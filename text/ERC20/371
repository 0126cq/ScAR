"function __redeemSharesSetup(        IVault vaultProxyContract,        address _redeemer,        uint256 _sharesQuantityInput,        bool _forSpecifiedAssets,        uint256 _gavIfCalculated    ) private returns (uint256 sharesToRedeem_, uint256 sharesSupply_) {        __assertSharesActionNotTimelocked(address(vaultProxyContract), _redeemer);        ERC20 sharesContract = <mask0>;        uint256 preFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);        if (_sharesQuantityInput == type(uint256).max) {            sharesToRedeem_ = preFeesRedeemerSharesBalance;        } else {            sharesToRedeem_ = _sharesQuantityInput;        }        require(sharesToRedeem_ > 0, \"__redeemSharesSetup: No shares to redeem\");        __preRedeemSharesHook(_redeemer, sharesToRedeem_, _forSpecifiedAssets, _gavIfCalculated);        uint256 postFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);        if (_sharesQuantityInput == type(uint256).max) {            sharesToRedeem_ = postFeesRedeemerSharesBalance;        } else if (postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance) {            sharesToRedeem_ = sharesToRedeem_.sub(                preFeesRedeemerSharesBalance.sub(postFeesRedeemerSharesBalance)            );        }        vaultProxyContract.payProtocolFee();        if (_gavIfCalculated > 0 && doesAutoProtocolFeeSharesBuyback()) {            __buyBackMaxProtocolFeeShares(address(vaultProxyContract), _gavIfCalculated);        }        sharesSupply_ = sharesContract.totalSupply();        vaultProxyContract.burnShares(_redeemer, sharesToRedeem_);        return (sharesToRedeem_, sharesSupply_);    }"