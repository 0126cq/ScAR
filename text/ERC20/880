"function __buyShares(        address _buyer,        uint256 _investmentAmount,        uint256 _minSharesQuantity,        bool _hasSharesActionTimelock,        address _canonicalSender    ) private locksReentrance allowsPermissionedVaultAction returns (uint256 sharesReceived_) {        require(_minSharesQuantity > 0, \"__buyShares: _minSharesQuantity must be >0\");        address vaultProxyCopy = getVaultProxy();        require(            !_hasSharesActionTimelock || !__hasPendingMigrationOrReconfiguration(vaultProxyCopy),            \"__buyShares: Pending migration or reconfiguration\"        );        uint256 gav = calcGav();        __preBuySharesHook(_buyer, _investmentAmount, gav);        IVault(vaultProxyCopy).payProtocolFee();        if (doesAutoProtocolFeeSharesBuyback()) {            __buyBackMaxProtocolFeeShares(vaultProxyCopy, gav);        }        uint256 receivedInvestmentAmount = __transferFromWithReceivedAmount(            getDenominationAsset(),            _canonicalSender,            vaultProxyCopy,            _investmentAmount        );        uint256 sharePrice = __calcGrossShareValue(            gav,            ERC20(vaultProxyCopy).totalSupply(),            10**uint256(ERC20(getDenominationAsset()).decimals())        );        uint256 sharesIssued = receivedInvestmentAmount.mul(SHARES_UNIT).div(sharePrice);        uint256 prevBuyerShares = ERC20(vaultProxyCopy).balanceOf(_buyer);        IVault(vaultProxyCopy).mintShares(_buyer, sharesIssued);        __postBuySharesHook(_buyer, receivedInvestmentAmount, sharesIssued, gav);        sharesReceived_ = <mask0>.balanceOf(_buyer).sub(prevBuyerShares);        require(            sharesReceived_ >= _minSharesQuantity,            \"__buyShares: Shares received < _minSharesQuantity\"        );        if (_hasSharesActionTimelock) {            acctToLastSharesBoughtTimestamp[_buyer] = block.timestamp;        }        emit SharesBought(_buyer, receivedInvestmentAmount, sharesIssued, sharesReceived_);        return sharesReceived_;    }"