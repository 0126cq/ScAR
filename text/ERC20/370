"function redeemSharesInKind(        address _recipient,        uint256 _sharesQuantity,        address[] calldata _additionalAssets,        address[] calldata _assetsToSkip    )        external        locksReentrance        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)    {        address canonicalSender = __msgSender();        require(            _additionalAssets.isUniqueSet(),            \"redeemSharesInKind: _additionalAssets contains duplicates\"        );        require(            _assetsToSkip.isUniqueSet(),            \"redeemSharesInKind: _assetsToSkip contains duplicates\"        );        payoutAssets_ = __parseRedemptionPayoutAssets(            IVault(vaultProxy).getTrackedAssets(),            _additionalAssets,            _assetsToSkip        );        uint256 gavOrZero;        if (doesAutoProtocolFeeSharesBuyback()) {            try this.calcGav() returns (uint256 gav) {                gavOrZero = gav;            } catch {                emit RedeemSharesInKindCalcGavFailed();            }        }        (uint256 sharesToRedeem, uint256 sharesSupply) = __redeemSharesSetup(            IVault(vaultProxy),            canonicalSender,            _sharesQuantity,            false,            gavOrZero        );        payoutAmounts_ = new uint256[](payoutAssets_.length);        for (uint256 i; i < payoutAssets_.length; i++) {            payoutAmounts_[i] = <mask0>                .balanceOf(vaultProxy)                .mul(sharesToRedeem)                .div(sharesSupply);            if (payoutAmounts_[i] > 0) {                IVault(vaultProxy).withdrawAssetTo(                    payoutAssets_[i],                    _recipient,                    payoutAmounts_[i]                );            }        }        emit SharesRedeemed(            canonicalSender,            _recipient,            sharesToRedeem,            payoutAssets_,            payoutAmounts_        );        return (payoutAssets_, payoutAmounts_);    }"