"function withdraw(uint256 assets, address receiver, address owner) public returns (uint256 shares) {        if (assets == 0) revert ZeroAssets();        if (balanceOf[owner] == 0) revert ZeroShares();        uint256 withdrawnActiveShares;        uint256 withdrawnInactiveShares;        uint256 withdrawnInactiveAssets;        uint256 originalDepositedAssets;         uint256 exchangeRate = convertToAssets(1e18);        UserDeposit[] storage deposits = userDeposits[owner];        uint256 leftToWithdraw = assets;        for (uint256 i = deposits.length - 1; i + 1 != 0; i--) {            UserDeposit storage d = deposits[i];            uint256 dAssets = d.assets;            if (dAssets != 0) {                uint256 dShares = d.shares;                uint256 withdrawnAssets;                uint256 withdrawnShares;                if (d.timeDeposited < lastTimeEnteredStrategy) {                    dAssets = exchangeRate * dShares / 1e18;                    withdrawnAssets = MathUtils.min(leftToWithdraw, dAssets);                    withdrawnShares = MathUtils.mulDivUp(dShares, withdrawnAssets, dAssets);                    uint256 originalDepositWithdrawn = MathUtils.mulDivUp(d.assets, withdrawnShares, dShares);                    d.assets -= originalDepositWithdrawn;                    originalDepositedAssets += originalDepositWithdrawn;                    withdrawnActiveShares += withdrawnShares;                } else {                    withdrawnAssets = MathUtils.min(leftToWithdraw, dAssets);                    withdrawnShares = MathUtils.mulDivUp(dShares, withdrawnAssets, dAssets);                    d.assets -= withdrawnAssets;                    withdrawnInactiveShares += withdrawnShares;                    withdrawnInactiveAssets += withdrawnAssets;                }                d.shares -= withdrawnShares;                leftToWithdraw -= withdrawnAssets;            }            if (i == 0 || leftToWithdraw == 0) break;        }        shares = withdrawnActiveShares + withdrawnInactiveShares;        if (msg.sender != owner) {            uint256 allowed = allowance[owner][msg.sender];             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;        }        uint256 withdrawnActiveAssets = exchangeRate * withdrawnActiveShares / 1e18;        if (withdrawnActiveAssets > 0) {            uint256 gain = withdrawnActiveAssets - originalDepositedAssets;            uint256 feeInAssets = gain * PERFORMANCE_FEE / DENOMINATOR;            uint256 fees = convertToShares(feeInAssets);            if (fees > 0) {                accruedPerformanceFees += fees;                withdrawnActiveAssets -= feeInAssets;                _mint(address(this), fees);            }        }        _burn(owner, shares);        if (withdrawnActiveAssets > 0) {            if (!isShutdown) {                lendingPool.withdraw(currentLendingToken, withdrawnActiveAssets, receiver);            } else {                ERC20(currentLendingToken).transfer(receiver, withdrawnActiveAssets);            }        }        if (withdrawnInactiveAssets > 0) {            <mask0>.transfer(receiver, withdrawnInactiveAssets);        }        emit Withdraw(msg.sender, receiver, owner, assets, shares);    }"