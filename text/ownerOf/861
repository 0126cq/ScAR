"function mintTickets(\t\tuint256[] memory _ticketTypes,\t\tuint256[] memory _amounts,\t\tuint16[] memory _rocketIds,\t\tuint16[] memory _patchIds,\t\tuint256 _fromTimestamp,\t\tuint256 _toTimestamp,\t\tbytes calldata _signature\t) external contractIsNotFrozen callerIsUser {\t\trequire(_ticketTypes.length == _amounts.length, \"Amount of mints per tickets does not match the ticket array\");\t\tuint256 _totalTicketsAmount;\t\tfor (uint256 i; i < _amounts.length; i++) {\t\t\t_totalTicketsAmount += _amounts[i];\t\t}\t\trequire(\t\t\t_rocketIds.length + _patchIds.length == _totalTicketsAmount,\t\t\t\"The amount of tickets to be minted does not match the rockets and patches\"\t\t);\t\tbytes32 messageHash = generateMessageHash(\t\t\tmsg.sender,\t\t\t_fromTimestamp,\t\t\t_toTimestamp,\t\t\t_ticketTypes,\t\t\t_amounts,\t\t\t_rocketIds,\t\t\t_patchIds\t\t);\t\taddress recoveredWallet = ECDSA.recover(messageHash, _signature);\t\trequire(recoveredWallet == signerAddress, \"Invalid signature for the caller\");\t\trequire(block.timestamp >= _fromTimestamp, \"Too early to mint\");\t\trequire(block.timestamp <= _toTimestamp, \"Mint window is closed\");\t\tfor (uint256 i; i < _rocketIds.length; i++) {\t\t\trequire(!usedRockets[_rocketIds[i]], \"Ticket already claimed for the given Rocket\");\t\t\trequire(rocketsContract.<mask0> == msg.sender, \"Invalid owner for the given rocketId\");\t\t\tusedRockets[_rocketIds[i]] = true;\t\t\temit RocketUsed(msg.sender, _rocketIds[i]);\t\t}\t\tfor (uint256 i; i < _patchIds.length; i++) {\t\t\trequire(!usedPatches[_patchIds[i]], \"Ticket already claimed for the given Patch\");\t\t\trequire(patchesContract.ownerOf(_patchIds[i]) == msg.sender, \"Invalid owner for the given patchId\");\t\t\tusedPatches[_patchIds[i]] = true;\t\t\temit PatchUsed(msg.sender, _patchIds[i]);\t\t}\t\tfor (uint256 i; i < _ticketTypes.length; i++) {\t\t\trequire(_ticketTypes[i] < TICKET_TYPES_QTY, \"Invalid ticket type\");\t\t}\t\t_mintBatch(msg.sender, _ticketTypes, _amounts, \"\");\t}"