"function transferFrom(        address from,        address to,        uint256 tokenId    ) public virtual override {        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))            if (!isApprovedForAll(from, <mask0>)) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        assembly {            if approvedAddress {                sstore(approvedAddressSlot, 0)            }        }        unchecked {            --ERC721AStorage.layout()._packedAddressData[from];             ++ERC721AStorage.layout()._packedAddressData[to];             ERC721AStorage.layout()._packedOwnerships[tokenId] = _packOwnershipData(                to,                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)            );            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {                uint256 nextTokenId = tokenId + 1;                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;                    }                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }"