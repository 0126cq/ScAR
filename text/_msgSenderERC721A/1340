"function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);        address from = address(uint160(prevOwnershipPacked));        address approvedAddress = _tokenApprovals[tokenId];        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSenderERC721A() == from ||                isApprovedForAll(from, <mask0>) ||                approvedAddress == _msgSenderERC721A());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        if (_addressToUint256(approvedAddress) != 0) {            delete _tokenApprovals[tokenId];        }        unchecked {            _packedAddressData[from] += (1 << BITPOS_NUMBER_BURNED) - 1;            _packedOwnerships[tokenId] =                _addressToUint256(from) |                (block.timestamp << BITPOS_START_TIMESTAMP) |                BITMASK_BURNED |                BITMASK_NEXT_INITIALIZED;            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {                uint256 nextTokenId = tokenId + 1;                if (_packedOwnerships[nextTokenId] == 0) {                    if (nextTokenId != _currentIndex) {                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;                    }                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }"