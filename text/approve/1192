"function deposit(         uint _amount,         uint _maxPrice,        address _depositor    ) external returns ( uint ) {        require( _depositor != address(0), \"Invalid address\" );        require(msg.sender == _depositor || allowedZappers[msg.sender], \"LFNA\");        decayDebt();        uint priceInUSD = bondPriceInUSD();         uint nativePrice = _bondPrice();        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" );         uint value = treasury.valueOf( address(principle), _amount );        uint payout = payoutFor( value );         require( totalDebt.add(value) <= terms.maxDebt, \"Max capacity reached\" );        require( payout >= 10000000, \"Bond too small\" );         require( payout <= maxPayout(), \"Bond too large\");         uint fee = payout.mul( terms.fee )/ 10000 ;        uint profit = value.sub( payout ).sub( fee );        uint balanceBefore = Sigma.balanceOf(address(this));        principle.safeTransferFrom( msg.sender, address(this), _amount );        principle.<mask0>;        treasury.deposit( _amount, address(principle), profit );        if ( fee != 0 ) {             Sigma.safeTransfer( DAO, fee );         }        require(balanceBefore.add(profit) == Sigma.balanceOf(address(this)), \"Not enough Sigma to cover profit\");        totalDebt = totalDebt.add( value );         bondInfo[ _depositor ] = Bond({             payout: bondInfo[ _depositor ].payout.add( payout ),            vesting: terms.vestingTerm,            lastTime: uint32(block.timestamp),            pricePaid: priceInUSD        });        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );        adjust();         return payout;     }"