"function crossBuy(        uint16 dstChainId,        ERC20Infos memory sourceTokenDetails,        PaymentInfo memory payInfo,        OrderDetails[] memory _orderDetails,        address to,        address destAddress,        uint256 deadline    ) external payable whenNotPaused {        uint256 bridgeAmount;        uint256 value = msg.value;        _erc20TranasferHelper(sourceTokenDetails);        {            for (uint256 i = 0; i < sourceTokenDetails.tokenAddrs.length; i++) {                address[] memory path = new address[](2);                path[0] = sourceTokenDetails.tokenAddrs[i] == address(0x0)                    ? IUniswapV2Router02(swapRouter).WETH()                    : sourceTokenDetails.tokenAddrs[i];                path[1] = payInfo.bridgeToken;                uint256[] memory amounts;                if (sourceTokenDetails.tokenAddrs[i] == payInfo.bridgeToken) {                    bridgeAmount += sourceTokenDetails.amounts[i];                    continue;                }                if (sourceTokenDetails.tokenAddrs[i] == address(0x0)) {                    amounts = IUniswapV2Router02(swapRouter)                        .swapExactETHForTokens{                        value: sourceTokenDetails.amounts[i]                    }(0, path, address(this), deadline);                    value -= sourceTokenDetails.amounts[i];                } else {                    IERC20(sourceTokenDetails.tokenAddrs[i]).approve(                        swapRouter,                        sourceTokenDetails.amounts[i]                    );                    amounts = IUniswapV2Router02(swapRouter)                        .swapExactTokensForTokens(                            sourceTokenDetails.amounts[i],                            0,                            path,                            address(this),                            deadline                        );                }                bridgeAmount += amounts[1];            }        }        IERC20(payInfo.bridgeToken).<mask0>;        require(            bridgeAmount >= payInfo.amountOutMinDest,            \"Bridge amount not enough\"        );        bytes memory data;        {            data = abi.encode(to, _orderDetails);        }        IStargateRouter(stargateRouter).swap{value: value}(            dstChainId,            payInfo.srcPoolId,            payInfo.dstPoolId,            payable(msg.sender),            bridgeAmount,            0,            IStargateRouter.lzTxObj(500000, 0, \"0x\"),            abi.encodePacked(destAddress),            data        );    }"