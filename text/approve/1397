"function deposit(         uint _amount,         uint _maxPrice,        address _depositor    ) external returns ( uint ) {        require( _depositor != address(0), \"Invalid address\" );        decayDebt();        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );        uint priceInUSD = bondPriceInUSD();         require( _maxPrice >= _bondPrice(), \"Slippage limit: more than max price\" );         uint value = ITreasury( treasury ).valueOf( principle, _amount );        uint payout = payoutFor( value );         require( payout >= 10000000, \"Bond too small\" );         require( payout <= maxPayout(), \"Bond too large\");         uint fee = payout.mul( terms.fee ).div( 10000 );        uint profit = value.sub( payout ).sub( fee );        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );        IERC20( principle ).<mask0>;        ITreasury( treasury ).deposit( _amount, principle, profit );        totalPrinciple=totalPrinciple.add(_amount);        if ( fee != 0 ) {             IERC20( HEC ).safeTransfer( DAO, fee );         }        totalDebt = totalDebt.add( value );         IERC20( HEC ).approve( staking, payout );        IStaking( staking ).stake( payout, address(this) );        IStaking( staking ).claim( address(this) );        uint stakeGons=ISHEC(sHEC).gonsForBalance(payout);        _bondInfo[ _depositor ] = Bond({             gonsPayout: _bondInfo[ _depositor ].gonsPayout.add( stakeGons ),            hecPayout: _bondInfo[ _depositor ].hecPayout.add( payout ),            vesting: terms.vestingTerm,            lastBlock: block.number,            pricePaid: priceInUSD        });        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );        adjust();         return payout;     }"