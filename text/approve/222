"function setToken(        uint256 currencyId,        bool underlying,        TokenStorage memory tokenStorage    ) internal {        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {            TokenStorage storage ts = store[currencyId][true];            ts.tokenAddress = address(0);            ts.hasTransferFee = false;            ts.tokenType = TokenType.Ether;            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;            ts.maxCollateralBalance = 0;            return;        }        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");        Token memory token = _getToken(currencyId, underlying);        require(            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),            \"TH: token cannot be reset\"        );        require(0 < tokenStorage.decimalPlaces             && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \"TH: invalid decimals\");        require(tokenStorage.tokenType != TokenType.Ether);         if (underlying) {            require(tokenStorage.maxCollateralBalance == 0);             require(tokenStorage.tokenType == TokenType.UnderlyingToken);         } else {            require(tokenStorage.tokenType != TokenType.UnderlyingToken);         }        if (tokenStorage.tokenType == TokenType.cToken || tokenStorage.tokenType == TokenType.aToken) {            Token memory underlyingToken = getUnderlyingToken(currencyId);            address approvalAddress = tokenStorage.tokenType == TokenType.cToken ?                tokenStorage.tokenAddress :                address(LibStorage.getLendingPool().lendingPool);            IEIP20NonStandard(underlyingToken.tokenAddress).<mask0>;            GenericToken.checkReturnCode();        }        store[currencyId][underlying] = tokenStorage;    }"