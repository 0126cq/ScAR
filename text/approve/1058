"function _executeOperation(        address[] calldata assets,        uint256[] calldata amounts,        uint256[] calldata premiums,        OperationData memory opData    ) internal returns (bool) {        OperationContracts memory opContracts = _getContracts(opData.contracts);        LoanLibraryV1.LoanData memory loanData = opContracts.loanCore.getLoan(opData.loanId);        address borrower = opContracts.borrowerNote.ownerOf(loanData.borrowerNoteId);        (uint256 flashAmountDue, uint256 needFromBorrower, uint256 leftoverPrincipal) = _ensureFunds(            amounts[0],            premiums[0],            opContracts.feeController.getOriginationFee(),            opData.newLoanTerms.principal        );        IERC20 asset = IERC20(assets[0]);        if (needFromBorrower > 0) {            require(asset.balanceOf(borrower) >= needFromBorrower, \"borrower cannot pay\");            require(asset.allowance(borrower, address(this)) >= needFromBorrower, \"lacks borrower approval\");        }        _repayLoan(opContracts, loanData, borrower);        {            _recreateBundle(opContracts, loanData, opData.newLoanTerms.collateralId);            uint256 newLoanId = _initializeNewLoan(                opContracts,                borrower,                opData.lender,                opData            );            emit Rollover(                opContracts.lenderNote.ownerOf(loanData.lenderNoteId),                borrower,                loanData.terms.collateralTokenId,                newLoanId            );            if (address(opData.contracts.sourceLoanCore) != address(opData.contracts.targetLoanCore)) {                emit Migration(address(opContracts.loanCore), address(opContracts.targetLoanCore), newLoanId);            }        }        if (leftoverPrincipal > 0) {            asset.safeTransfer(borrower, leftoverPrincipal);        } else if (needFromBorrower > 0) {            asset.safeTransferFrom(borrower, address(this), needFromBorrower);        }        asset.<mask0>;        return true;    }"