"function clipperCall(        address sender,                 uint256 daiAmt,                 uint256 gemAmt,                 bytes calldata data         ) external {        (            address to,                       address gemJoin,                  uint256 minProfit,                address[] memory pathA,             address[] memory pathB          ) = abi.decode(data, (address, address, uint256, address[], address[]));        gemAmt = _fromWad(gemJoin, gemAmt);        GemJoinLike_2(gemJoin).exit(address(this), gemAmt);        TokenLike_2 gem = GemJoinLike_2(gemJoin).gem();        gem.<mask0>;        uint256 daiToJoin = divup(daiAmt, RAY);        try gem.token0() returns (TokenLike_2 tokenA) {             TokenLike_2 tokenB = gem.token1();            uniRouter02.removeLiquidity({                 tokenA: address(tokenA),                tokenB: address(tokenB),                liquidity: gemAmt,                amountAMin: 0,                 amountBMin: 0,                to: address(this),                deadline: block.timestamp            });            if (address(tokenA) != address(dai)) {                swapGemForDai(tokenA, pathA, to);            }            if (address(tokenB) != address(dai)) {                swapGemForDai(tokenB, pathB, to);            }            require(                dai.balanceOf(address(this)) >= add(daiToJoin, minProfit),                \"UniswapV2Callee/insufficient-profit\"            );        } catch {                                                 uniRouter02.swapExactTokensForTokens(                gemAmt,                add(daiToJoin, minProfit),                pathA,                address(this),                block.timestamp            );        }        if (gem.balanceOf(address(this)) > 0) {            gem.transfer(to, gem.balanceOf(address(this)));        }        daiJoin.join(sender, daiToJoin);        dai.transfer(to, dai.balanceOf(address(this)));    }"