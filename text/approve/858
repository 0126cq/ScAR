"function _liquidateAndSwap(    address collateralAsset,    address borrowedAsset,    address user,    uint256 debtToCover,    bool useEthPath,    uint256 flashBorrowedAmount,    uint256 premium,    address initiator  ) internal {    LiquidationCallLocalVars memory vars;    vars.initCollateralBalance = IERC20(collateralAsset).balanceOf(address(this));    if (collateralAsset != borrowedAsset) {      vars.initFlashBorrowedBalance = IERC20(borrowedAsset).balanceOf(address(this));      vars.borrowedAssetLeftovers = vars.initFlashBorrowedBalance.sub(flashBorrowedAmount);    }    vars.flashLoanDebt = flashBorrowedAmount.add(premium);    IERC20(borrowedAsset).<mask0>;    LENDING_POOL.liquidationCall(collateralAsset, borrowedAsset, user, debtToCover, false);    uint256 collateralBalanceAfter = IERC20(collateralAsset).balanceOf(address(this));    vars.diffCollateralBalance = collateralBalanceAfter.sub(vars.initCollateralBalance);    if (collateralAsset != borrowedAsset) {      uint256 flashBorrowedAssetAfter = IERC20(borrowedAsset).balanceOf(address(this));      vars.diffFlashBorrowedBalance = flashBorrowedAssetAfter.sub(vars.borrowedAssetLeftovers);      vars.soldAmount = _swapTokensForExactTokens(        collateralAsset,        borrowedAsset,        vars.diffCollateralBalance,        vars.flashLoanDebt.sub(vars.diffFlashBorrowedBalance),        useEthPath      );      vars.remainingTokens = vars.diffCollateralBalance.sub(vars.soldAmount);    } else {      vars.remainingTokens = vars.diffCollateralBalance.sub(premium);    }    IERC20(borrowedAsset).approve(address(LENDING_POOL), vars.flashLoanDebt);    if (vars.remainingTokens > 0) {      IERC20(collateralAsset).transfer(initiator, vars.remainingTokens);    }  }"