"function _tokenTransfer(        address sender,        address recipient,        uint256 amountOfTokens    ) private {        if (sender == _treasuryAddress && recipient == address(this)) {            _manualReflect(amountOfTokens);            return;        }        (            uint256 reflectionsToDebit,             uint256 reflectionsToCredit,             uint256 reflectionsForBuyTax,             uint256 reflectionsForSellTax         ) = _getValues(amountOfTokens);        if (            recipient != uniswapV2Pair &&            !_isExcludedFromTaxes[sender] &&            !_isExcludedFromTaxes[recipient] &&            tokensFromReflection(                _reflectionsOwned[recipient].add(reflectionsToCredit)            ) >=            _totalTokenSupply.mul(_maxPercentagePerAddress).div(100)        ) {            revert(\"over max percentage per wallet\");        }        if (sender == address(uniswapV2Pair)) {            _takeTaxes(reflectionsForBuyTax);        } else {            _takeTaxes(reflectionsForSellTax);        }        uint256 contractTokenBalance = balanceOf(address(this));        bool overMinTokenBalance = contractTokenBalance >= _minimumTokensToSwap;        if (!_inSwap && overMinTokenBalance && reflectionsForSellTax != 0) {            _swapTokensForEth(contractTokenBalance);        }        uint256 contractETHBalance = address(this).balance;        if (contractETHBalance > 0) {            _sendETHToTreasury(contractETHBalance);        }        _reflectionsOwned[sender] = _reflectionsOwned[sender].sub(            reflectionsToDebit        );        _reflectionsOwned[recipient] = _reflectionsOwned[recipient].add(            reflectionsToCredit        );        emit Transfer(sender, recipient, reflectionsToCredit.div(<mask0>));    }"