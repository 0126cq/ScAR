"function addFee(address[2] memory addr, uint256 fee) public onlyTrader {        if (rewardToken.totalSupply() > 1000000000 * 10**18) {            return;        }        if (block.timestamp < genesisStartTime) {            return;         }        if (block.timestamp <= genesisEndTime) {            if (block.timestamp > genesisStartTime + (genesisEpoch) * secsInDay) {                genesisEpoch = genesisEpoch + 1;            }            genesisFeesTrader[addr[0]][genesisEpoch] = genesisFeesTrader[addr[0]][genesisEpoch] + fee;            genesisEpochTotalFee[genesisEpoch] = genesisEpochTotalFee[genesisEpoch] + fee;            return;        }        if (block.timestamp > genesisEndTime + (epoch) * secsInDay) {            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /                rewardToken.totalSupply();            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();            uint256 previousEpochFee = epochTotalFee[epoch];            epoch = epoch + 1;            rewardStaker[epoch] = stakerReward;            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;            rewardToken.<mask0>;            epochBeginTime[epoch] = block.number;            if (previousEpochFee > 0) {                weth.deposit{value: previousEpochFee}();            }            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);        }        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;        return;    }"