"function depositFor(        bytes32 contextId,        address provider,        Token pool,        uint256 baseTokenAmount    ) external only(address(_network)) validAddress(provider) greaterThanZero(baseTokenAmount) returns (uint256) {        Pool storage data = _poolStorage(pool);        if (!data.depositingEnabled) {            revert DepositingDisabled();        }        PoolLiquidity memory prevLiquidity = data.liquidity;        uint256 currentStakedBalance = prevLiquidity.stakedBalance;        uint256 prevPoolTokenTotalSupply = data.poolToken.totalSupply();        if (prevPoolTokenTotalSupply == 0 && currentStakedBalance != 0) {            currentStakedBalance = 0;            _resetTradingLiquidity(contextId, pool, data, TRADING_STATUS_UPDATE_INVALID_STATE);        }        uint256 poolTokenAmount = _underlyingToPoolToken(            baseTokenAmount,            prevPoolTokenTotalSupply,            currentStakedBalance        );        data.liquidity.stakedBalance = currentStakedBalance + baseTokenAmount;        data.poolToken.<mask0>;        _updateTradingLiquidity(            contextId,            pool,            data,            data.averageRates.rate.fromFraction112(),            _networkSettings.minLiquidityForTrading()        );        if (data.tradingEnabled) {            _updateAverageRates(                data,                Fraction({ n: data.liquidity.bntTradingLiquidity, d: data.liquidity.baseTokenTradingLiquidity })            );        }        emit TokensDeposited({            contextId: contextId,            provider: provider,            token: pool,            baseTokenAmount: baseTokenAmount,            poolTokenAmount: poolTokenAmount        });        _dispatchTradingLiquidityEvents(            contextId,            pool,            prevPoolTokenTotalSupply + poolTokenAmount,            prevLiquidity,            data.liquidity        );        return poolTokenAmount;    }"