"function borrow(        uint256 positionId,        uint256 collateralAmount,        uint256 borrowAmount    )        internal        returns (TypesV1.Position memory)    {        TypesV1.Position memory position = state.getPosition(positionId);        require(            state.isCollateralized(position) == true,            \"borrowPosition(): position is not collateralised\"        );        require(            position.owner == msg.sender,            \"borrowPosition(): must be a valid position\"        );        Decimal.D256 memory currentPrice = state.getCurrentPrice();        position = state.updatePositionAmount(            positionId,            position.collateralAsset,            TypesV1.Par({                sign: true,                value: collateralAmount.to128()            })        );        state.updateTotalSupplied(collateralAmount);        if (borrowAmount > 0) {            TypesV1.Par memory newPar = position.borrowedAmount.add(                TypesV1.Par({                    sign: false,                    value: borrowAmount.to128()                })            );            position = state.setAmount(                positionId,                position.borrowedAsset,                newPar            );            TypesV1.Par memory collateralRequired = state.calculateInverseRequired(                position.borrowedAsset,                position.borrowedAmount.value,                currentPrice            );            require(                position.collateralAmount.value >= collateralRequired.value,                \"borrowPosition(): not enough collateral provided\"            );        }        IERC20 syntheticAsset = IERC20(state.syntheticAsset());        IERC20 collateralAsset = IERC20(state.collateralAsset());        SafeERC20.safeTransferFrom(            collateralAsset,            msg.sender,            address(syntheticAsset),            collateralAmount        );        ISyntheticToken(address(syntheticAsset)).<mask0>;        return position;    }"