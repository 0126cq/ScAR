"function _borrow(    address asset,    uint256 amount,    address nftAsset,    uint256 nftTokenId,    address onBehalfOf,    uint16 referralCode  ) internal {    require(onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);    ExecuteBorrowLocalVars memory vars;    vars.initiator = _msgSender();    DataTypes.ReserveData storage reserveData = _reserves[asset];    DataTypes.NftData storage nftData = _nfts[nftAsset];    reserveData.updateState();    vars.reserveOracle = _addressesProvider.getReserveOracle();    vars.nftOracle = _addressesProvider.getNFTOracle();    vars.loanAddress = _addressesProvider.getLendPoolLoan();    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(nftAsset, nftTokenId);    ValidationLogic.validateBorrow(      onBehalfOf,      asset,      amount,      reserveData,      nftAsset,      nftData,      vars.loanAddress,      vars.loanId,      vars.reserveOracle,      vars.nftOracle    );    if (vars.loanId == 0) {      IERC721Upgradeable(nftAsset).safeTransferFrom(_msgSender(), address(this), nftTokenId);      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(        vars.initiator,        onBehalfOf,        nftAsset,        nftTokenId,        nftData.bNftAddress,        asset,        amount,        reserveData.variableBorrowIndex      );    } else {      ILendPoolLoan(vars.loanAddress).updateLoan(        vars.initiator,        vars.loanId,        amount,        0,        reserveData.variableBorrowIndex      );    }    IDebtToken(reserveData.debtTokenAddress).<mask0>;    reserveData.updateInterestRates(asset, reserveData.bTokenAddress, 0, amount);    IBToken(reserveData.bTokenAddress).transferUnderlyingTo(vars.initiator, amount);    emit Borrow(      vars.initiator,      asset,      amount,      nftAsset,      nftTokenId,      onBehalfOf,      reserveData.currentVariableBorrowRate,      vars.loanId,      referralCode    );  }"