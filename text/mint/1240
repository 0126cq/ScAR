"function wlPurchase(uint256 qty, uint8 v, bytes32 r, bytes32 s) public payable nonReentrant whenNotPaused {\t\trequire(qty > 0, \"Invalid qty\");        require(block.timestamp >= saleStart && block.timestamp <= saleStart+wlPeriod, \"Not wl sales\");        require(nft.totalSupply() + qty <= supplyLimit, \"Exceed supply limit\");\t\tbytes32 hashedMsg = keccak256(abi.encodePacked(address(this), address(msg.sender)));\t\tbytes32 digest = keccak256(abi.encodePacked(PREFIX, hashedMsg));\t\taddress recovered = ecrecover(digest, v, r, s);\t\trequire(hasRole(WL_SIGNER_ROLE, recovered), \"Permission denied\");\t\tpurchaseInfo storage myPurchaseNft = purchaseHistory[msg.sender];\t\tuint256 freeQuota = maxWlFreeMint - myPurchaseNft.wlFreeMint;\t\tuint256 orderPrice;\t\tuint256 freeMint;\t\tuint256 paidMint;\t\tif (qty > freeQuota) {\t\t\tfreeMint = freeQuota;\t\t\tpaidMint = (qty - freeQuota);\t\t\torderPrice = salePrice * paidMint;\t\t} else {\t\t\tfreeMint = qty;\t\t\tpaidMint = 0;\t\t\torderPrice = 0;\t\t}\t\trequire(orderPrice == msg.value, \"Incorrect eth value\");\t\tnft.<mask0>;        myPurchaseNft.wlFreeMint += freeMint;\t\tmyPurchaseNft.paidMint += qty - freeMint;\t\tif (orderPrice > 0) {\t\t\tpayable(beneficiary).transfer(address(this).balance);\t\t}    }"