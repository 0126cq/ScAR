"function claim(uint256 tokenId, bool unstake, uint256 nonce, uint256 amountV, bytes32 r, bytes32 s) external override requireContractsSet nonReentrant {        require(tx.origin == _msgSender(), \"Only EOA\");        require(userStake[_msgSender()] == tokenId, \"Must own this token\");        require(tokenStakedBy[tokenId] == _msgSender(), \"Must own this token\");        require(!nonceUsed[nonce], \"Claim already used\");        nonceUsed[nonce] = true;        uint256 amount = uint248(amountV >> 8);        uint8 v = uint8(amountV);        bytes32 digest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",            keccak256(abi.encode(MINT_CALL_HASH_TYPE, nonce, _msgSender(), amount))        ));        address signedBy = ecrecover(digest, v, r, s);        require(signedBy == signer, \"Invalid signer\");        if (unstake) {            userStake[_msgSender()] = 0;            tokenStakedBy[tokenId] = address(0);            userUnstakeFaction[_msgSender()] = blockverse.getTokenFaction(tokenId);            userUnstakeTime[_msgSender()] = block.timestamp;            blockverse.safeTransferFrom(address(this), _msgSender(), tokenId, \"\");        }        diamonds.<mask0>;        emit Claim(tokenId, amount, unstake);    }"