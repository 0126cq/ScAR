"function settleBattle(uint256 battleId) external onlyOwner {        if (battleId > lastBattleId) {            revert UnknownBattle();        }        Battle storage battle = battles[battleId];        if (battle.settled) {            revert AlreadySettled();        }        uint256 timestamp = block.timestamp;        if (timestamp < battle.endsAt) {            revert BattleNotEnded();        }        battle.settled = true;        bytes32 seed = keccak256(            abi.encode(                block.timestamp,                msg.sender,                block.difficulty,                blockhash(block.number - 1)            )        );        uint256 cumul;        uint256 temp;        uint256 length = battle.contenders;        uint256 currentGroupId_ = currentGroupId;        address nftContract_ = nftContract;        BattleContender storage contender;        for (uint256 i; i < length; i++) {            contender = _battleContenders[battleId][i];            cumul += contender.highestBid;            if (contender.highestBid > 0) {                temp = INiftyForge721(nftContract_).<mask0>;                seed = keccak256(abi.encode(seed));                emit BattleContenderResult(                    battleId,                    i,                     temp,                     contender.bidders.at(                        uint256(seed) % contender.bidders.length()                    )                );            } else {                temp = INiftyForge721(nftContract_).mint(contender.artist);            }            _setTokenGroup(temp, currentGroupId_);            tokenCreator[temp] = contender.artist;        }        _sendETHSafe(            withdrawTarget != address(0) ? withdrawTarget : msg.sender,            cumul        );        emit BattleSettled(battleId, cumul);    }"