"function protectAgainstSlippage(uint256 _withdrawalAmount) external onlyManager         returns (uint256) {        require(_withdrawalAmount != 0, \"Formation.Fi: zero amount\");        require(netDepositInd == 0, \"Formation.Fi: no slippage\");       uint256 _amount = 0;        uint256 _deltaAmount =0;       uint256 _slippage = 0;       uint256  _tokenAmount = 0;       uint256 _balanceTokenTreasury = token.balanceOf(treasury);       uint256 _balanceStableTreasury = stableToken.balanceOf(treasury) * amountScaleDecimals;        if (_withdrawalAmount< netAmountEvent){            _amount = netAmountEvent - _withdrawalAmount;               _slippage = (_amount * FACTOR_FEES_DECIMALS ) / netAmountEvent;            if (_slippage >= slippageTolerance) {                return netAmountEvent;            }            else {                 _deltaAmount = Math.min( _amount, _balanceStableTreasury);                if ( _deltaAmount  > 0){                    stableToken.safeTransferFrom(treasury, investement, _deltaAmount/amountScaleDecimals);                    _tokenAmount = (_deltaAmount * FACTOR_PRICE_DECIMALS)/tokenPrice;                    token.<mask0>;                    return _amount - _deltaAmount;                }                else {                     return _amount;                 }              }            }        else  {           _amount = _withdrawalAmount - netAmountEvent;             _tokenAmount = (_amount * FACTOR_PRICE_DECIMALS)/tokenPrice;          _tokenAmount = Math.min(_tokenAmount, _balanceTokenTreasury);          if (_tokenAmount >0) {              _deltaAmount = (_tokenAmount * tokenPrice)/FACTOR_PRICE_DECIMALS;              stableToken.safeTransfer(treasury, _deltaAmount/amountScaleDecimals);                 token.burn( treasury, _tokenAmount);            }           if ((_amount - _deltaAmount) > 0) {              stableToken.safeTransfer(safeHouse, (_amount - _deltaAmount)/amountScaleDecimals);             }        }        return 0;    }"