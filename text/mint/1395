"function claimReward(address _depositAddress, bool isHarvest) public onlyOwner {        address[] memory supAddresses = getSupportAddresses(_depositAddress);         if (supAddresses[1] == SWERVE_GAUGE_ADDRESS) {            TokenMinter(SWERVE_TOKEN_MINTER_ADDRESS).<mask0>;        } else {            TokenMinter(CRV_TOKEN_MINTER_ADDRESS).mint(supAddresses[1]);        }        uint swerveTokenBalance = IERC20(SWERVE_TOKEN_ADDRESS).balanceOf(address(this));        uint crvTokenBalance = IERC20(CRV_TOKEN_ADDRESS).balanceOf(address(this));        if (isHarvest) {            uint _amount;            uint[] memory _distribution;            if (swerveTokenBalance > 0) {                IERC20(SWERVE_TOKEN_ADDRESS).approve(EXCHANGE_CONTRACT, swerveTokenBalance);                (_amount, _distribution) = IOneSplit(EXCHANGE_CONTRACT).getExpectedReturn(IERC20(SWERVE_TOKEN_ADDRESS), IERC20(DAI_ADDRESS), swerveTokenBalance, 100, 0);                IOneSplit(EXCHANGE_CONTRACT).swap(IERC20(SWERVE_TOKEN_ADDRESS), IERC20(DAI_ADDRESS), swerveTokenBalance, _amount, _distribution, 0);            }            if (crvTokenBalance > 0) {                IERC20(CRV_TOKEN_ADDRESS).approve(EXCHANGE_CONTRACT, crvTokenBalance);                (_amount, _distribution) = IOneSplit(EXCHANGE_CONTRACT).getExpectedReturn(IERC20(CRV_TOKEN_ADDRESS), IERC20(DAI_ADDRESS), crvTokenBalance, 100, 0);                IOneSplit(EXCHANGE_CONTRACT).swap(IERC20(CRV_TOKEN_ADDRESS), IERC20(DAI_ADDRESS), crvTokenBalance, _amount, _distribution, 0);            }            uint daiBalance = IERC20(DAI_ADDRESS).balanceOf(address(this));            if(daiBalance > 0) {                IERC20(DAI_ADDRESS).transfer(msg.sender, daiBalance);            }            return;        }        if(swerveTokenBalance > 0) {            IERC20(SWERVE_TOKEN_ADDRESS).transfer(msg.sender, swerveTokenBalance);        }        if(crvTokenBalance > 0) {            IERC20(CRV_TOKEN_ADDRESS).transfer(msg.sender, crvTokenBalance);        }    }"