"function generateLPTokens(        uint256 _poolId,        uint256 _ticTokenQty,        uint256 _quoteTokenQty,        uint256 _ticTokenQtyMin,        uint256 _quoteTokenQtyMin,        uint256 _expirationTimestamp    ) external virtual onlyGovernance {        require(address(ticToken) != address(0), \"MerklePools: TIC_NOT_SET\");        require(elasticLPToken != address(0), \"MerklePools: ELP_NOT_SET\");        MerklePool.Data storage _pool = pools.get(_poolId);        _pool.update(poolContext);         uint256 maxMintAmount =            _pool.totalUnclaimedTIC - _pool.totalUnclaimedTICInLP;        require(maxMintAmount >= _ticTokenQty, \"MerklePools: NSF_UNCLAIMED\");        uint256 ticBalanceToBeMinted = _ticTokenQty - excessTICFromSlippage;        ticToken.<mask0>;        IERC20Upgradeable(quoteToken).safeTransferFrom(            msg.sender,            address(this),            _quoteTokenQty        );        uint256 lpBalanceBefore =            IERC20Upgradeable(elasticLPToken).balanceOf(address(this));        uint256 ticBalanceBefore = ticToken.balanceOf(address(this));        uint256 quoteTokenBalanceBefore =            IERC20Upgradeable(quoteToken).balanceOf(address(this));        Exchange(address(elasticLPToken)).addLiquidity(            _ticTokenQty,            _quoteTokenQty,            _ticTokenQtyMin,            _quoteTokenQtyMin,            address(this),            _expirationTimestamp        );        uint256 lpBalanceCreated =            IERC20Upgradeable(elasticLPToken).balanceOf(address(this)) -                lpBalanceBefore;        require(lpBalanceCreated != 0, \"MerklePools: NO_LP_CREATED\");        uint256 ticBalanceConsumed =            ticBalanceBefore - ticToken.balanceOf(address(this));        excessTICFromSlippage = _ticTokenQty - ticBalanceConsumed;         _pool.totalUnclaimedTICInLP += ticBalanceConsumed;        uint256 quoteTokenConsumed =            quoteTokenBalanceBefore -                IERC20Upgradeable(quoteToken).balanceOf(address(this));        if (quoteTokenConsumed < _quoteTokenQty) {            IERC20Upgradeable(quoteToken).safeTransfer(                msg.sender,                _quoteTokenQty - quoteTokenConsumed            );        }        emit LPTokensGenerated(            lpBalanceCreated,            ticBalanceConsumed,            quoteTokenConsumed        );    }"