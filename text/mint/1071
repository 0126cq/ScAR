"function retrieveRewards(        address voterAddress,        uint256 roundId,        PendingRequestAncillary[] memory toRetrieve    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {        if (migratedAddress != address(0)) {            require(msg.sender == migratedAddress, \"Can only call from migrated\");        }        require(roundId < voteTiming.computeCurrentRoundId(getCurrentTime()), \"Invalid roundId\");        Round storage round = rounds[roundId];        bool isExpired = getCurrentTime() > round.rewardsExpirationTime;        FixedPoint.Unsigned memory snapshotBalance =            FixedPoint.Unsigned(votingToken.balanceOfAt(voterAddress, round.snapshotId));        FixedPoint.Unsigned memory snapshotTotalSupply =            FixedPoint.Unsigned(votingToken.totalSupplyAt(round.snapshotId));        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);        totalRewardToIssue = FixedPoint.Unsigned(0);        for (uint256 i = 0; i < toRetrieve.length; i++) {            PriceRequest storage priceRequest =                _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time, toRetrieve[i].ancillaryData);            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");            _resolvePriceRequest(priceRequest, voteInstance);            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {                continue;            } else if (isExpired) {                emit RewardsRetrieved(                    voterAddress,                    roundId,                    toRetrieve[i].identifier,                    toRetrieve[i].time,                    toRetrieve[i].ancillaryData,                    0                );            } else if (                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)            ) {                FixedPoint.Unsigned memory reward =                    snapshotBalance.mul(totalRewardPerVote).div(                        voteInstance.resultComputation.getTotalCorrectlyVotedTokens()                    );                totalRewardToIssue = totalRewardToIssue.add(reward);                emit RewardsRetrieved(                    voterAddress,                    roundId,                    toRetrieve[i].identifier,                    toRetrieve[i].time,                    toRetrieve[i].ancillaryData,                    reward.rawValue                );            } else {                emit RewardsRetrieved(                    voterAddress,                    roundId,                    toRetrieve[i].identifier,                    toRetrieve[i].time,                    toRetrieve[i].ancillaryData,                    0                );            }            delete voteInstance.voteSubmissions[voterAddress].revealHash;        }        if (totalRewardToIssue.isGreaterThan(0)) {            require(votingToken.<mask0>, \"Voting token issuance failed\");        }    }"