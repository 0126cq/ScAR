"function swapBack() internal swapping {        uint256 dynamicliquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;        uint256 amountToLiquify = swapThreshold.mul(dynamicliquidityFee).div(totalFee).div(2);        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = WBNB;        uint256 balanceBefore = address(this).balance;        router.<mask0>;        uint256 amountBNB = address(this).balance.sub(balanceBefore);        uint256 totalBNBFee = totalFee.sub(dynamicliquidityFee.div(2));        uint256 amountBNBLiquidity = amountBNB.mul(dynamicliquidityFee).div(totalBNBFee).div(2);        uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(totalBNBFee);        uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(totalBNBFee);        uint256 amountBNBDev = amountBNB.mul(devFee).div(totalBNBFee);        if (amountBNBReflection > 0){            try distributor.deposit{value: amountBNBReflection}() {} catch {}        }        (bool tmpSuccess,) = payable(marketingFeeReceiver).call{value: amountBNBMarketing, gas: 30000}(\"\");        (bool tmpSuccessDev,) = payable(devFeeReceiver).call{value: amountBNBDev, gas: 30000}(\"\");        tmpSuccess = false;        tmpSuccessDev = false;        if(amountToLiquify > 0){            router.addLiquidityETH{value: amountBNBLiquidity}(                address(this),                amountToLiquify,                0,                0,                autoLiquidityReceiver,                block.timestamp            );            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);        }        emit SwapBackEvent(amountBNB, amountBNBLiquidity, amountBNBReflection, amountBNBMarketing);    }"