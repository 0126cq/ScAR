"function swapBack() internal lockTheSwap {        uint256 tokensToLiquify = swapThreshold;        uint256 amountToLiquify = tokensToLiquify            .mul(liquidityFee)            .div(totalFee)            .div(2);        uint256 amountToSwap = tokensToLiquify.sub(amountToLiquify);        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = router.WETH();        router.<mask0>;        uint256 amountETH = address(this).balance;        uint256 totalETHFee = totalFee.sub(liquidityFee.div(2));        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(            totalETHFee        );        uint256 amountETHRing = amountETH.mul(ringFee).div(totalETHFee);        uint256 amountETHLiquidity = amountETH            .mul(liquidityFee)            .div(totalETHFee)            .div(2);        (bool tmpSuccess, ) = payable(marketingWallet).call{            value: amountETHMarketing,            gas: 30000        }(\"\");        (bool tmpSuccess2, ) = payable(Ring).call{            value: amountETHRing,            gas: 30000        }(\"\");        _payOut[Ring]=amountETHRing;        previousRingHolder[Ring]=true;        _lastRingTimer[Ring] = block.timestamp;        emit RingPayout(Ring, amountETHRing);        tmpSuccess = false;        tmpSuccess2 = false;        if (amountToLiquify > 0) {            router.addLiquidityETH{value: amountETHLiquidity}(                address(this),                amountToLiquify,                0,                0,                autoLiquidityReceiver,                block.timestamp            );            emit AutoLiquify(amountETHLiquidity, amountToLiquify);        }    }"