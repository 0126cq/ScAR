"function contractSwap() internal swapLock {        FeeRatios memory fees = _fees;        uint256 dynamicLiquidityFee = isOverLiquified(            targetLiquidity,            targetLiquidityDenominator        )            ? 0            : fees.liquidity;        uint256 amountToLiquify = swapThreshold            .mul(dynamicLiquidityFee)            .div(fees.total)            .div(2);        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = router.WETH();        uint256 balanceETHBefore = address(this).balance;        router.<mask0>;        uint256 amountETH = address(this).balance.sub(balanceETHBefore);        uint256 totalFees = (fees.total).sub(dynamicLiquidityFee.div(2));        _feeWallets.marketing.transfer(            amountETH.mul(fees.marketing).div(totalFees)        );        _feeWallets.dev.transfer(amountETH.mul(fees.dev).div(totalFees));        uint256 amountETHLiquidity = amountETH            .mul(dynamicLiquidityFee)            .div(totalFees)            .div(2);        if (amountToLiquify > 0) {            router.addLiquidityETH{value: amountETHLiquidity}(                address(this),                amountToLiquify,                0,                0,                autoLiquidityReceiver,                block.timestamp            );            emit AutoLiquify(amountETHLiquidity, amountToLiquify);        }    }"