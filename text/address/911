"function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {        require(!borrowGuardianPaused[cToken], \"borrow is paused\");        if (!isMarketListed(cToken)) {            return uint(Error.MARKET_NOT_LISTED);        }        if (!markets[cToken].accountMembership[borrower]) {            require(msg.sender == cToken, \"sender must be cToken\");            Error err = addToMarketInternal(CToken(msg.sender), borrower);            if (err != Error.NO_ERROR) {                return uint(err);            }            assert(markets[cToken].accountMembership[borrower]);        }        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {            return uint(Error.PRICE_ERROR);        }        uint borrowCap = borrowCaps[cToken];        if (borrowCap != 0) {            uint totalBorrows = CToken(cToken).totalBorrows();            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");        }        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);        if (err != Error.NO_ERROR) {            return uint(err);        }        if (shortfall > 0) {            return uint(Error.INSUFFICIENT_LIQUIDITY);        }        if (liquidityMining != address(0)) {            address[] memory accounts = new <mask0>;            accounts[0] = borrower;            LiquidityMiningInterface(liquidityMining).updateBorrowIndex(cToken, accounts);        }        return uint(Error.NO_ERROR);    }"