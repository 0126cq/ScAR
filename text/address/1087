"function _buy(        uint256 amountInMax,        uint256 amountOut,        address[] memory path    )        private        returns (uint256 tokensSold)    {        bytes memory localData = adapterVsData[key];        LocalData memory data = abi.decode(localData, (LocalData));        require(path.length > 1, \"More than 1 token required\");        bool tokensBoughtEth;        uint8 length = uint8(path.length);        uint256[] memory amounts = new uint256[](length);        address[] memory pairs = new <mask0>;        amounts[length - 1] = amountOut;        for (uint8 i = length - 1; i > 0; i--) {            (amounts[i - 1], pairs[i - 1]) = UniswapV3LibFork.getAmountInAndPair(                data.factory,                amounts[i],                path[i-1],                path[i],                data.initCode,                data.feeMultiplicationFactor            );        }        tokensSold = amounts[0];        require(tokensSold <= amountInMax, \"UniswapV3Router: INSUFFICIENT_INPUT_AMOUNT\");        for(uint8 i = 0; i < length - 1; i++) {            address tokenSold = path[i];            address tokenBought = path[i+1];            if (i == length - 2) {                if (tokenBought == Utils.ethAddress()) {                    tokenBought = Utils.wethAddress();                    tokensBoughtEth = true;                }            }            if (i == 0) {                if (tokenSold == Utils.ethAddress()) {                    tokenSold = Utils.wethAddress();                    IWETH(Utils.wethAddress()).deposit{value: tokensSold}();                    assert(IWETH(Utils.wethAddress()).transfer(pairs[i], tokensSold));                }                else {                    TransferHelper.safeTransfer(                        tokenSold, pairs[i], tokensSold                    );                }            }            address receiver;            if (i == length - 2) {                receiver = address(this);            }            else {                receiver = pairs[i+1];            }            (address token0,) = UniswapV3LibFork.sortTokens(tokenSold, tokenBought);            (uint256 amount0Out, uint256 amount1Out) = tokenSold == token0 ? (uint256(0), amounts[i+1]) : (amounts[i+1], uint256(0));            IUniswapV2Pair(pairs[i]).swap(                amount0Out, amount1Out, receiver, new bytes(0)            );        }        if (tokensBoughtEth) {            IWETH(Utils.wethAddress()).withdraw(amountOut);        }    }"