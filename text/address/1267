"function _claimRewards() internal {        if (isInvestmentTokenIncentivised || isWantIncentivised) {            uint256 stkAaveBalance =                IERC20(address(stkAave)).balanceOf(address(this));            if (stkAaveBalance > 0 && _checkCooldown()) {                stkAave.claimRewards(address(this), type(uint256).max);                stkAave.redeem(address(this), stkAaveBalance);            }            uint256 aaveBalance = IERC20(AAVE).balanceOf(address(this));            if (aaveBalance > 1e15) {                _sellAForB(aaveBalance, address(AAVE), address(want));            }            address[] memory assets;            if (isInvestmentTokenIncentivised && isWantIncentivised) {                assets = new address[](2);                assets[0] = address(aToken);                assets[1] = address(variableDebtToken);            } else if (isInvestmentTokenIncentivised) {                assets = new address[](1);                assets[0] = address(variableDebtToken);            } else if (isWantIncentivised) {                assets = new <mask0>;                assets[0] = address(aToken);            }            _incentivesController().claimRewards(                assets,                type(uint256).max,                address(this)            );            uint256 cooldownStartTimestamp =                IStakedAave(stkAave).stakersCooldowns(address(this));            uint256 COOLDOWN_SECONDS = IStakedAave(stkAave).COOLDOWN_SECONDS();            uint256 UNSTAKE_WINDOW = IStakedAave(stkAave).UNSTAKE_WINDOW();            if (                IERC20(address(stkAave)).balanceOf(address(this)) > 0 &&                (cooldownStartTimestamp == 0 ||                    block.timestamp >                    cooldownStartTimestamp.add(COOLDOWN_SECONDS).add(                        UNSTAKE_WINDOW                    ))            ) {                stkAave.cooldown();            }        }    }"