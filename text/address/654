"function _swapExactTokensForTokens(    address assetToSwapFrom,    address assetToSwapTo,    uint256 amountToSwap,    uint256 minAmountOut,    bool useEthPath  ) internal returns (uint256) {    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);    uint256 fromAssetPrice = _getPrice(assetToSwapFrom);    uint256 toAssetPrice = _getPrice(assetToSwapTo);    uint256 expectedMinAmountOut =      amountToSwap        .mul(fromAssetPrice.mul(10**toAssetDecimals))        .div(toAssetPrice.mul(10**fromAssetDecimals))        .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(MAX_SLIPPAGE_PERCENT));    require(expectedMinAmountOut < minAmountOut, 'minAmountOut exceed max slippage');    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap);    address[] memory path;    if (useEthPath) {      path = new address[](3);      path[0] = assetToSwapFrom;      path[1] = WETH_ADDRESS;      path[2] = assetToSwapTo;    } else {      path = new <mask0>;      path[0] = assetToSwapFrom;      path[1] = assetToSwapTo;    }    uint256[] memory amounts =      UNISWAP_ROUTER.swapExactTokensForTokens(        amountToSwap,        minAmountOut,        path,        address(this),        block.timestamp      );    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);    return amounts[amounts.length - 1];  }"