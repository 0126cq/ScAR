"function voteProposal(uint8 chainID, uint64 depositNonce, bytes32 resourceID, bytes32 dataHash) external onlyRelayers whenNotPaused {        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);        Proposal storage proposal = _proposals[nonceAndID][dataHash];        require(_resourceIDToHandlerAddress[resourceID] != address(0), \"no handler for resourceID\");        require(uint(proposal._status) <= 1, \"proposal already passed/executed/cancelled\");        require(!_hasVotedOnProposal[nonceAndID][dataHash][msg.sender], \"relayer already voted\");        if (uint(proposal._status) == 0) {            ++_totalProposals;            _proposals[nonceAndID][dataHash] = Proposal({                _resourceID : resourceID,                _dataHash : dataHash,                _yesVotes : new <mask0>,                _noVotes : new address[](0),                _status : ProposalStatus.Active,                _proposedBlock : block.number                });            proposal._yesVotes[0] = msg.sender;            emit ProposalEvent(chainID, depositNonce, ProposalStatus.Active, resourceID, dataHash);        } else {            if (sub(block.number, proposal._proposedBlock) > _expiry) {                proposal._status = ProposalStatus.Cancelled;                emit ProposalEvent(chainID, depositNonce, ProposalStatus.Cancelled, resourceID, dataHash);            } else {                require(dataHash == proposal._dataHash, \"datahash mismatch\");                proposal._yesVotes.push(msg.sender);            }        }        if (proposal._status != ProposalStatus.Cancelled) {            _hasVotedOnProposal[nonceAndID][dataHash][msg.sender] = true;            emit ProposalVote(chainID, depositNonce, proposal._status, resourceID);            if (_relayerThreshold <= 1 || proposal._yesVotes.length >= _relayerThreshold) {                proposal._status = ProposalStatus.Passed;                emit ProposalEvent(chainID, depositNonce, ProposalStatus.Passed, resourceID, dataHash);            }        }    }"