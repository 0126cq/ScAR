"function _getAmountsOutData(    address reserveIn,    address reserveOut,    uint256 amountIn  ) internal view returns (AmountCalc memory) {    uint256 finalAmountIn = amountIn.sub(amountIn.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000));    if (reserveIn == reserveOut) {      uint256 reserveDecimals = _getDecimals(reserveIn);      address[] memory path = new <mask0>;      path[0] = reserveIn;      return        AmountCalc(          finalAmountIn,          finalAmountIn.mul(10**18).div(amountIn),          _calcUsdValue(reserveIn, amountIn, reserveDecimals),          _calcUsdValue(reserveIn, finalAmountIn, reserveDecimals),          path        );    }    address[] memory simplePath = new address[](2);    simplePath[0] = reserveIn;    simplePath[1] = reserveOut;    uint256[] memory amountsWithoutWeth;    uint256[] memory amountsWithWeth;    address[] memory pathWithWeth = new address[](3);    if (reserveIn != WETH_ADDRESS && reserveOut != WETH_ADDRESS) {      pathWithWeth[0] = reserveIn;      pathWithWeth[1] = WETH_ADDRESS;      pathWithWeth[2] = reserveOut;      try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, pathWithWeth) returns (        uint256[] memory resultsWithWeth      ) {        amountsWithWeth = resultsWithWeth;      } catch {        amountsWithWeth = new uint256[](3);      }    } else {      amountsWithWeth = new uint256[](3);    }    uint256 bestAmountOut;    try UNISWAP_ROUTER.getAmountsOut(finalAmountIn, simplePath) returns (      uint256[] memory resultAmounts    ) {      amountsWithoutWeth = resultAmounts;      bestAmountOut = (amountsWithWeth[2] > amountsWithoutWeth[1])        ? amountsWithWeth[2]        : amountsWithoutWeth[1];    } catch {      amountsWithoutWeth = new uint256[](2);      bestAmountOut = amountsWithWeth[2];    }    uint256 reserveInDecimals = _getDecimals(reserveIn);    uint256 reserveOutDecimals = _getDecimals(reserveOut);    uint256 outPerInPrice =      finalAmountIn.mul(10**18).mul(10**reserveOutDecimals).div(        bestAmountOut.mul(10**reserveInDecimals)      );    return      AmountCalc(        bestAmountOut,        outPerInPrice,        _calcUsdValue(reserveIn, amountIn, reserveInDecimals),        _calcUsdValue(reserveOut, bestAmountOut, reserveOutDecimals),        (bestAmountOut == 0) ? new address[](2) : (bestAmountOut == amountsWithoutWeth[1])          ? simplePath          : pathWithWeth      );  }"