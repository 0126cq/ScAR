"function _openERC20ToERC20(        uint256 openValue,        address openContractAddress,        uint256 closeValue,        address payable closeTrader,        address closeContractAddress,        uint256 fee,        bool isFeeInSwap,        bool calcFeeUsingTotalSupply    )    private    whenNotPaused    {        require(openValue > 0, \"[Validation] The open ERC-20 amount has to be larger than 0\");        require(closeValue > 0, \"[Validation] The close ERC-20 amount has to be larger than 0\");        if(!isFreeToken(openContractAddress)) {            if(isFeeInSwap){                uint256 minRequiredFeeInSwap = getFeeInSwapForERC20(openValue, openContractAddress, calcFeeUsingTotalSupply);                uint256 feeDiff = 0;                if( fee < minRequiredFeeInSwap ) {                    feeDiff = minRequiredFeeInSwap.sub(fee);                    uint256 feeSlippagePercentage = feeDiff.mul(100).div(minRequiredFeeInSwap);                    require(feeSlippagePercentage < _allowedFeeSlippagePercentage, \"[Validation] Fee (SWAP) is below minimum required fee\");                }                _distributeFees(minRequiredFeeInSwap);            }            else {                uint256 minRequiredFeeInEth = calcFeeUsingTotalSupply ?                     getFeeInEthForERC20UsingTotalSupply(openValue, openContractAddress) :                     getFeeInEthForERC20(openValue, openContractAddress);                require(fee >= minRequiredFeeInEth, \"[Validation] Fee (ETH) is below minimum required fee\");                require(msg.value >= minRequiredFeeInEth, \"[Validation] msg.value doesn't contain enough ETH for fee\");                (bool success,) = _feesWallet.call.<mask0>(\"\");                require(success, \"[Validation] Transfer of fee failed\");            }        }        IERC20 openERC20Contract = IERC20(openContractAddress);        require(openValue <= openERC20Contract.allowance(msg.sender, address(this)));        require(openERC20Contract.transferFrom(msg.sender, address(this), openValue));        _swapId = _swapId.add(1);        _swaps[_swapId] = Swap({            openValue: openValue,            openTrader: msg.sender,            openContractAddress: openContractAddress,            closeValue: closeValue,            closeTrader: closeTrader,            closeContractAddress: closeContractAddress,            swapType: SwapType.ERC20_TO_ERC20,            status: Status.OPEN        });        emit Open(_swapId, msg.sender, closeTrader);    }"