"function _openERC20ToEther(        uint256 erc20Value,        address erc20ContractAddress,        address payable ethTrader,        uint256 ethValue,        uint256 fee,        bool isFeeInSwap,        bool calcFeeUsingTotalSupply    )    private    whenNotPaused    onlyContract(erc20ContractAddress)    {        require(ethValue > 0, \"[Validation] The ETH amount has to be larger than 0\");        require(erc20Value > 0, \"[Validation] The ERC-20 amount has to be larger than 0\");        if(!isFreeToken(erc20ContractAddress)) {            if(isFeeInSwap){                uint256 minRequiredFeeInSwap = getFeeInSwapForERC20(erc20Value, erc20ContractAddress, calcFeeUsingTotalSupply);                uint256 feeDiff = 0;                if( fee < minRequiredFeeInSwap ) {                    feeDiff = minRequiredFeeInSwap.sub(fee);                    uint256 feeSlippagePercentage = feeDiff.mul(100).div(minRequiredFeeInSwap);                    require(feeSlippagePercentage < _allowedFeeSlippagePercentage, \"[Validation] Fee (SWAP) is below minimum required fee\");                }                _distributeFees(minRequiredFeeInSwap);            }            else {                uint256 minRequiredFeeInEth = calcFeeUsingTotalSupply ?                     getFeeInEthForERC20UsingTotalSupply(erc20Value, erc20ContractAddress) :                     getFeeInEthForERC20(erc20Value, erc20ContractAddress);                require(fee >= minRequiredFeeInEth, \"[Validation] Fee (ETH) is below minimum required fee\");                require(msg.value >= minRequiredFeeInEth, \"[Validation] msg.value doesn't contain enough ETH for fee\");                (bool success,) = _feesWallet.call.<mask0>(\"\");                require(success, \"[Validation] Transfer of fee failed\");            }        }        IERC20 openERC20Contract = IERC20(erc20ContractAddress);        require(erc20Value <= openERC20Contract.allowance(msg.sender, address(this)));        require(openERC20Contract.transferFrom(msg.sender, address(this), erc20Value));        _swapId = _swapId.add(1);        _swaps[_swapId] = Swap({            openValue: erc20Value,            openTrader: msg.sender,            openContractAddress: erc20ContractAddress,            closeValue: ethValue,            closeTrader: ethTrader,            closeContractAddress: ETH_ADDRESS,            swapType: SwapType.ERC20_TO_ETH,            status: Status.OPEN        });        emit Open(_swapId, msg.sender, ethTrader);    }"