"function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant {    require(_refund == 0, \"refund is not zero\");    require(!Address.isContract(_recipient), \"recipient of cannot be contract\");    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");    require(isKnownRoot(_root), \"Cannot find your merkle root\");     require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\");    nullifierHashes[_nullifierHash] = true;    uint256 td = tokenDenomination;    if (td > 0) {      safeTransfer(token, _recipient, td);    }    updateBlockReward();    uint256 relayerFee = 0;    uint256 cycDeno = accumulateCYC.div(numOfShares);    if (cycDeno > 0) {      accumulateCYC -= cycDeno;      safeTransfer(cycToken, _recipient, cycDeno);    }    uint256 cd = coinDenomination;    if (_relayerFee > cd) {      _relayerFee = cd;    }    if (_relayerFee > 0) {      (bool success,) = _relayer.call.<mask0>;      require(success, \"failed to send relayer fee\");      cd -= _relayerFee;    }    if (cd > 0) {      (bool success,) = _recipient.call.value(cd)(\"\");      require(success, \"failed to withdraw coin\");    }    numOfShares -= 1;    emit Withdrawal(_recipient, _nullifierHash, _relayer, cycDeno, relayerFee);  }"