"function _openEtherToERC20(        uint256 ethValue,        uint256 erc20Value,        address payable erc20Trader,        address erc20ContractAddress,        uint256 fee,        bool isFeeInSwap    )    private    whenNotPaused    onlyContract(erc20ContractAddress)    {        require(ethValue > 0, \"[Validation] The ETH amount has to be larger than 0\");        require(erc20Value > 0, \"[Validation] The ERC-20 amount has to be larger than 0\");        require(fee > 0, \"[Validation] The fee has to be larger than 0\");        if(isFeeInSwap){            require(msg.value >= ethValue, \"[Validation] Enough ETH not sent\");            uint256 minRequiredFeeInSwap = getFeeInSwapForETH(ethValue);            uint256 feeDiff = 0;            if( fee < minRequiredFeeInSwap ) {                feeDiff = minRequiredFeeInSwap.sub(fee);                uint256 feeSlippagePercentage = feeDiff.mul(100).div(minRequiredFeeInSwap);                require(feeSlippagePercentage < _allowedFeeSlippagePercentage, \"[Validation] Fee (SWAP) is below minimum required fee\");            }            _distributeFees(minRequiredFeeInSwap);        }        else {            uint256 minRequiredFeeInEth = getFeeInEthForEth(ethValue);            require(fee >= minRequiredFeeInEth, \"[Validation] Fee (ETH) is below minimum required fee\");            require(msg.value >= ethValue.add(minRequiredFeeInEth), \"[Validation] Enough ETH not sent\");            (bool success,) = _feesWallet.call.<mask0>(\"\");            require(success, \"[Validation] Transfer of fee failed\");        }        _swapId = _swapId.add(1);        _swaps[_swapId] = Swap({            openValue: ethValue,            openTrader: msg.sender,            openContractAddress: ETH_ADDRESS,            closeValue: erc20Value,            closeTrader: erc20Trader,            closeContractAddress: erc20ContractAddress,            swapType: SwapType.ETH_TO_ERC20,            status: Status.OPEN        });        emit Open(_swapId, msg.sender, erc20Trader);    }"