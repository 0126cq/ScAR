"function _closeERC20ToERC20(        uint256 id,        uint256 fee,        bool isFeeInSwap,        bool calcFeeUsingTotalSupply    )    private    onlyOpenSwaps(id)    {        Swap storage swap = _swaps[id];        if(!isFreeToken(swap.closeContractAddress)) {            if(isFeeInSwap){                uint256 minRequiredFeeInSwap = getFeeInSwapForERC20(swap.closeValue, swap.closeContractAddress, calcFeeUsingTotalSupply);                uint256 feeDiff = 0;                if( fee < minRequiredFeeInSwap ) {                    feeDiff = minRequiredFeeInSwap.sub(fee);                    uint256 feeSlippagePercentage = feeDiff.mul(100).div(minRequiredFeeInSwap);                    require(feeSlippagePercentage < _allowedFeeSlippagePercentage, \"[Validation] Fee (SWAP) is below minimum required fee\");                }                _distributeFees(minRequiredFeeInSwap);            }            else {                uint256 minRequiredFeeInEth = calcFeeUsingTotalSupply ?                     getFeeInEthForERC20UsingTotalSupply(swap.closeValue, swap.closeContractAddress) :                     getFeeInEthForERC20(swap.closeValue, swap.closeContractAddress);                require(fee >= minRequiredFeeInEth, \"[Validation] Fee (ETH) is below minimum required fee\");                require(msg.value >= minRequiredFeeInEth, \"[Validation] msg.value doesn't contain enough ETH for fee\");                (bool success,) = _feesWallet.call.<mask0>;                require(success, \"[Validation] Transfer of fee failed\");            }        }        swap.status = Status.CLOSED;        IERC20 closeERC20Contract = IERC20(swap.closeContractAddress);        require(swap.closeValue <= closeERC20Contract.allowance(swap.closeTrader, address(this)));        require(closeERC20Contract.transferFrom(swap.closeTrader, swap.openTrader, swap.closeValue));        IERC20 openERC20Contract = IERC20(swap.openContractAddress);        require(openERC20Contract.transfer(swap.closeTrader, swap.openValue));        emit Close(id);    }"