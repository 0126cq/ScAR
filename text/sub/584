"function _solveTradeInvariant(        uint256 amountIn_,        address vault,        address balancerVault,        bytes32 poolId,        bool fromUnderlier    ) internal view returns (uint256) {        uint256 tokenScale = IVault(vault).tokenScale();        uint256 underlierScale = IVault(vault).underlierScale();        uint256 amountIn = (fromUnderlier) ? wdiv(amountIn_, underlierScale) : wdiv(amountIn_, tokenScale);        uint256 currentBalanceTokenIn;        uint256 currentBalanceTokenOut;        {            (address[] memory tokens, uint256[] memory balances, ) = IBalancerVault(balancerVault).getPoolTokens(                poolId            );            address token = IVault(vault).token();            address underlier = IVault(vault).underlierToken();            if (tokens[0] == underlier && tokens[1] == token) {                currentBalanceTokenIn = (fromUnderlier)                    ? wdiv(balances[0], underlierScale)                    : wdiv(balances[1], tokenScale);                currentBalanceTokenOut = (fromUnderlier)                    ? wdiv(balances[1], tokenScale)                    : wdiv(balances[0], underlierScale);            } else if (tokens[0] == token && tokens[1] == underlier) {                currentBalanceTokenIn = (fromUnderlier)                    ? wdiv(balances[1], underlierScale)                    : wdiv(balances[0], tokenScale);                currentBalanceTokenOut = (fromUnderlier)                    ? wdiv(balances[0], tokenScale)                    : wdiv(balances[1], underlierScale);            } else {                revert VaultEPTActions__solveTradeInvariant_tokenMismatch();            }        }        (address pool, ) = IBalancerVault(balancerVault).getPool(poolId);        IConvergentCurvePool ccp = IConvergentCurvePool(pool);        if (fromUnderlier) {            unchecked {                currentBalanceTokenOut += ccp.totalSupply();            }        } else {            unchecked {                currentBalanceTokenIn += ccp.totalSupply();            }        }        uint256 amountOut = ccp.solveTradeInvariant(amountIn, currentBalanceTokenIn, currentBalanceTokenOut, true);        uint256 impliedYieldFee = wmul(            ccp.percentFee(),            fromUnderlier                ? sub(amountOut, amountIn)                 : sub(amountIn, amountOut)         );        return wmul(<mask0>, (fromUnderlier) ? tokenScale : underlierScale);    }"