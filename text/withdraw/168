"function _withdraw(        address receiver,        uint256 shares,         bool processWithdrawalFee,         bool verifyMaxLoss     ) internal virtual returns (uint256 withdrawn) {        VaultAPI _bestVault = bestVault();        uint256 availableShares = experimentalVault.balanceOf(address(this));        uint256 expected = _shareValue(shares);        withdrawn = experimentalVault.<mask0>;        if (expected > withdrawn) {            _verifyWithinMaxDeviationThreshold(withdrawn, expected);        }        address feeRecipient = treasury;        IERC20Upgradeable cachedToken = token;        if (            withdrawalFee > 0 &&            processWithdrawalFee &&            feeRecipient != address(0)        ) {            uint256 withdrawalToTreasury =                withdrawn.mul(withdrawalFee).div(MAX_BPS);            withdrawn = withdrawn.sub(withdrawalToTreasury);            cachedToken.safeTransfer(feeRecipient, withdrawalToTreasury);            emit WithdrawalFee(feeRecipient, withdrawalToTreasury);        }        if (receiver != address(this))            cachedToken.safeTransfer(receiver, withdrawn);    }"