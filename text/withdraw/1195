"function exit(address _depositAddress, uint value) public onlyOwner {        claimReward(_depositAddress, false);        address[] memory supAddresses = getSupportAddresses(_depositAddress);        require(IGauge(supAddresses[1]).balanceOf(address(this)) > 0);        IGauge(supAddresses[1]).<mask0>;        uint bal = IERC20(supAddresses[0]).balanceOf(address(this));        require(bal > 0);        PoolFactory(poolFactoryAddress).burn(msg.sender, bal, isBTCPool);        IERC20(supAddresses[0]).approve(_depositAddress, bal);        if (!isBTCPool) {          if (_depositAddress == SWERVE_DEPOSIT_ADDRESS) {              uint[4] memory buf;              Deposit4Tokens(_depositAddress).remove_liquidity(bal, buf);          } else {                Deposit2Tokens(_depositAddress).remove_liquidity_one_coin(bal, 0, 1, true);          }        } else {            Deposit3Tokens(_depositAddress).remove_liquidity_one_coin(bal, 1, 1);        }        if (!isBTCPool) {            if(IERC20(DAI_ADDRESS).balanceOf(address(this)) > 0) {                IERC20(DAI_ADDRESS).transfer(msg.sender, IERC20(DAI_ADDRESS).balanceOf(address(this)));            }            if(IERC20(USDC_ADDRESS).balanceOf(address(this)) > 0) {                IERC20(USDC_ADDRESS).transfer(msg.sender, IERC20(USDC_ADDRESS).balanceOf(address(this)));            }            if(IERC20(TUSD_ADDRESS).balanceOf(address(this)) > 0) {                IERC20(TUSD_ADDRESS).transfer(msg.sender, IERC20(TUSD_ADDRESS).balanceOf(address(this)));            }        } else {            IERC20(WBTC_ADDRESS).transfer(msg.sender, IERC20(WBTC_ADDRESS).balanceOf(address(this)));        }    }"