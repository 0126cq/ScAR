"function dodoMutliSwap(        uint256 fromTokenAmount,        uint256 minReturnAmount,        uint256[] memory totalWeight,        uint256[] memory splitNumber,        address[] memory midToken,        address[] memory assetFrom,        bytes[] memory sequence,        uint256 deadLine    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {        require(assetFrom.length == splitNumber.length, 'DODORouteProxy: PAIR_ASSETTO_NOT_MATCH');                require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");        uint256 _fromTokenAmount = fromTokenAmount;        address fromToken = midToken[0];        address toToken = midToken[midToken.length - 1];        if(fromToken == _ETH_ADDRESS_) {            require(msg.value == _fromTokenAmount, \"DODORouteProxy: MSG_VALUE_NOT_MATCH\");        }        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);        _deposit(msg.sender, assetFrom[0], fromToken, _fromTokenAmount, fromToken == _ETH_ADDRESS_);        _multiSwap(totalWeight, midToken, splitNumber, sequence, assetFrom);        if(toToken == _ETH_ADDRESS_) {            returnAmount = IWETH(_WETH_).balanceOf(address(this));            IWETH(_WETH_).<mask0>;            msg.sender.transfer(returnAmount);        }else {            returnAmount = IERC20(toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);        }        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");        emit OrderHistory(            fromToken,            toToken,            msg.sender,            _fromTokenAmount,            returnAmount        );        }"