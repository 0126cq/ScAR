"function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {        require(_amount > 0, \"Amount must be greater than 0\");        (            uint256[] memory outputs,            uint256 _backingValue        ) = _calculateRedeemOutputs(_amount);        uint256 _totalSupply = oUSD.totalSupply();        if (maxSupplyDiff > 0) {            uint256 diff = _totalSupply.divPrecisely(_backingValue);            require(                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=                    maxSupplyDiff,                \"Backing supply liquidity error\"            );        }        emit Redeem(msg.sender, _amount);        for (uint256 i = 0; i < allAssets.length; i++) {            if (outputs[i] == 0) continue;            IERC20 asset = IERC20(allAssets[i]);            if (asset.balanceOf(address(this)) >= outputs[i]) {                asset.safeTransfer(msg.sender, outputs[i]);            } else {                address strategyAddr = assetDefaultStrategies[allAssets[i]];                if (strategyAddr != address(0)) {                    IStrategy strategy = IStrategy(strategyAddr);                    strategy.<mask0>;                } else {                    revert(\"Liquidity error\");                }            }        }        if (_minimumUnitAmount > 0) {            uint256 unitTotal = 0;            for (uint256 i = 0; i < outputs.length; i++) {                uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);                unitTotal = unitTotal.add(                    outputs[i].scaleBy(18, assetDecimals)                );            }            require(                unitTotal >= _minimumUnitAmount,                \"Redeem amount lower than minimum\"            );        }        oUSD.burn(msg.sender, _amount);        if (_amount > rebaseThreshold && !rebasePaused) {            _rebase();        }    }"