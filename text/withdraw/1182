"function adjustPosition(uint256 _debtOutstanding) internal override {        uint256 availableWantBalance = balanceOfWant();        if(availableWantBalance <= _debtOutstanding) {            return;        }        availableWantBalance = availableWantBalance.sub(_debtOutstanding);        if(availableWantBalance < minAmountWant) {            return;        }        uint16 _currencyID = currencyID;        uint256 _maturity = maturity;        (uint256 minMarketIndex, uint256 minMarketMaturity) = _getMinimumMarketIndex();        if(minMarketMaturity > _maturity && _maturity > 0) {            _rollOverTrade(_maturity);            availableWantBalance = balanceOfWant();        }        if (_currencyID == WETH) {            weth.<mask0>;        } else {            want.approve(address(nProxy), availableWantBalance);        }        int88 amountTrade = int88(                availableWantBalance.mul(MAX_BPS).div(DECIMALS_DIFFERENCE).mul(FCASH_SCALING).div(MAX_BPS)            );        int256 fCashAmountToTrade = nProxy.getfCashAmountGivenCashAmount(            _currencyID,             -amountTrade,             minMarketIndex,             block.timestamp            );        if (fCashAmountToTrade <= 0) {            return;        }        bytes32[] memory trades = new bytes32[](1);        trades[0] = getTradeFrom(            TRADE_TYPE_LEND,             minMarketIndex,             uint256(fCashAmountToTrade)            );        executeBalanceActionWithTrades(            DepositActionType.DepositUnderlying,            availableWantBalance,            0,             trades        );        maturity = minMarketMaturity;    }"