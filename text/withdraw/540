"function settleETHBatch(address[] _custodies, int[] _flows, uint _fee, uint _insurance) external whenNotPaused onlyExchangeOrOwneronlyAllowedInPhase(SettlementPhase.ONGOING) {require(_custodies.length == _flows.length);uint preBatchBalance = address(this).balance;if(_insurance > 0) {Insurance(insuranceAccount).useInsurance(_insurance);}for (uint flowIndex = 0; flowIndex < _flows.length; flowIndex++) {require(custodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] == false);require(custodyStorage.custodiesMap(_custodies[flowIndex]));if (_flows[flowIndex] > 0) {var outboundFlow = uint(_flows[flowIndex]);if(outboundFlow > 10 ether) {require(getTotalBalanceFor(_custodies[flowIndex]) >= outboundFlow);}_custodies[flowIndex].transfer(uint(_flows[flowIndex]));} else if (_flows[flowIndex] < 0) {Custody custody = Custody(_custodies[flowIndex]);custody.<mask0>;}custodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] = true;}if(_fee > 0) {feeAccount.transfer(_fee);totalFeeFlows = totalFeeFlows + _fee;require(totalFeeFlows <= startingFeeBalance);}uint postBatchBalance = address(this).balance;if(address(this).balance > preBatchBalance) {uint leftovers = address(this).balance - preBatchBalance;insuranceAccount.transfer(leftovers);totalInsuranceFlows += leftovers;require(totalInsuranceFlows <= startingInsuranceBalance);}}"