"function _recenter(        RebalanceCache memory _cache,        Uniswap.Position memory _primary,        uint128 _primaryLiquidity,        uint256 _inventory0,        uint256 _inventory1,        bool _maintenanceIsSustainable    ) private returns (Uniswap.Position memory) {        unchecked {            (, , uint256 earned0, uint256 earned1) = _primary.<mask0>;            maintenanceBudget0 += earned0 / MAINTENANCE_FEE;            maintenanceBudget1 += earned1 / MAINTENANCE_FEE;        }        int24 w = _maintenanceIsSustainable            ? _computeNextPositionWidth(volatilityOracle.estimate24H(UNI_POOL))            : MAX_WIDTH;        w = w >> 1;        (uint256 amount0, uint256 amount1) = _computeMagicAmounts(_inventory0, _inventory1, w);        int256 balance0;        int256 balance1;        unchecked {            balance0 = int256(_balance0()) - int256(FullMath.mulDiv(_inventory0, FLOAT_PERCENTAGE, 10_000));            balance1 = int256(_balance1()) - int256(FullMath.mulDiv(_inventory1, FLOAT_PERCENTAGE, 10_000));            if (balance0 < int256(amount0)) {                _inventory0 = 0;                 amount0 = uint256(balance0 + int256(_silo0Withdraw(uint256(int256(amount0) - balance0))));            }            if (balance1 < int256(amount1)) {                _inventory1 = 0;                 amount1 = uint256(balance1 + int256(_silo1Withdraw(uint256(int256(amount1) - balance1))));            }        }        unchecked {            _primary.lower = TickMath.floor(_cache.tick - w, TICK_SPACING);            _primary.upper = TickMath.ceil(_cache.tick + w, TICK_SPACING);            if (_primary.lower < MIN_TICK) _primary.lower = MIN_TICK;            if (_primary.upper > MAX_TICK) _primary.upper = MAX_TICK;        }        (amount0, amount1) = _primary.deposit(_primary.liquidityForAmounts(_cache.sqrtPriceX96, amount0, amount1));        if (_inventory0 != 0) {            silo0.delegate_deposit(uint256(balance0) - amount0);            silo0Basis += uint256(balance0) - amount0;        }        if (_inventory1 != 0) {            silo1.delegate_deposit(uint256(balance1) - amount1);            silo1Basis += uint256(balance1) - amount1;        }        emit Recenter(_primary.lower, _primary.upper);        return _primary;    }"