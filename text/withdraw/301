"function _liquidate(        uint256 _pid,        int128 _coinId,        address _user,        uint256 _amount,        address _recipient    ) internal returns (address, uint256) {        PoolInfo storage pool = poolInfo[_pid];        IOriginConvexRewardPool(pool.originCrvRewards).withdrawAndUnwrap(_amount, true);        if (_user != address(0)) {            if (IConvexRewardPool(pool.rewardCrvPool).earned(_user) > 0) {                IConvexRewardPool(pool.rewardCrvPool).getReward(_user);            }            if (IConvexRewardPool(pool.rewardCvxPool).earned(_user) > 0) {                IConvexRewardPool(pool.rewardCvxPool).getReward(_user);            }            IVirtualBalanceWrapper(pool.virtualBalance).withdrawFor(_user, _amount);            IConvexRewardPool(pool.rewardCrvPool).<mask0>;            IConvexRewardPool(pool.rewardCvxPool).withdraw(_user);        }        address underlyToken;        if (metaPoolInfo[pool.lpToken].zapAddress != address(0)) {            if (                metaPoolInfo[pool.lpToken].swapAddress == metaPoolInfo[pool.lpToken].basePoolAddress ||                (!metaPoolInfo[pool.lpToken].isMeta && !metaPoolInfo[pool.lpToken].isMetaFactory) ||                _coinId == 0            ) {                underlyToken = _coins(pool.curveSwapAddress, _coinId);            } else {                underlyToken = _coins(metaPoolInfo[pool.lpToken].basePoolAddress, _coinId - 1);            }        } else {            underlyToken = _coins(pool.curveSwapAddress, _coinId);        }        _removeLiquidity(pool.lpToken, pool.curveSwapAddress, _amount, _coinId);        if (underlyToken == ZERO_ADDRESS) {            uint256 totalAmount = address(this).balance;            payable(_recipient).sendValue(totalAmount);            return (ZERO_ADDRESS, totalAmount);        } else {            uint256 totalAmount = IERC20(underlyToken).balanceOf(address(this));            IERC20(underlyToken).safeTransfer(_recipient, totalAmount);            return (underlyToken, totalAmount);        }    }"