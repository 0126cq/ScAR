"function withdrawInternal(        uint256 amount_,        address to_,        bool afterDeleverage_    ) internal returns (uint256 vtokenAmount_) {        require(amount_ != 0, \"amount cannot be zero\");        (            uint256 exchangePrice_,            uint256 newRevenue_        ) = getCurrentExchangePrice();        updateStorage(exchangePrice_, newRevenue_);        if (amount_ == type(uint256).max) {            vtokenAmount_ = balanceOf(msg.sender);            amount_ = (vtokenAmount_ * exchangePrice_) / 1e18;        } else {            vtokenAmount_ = (amount_ * 1e18) / exchangePrice_;        }        _burn(msg.sender, vtokenAmount_);        uint256 fee_ = (amount_ * withdrawalFee) / 10000;        uint256 amountAfterFee_ = amount_ - fee_;        uint256[] memory transferAmts_ = withdrawFinal(amountAfterFee_);        (uint256 wethAmt_, uint256 stEthAmt_) = withdrawTransfers(            amountAfterFee_,            transferAmts_        );        (bool maxIsOk_, , , , bool hfIsOk_) = validateFinalRatio();        require(maxIsOk_ && hfIsOk_, \"Aave-position-risky\");        if (wethAmt_ > 0) {            wethCoreContract.<mask0>;            Address.sendValue(payable(to_), wethAmt_);        }        if (stEthAmt_ > 0) stEthContract.safeTransfer(to_, stEthAmt_);        if (afterDeleverage_) {            (, , , bool minGapIsOk_, ) = validateFinalRatio();            require(minGapIsOk_, \"Aave-position-risky\");        }    }"