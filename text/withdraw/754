"function _withdraw(        uint256 depositID,        uint256 fundingID,        bool early    ) internal {        Deposit storage depositEntry = _getDeposit(depositID);        require(depositEntry.active, \"DInterest: Deposit not active\");        depositEntry.active = false;        if (early) {            require(                now < depositEntry.maturationTimestamp,                \"DInterest: Deposit mature, use withdraw() instead\"            );            require(                now > depositEntry.depositTimestamp,                \"DInterest: Deposited in same block\"            );        } else {            require(                now >= depositEntry.maturationTimestamp,                \"DInterest: Deposit not mature\"            );        }        require(            depositNFT.ownerOf(depositID) == msg.sender,            \"DInterest: Sender doesn't own depositNFT\"        );        {            uint256 takeBackMPHAmount =                mphMinter.takeBackDepositorReward(                    msg.sender,                    depositEntry.mintMPHAmount,                    early                );            emit EWithdraw(                msg.sender,                depositID,                fundingID,                early,                takeBackMPHAmount            );        }        totalDeposit = totalDeposit.sub(depositEntry.amount);        totalInterestOwed = totalInterestOwed.sub(depositEntry.interestOwed);        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();        require(            currentMoneyMarketIncomeIndex > 0,            \"DInterest: currentMoneyMarketIncomeIndex == 0\"        );        (bool depositSurplusIsNegative, uint256 depositSurplus) =            surplusOfDeposit(depositID);        {            uint256 feeAmount;            uint256 withdrawAmount;            if (early) {                withdrawAmount = depositEntry.amount;            } else {                feeAmount = feeModel.getFee(depositEntry.interestOwed);                withdrawAmount = depositEntry.amount.add(                    depositEntry.interestOwed                );            }            withdrawAmount = moneyMarket.<mask0>;            stablecoin.safeTransfer(msg.sender, withdrawAmount.sub(feeAmount));            if (feeAmount > 0) {                stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);            }        }        if (depositIsFunded(depositID)) {            _payInterestToFunder(                fundingID,                depositID,                depositEntry.amount,                depositEntry.maturationTimestamp,                depositEntry.interestOwed,                depositSurplusIsNegative,                depositSurplus,                currentMoneyMarketIncomeIndex,                early            );        } else {            unfundedUserDepositAmount = unfundedUserDepositAmount.sub(                depositEntry.amount.add(depositEntry.interestOwed)            );            depositEntry.finalSurplusIsNegative = depositSurplusIsNegative;            depositEntry.finalSurplusAmount = depositSurplus;        }    }"