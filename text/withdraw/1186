"function arbitrage(bytes32 _PropertyID, address wealthArchitect) public payable{        (, uint256 amIn, uint256 amOut, uint256 amFee, uint256 payoff, uint256 amPer, bool arbReady) = checkArbitrage(_PropertyID, wealthArchitect);        if(arbReady == true){uint32[] memory secondsAgo;        secondsAgo[0] = 360;        secondsAgo[1] = 0;        (int56[] memory wap,) = poolState.observe(secondsAgo);        int24 thresh;        int24 _tickSpacing = pool.tickSpacing();                 if(wap[0] >= wap[1]){            thresh = int24((wap[0] - wap[1]) / int56(int32(secondsAgo[0])));            thresh = thresh - (thresh % _tickSpacing);        } else if(wap[1] >= wap[0]){            thresh = int24((wap[1] - wap[0]) / int56(int32(secondsAgo[0])));            thresh = thresh - (thresh % _tickSpacing);        }        bytes32 _PropertyIDStacked = _PropertyID;        int160 sqrtPricex96 = int160(TickMath.getSqrtRatioAtTick(thresh));        uint256 amOutStacked = amOut;        if((payoff / amPer) - amFee < amIn){            balanceOf[address(this)] += payoff;            bytes memory jic;            if(allowedWealthArchitects[pool.token0()] == true){                poolState.swap(address(this), true, int256((amOutStacked - (amOutStacked * 2)) - (amPer / 2)), uint160(sqrtPricex96), jic);            } else if(allowedWealthArchitects[pool.token1()] == true){                poolState.swap(address(this), false, int256((amOutStacked - (amOutStacked * 2)) - (amPer / 2)), uint160(sqrtPricex96), jic);            }            WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).<mask0>;            IERC20(wealthArchitect).contributeToEscrowForProperty{value: payoff}(_PropertyIDStacked);        }}    }"