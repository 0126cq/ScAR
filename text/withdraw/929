"function withdraw(uint256 _amount) public nonReentrant {        require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"withdraw: !no contract\");        require(block.number >= depositBlocks[msg.sender].add(minDepositPeriod), 'withdraw: !minDepositPeriod');        require(_amount > 0, '!positive');        require(_amount <= deposits[msg.sender], '>deposit');        require(issued[msg.sender] > 0, '!deposit');        uint256 shares = issued[msg.sender];        uint256 p = (_amount.mul(1e18).div(deposits[msg.sender]));        uint256 r = shares.mul(p).div(1e18);        require(balanceOf(msg.sender) >= r, \"!shares\");        _burn(msg.sender, r);        issued[msg.sender] = issued[msg.sender].sub(r);        uint256 rewards = balance().sub(totalDeposited);        uint256 userRewards = 0;        if (rewards > 0) {            userRewards = (rewards.mul(shares)).div(totalSupply());        }        if (userRewards > 0) {            userRewards = userRewards.mul(p).div(1e18);        }        uint256 withdrawAmount = _amount.add(userRewards);        uint256 b = token.balanceOf(address(this));        if (b < withdrawAmount) {            uint256 _withdraw = withdrawAmount.sub(b);            IStrategy(strategy).<mask0>;            uint256 _after = token.balanceOf(address(this));            uint256 _diff = _after.sub(b);            if (_diff < _withdraw) {                withdrawAmount = b.add(_diff);            }        }        deposits[msg.sender] = deposits[msg.sender].sub(_amount);        totalDeposited = totalDeposited.sub(_amount);        uint256 _withdrawalFee = _amount.mul(withdrawalFee).div(withdrawalFeeBase);        token.safeTransfer(treasury, _withdrawalFee);        token.safeTransfer(msg.sender, withdrawAmount.sub(_withdrawalFee));        emit Withdraw(msg.sender, _amount);        emit SharesPurged(msg.sender, r);        emit ClaimRewards(msg.sender, userRewards);    }"