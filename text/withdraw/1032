"function _redeemVault(address _pool, uint256 _totalInputAmount) internal returns (uint256 totalOutputAmount) {    require(_totalInputAmount != 0, \"NULL_INPUT\");    address[] memory tokens = poolTokens[_pool];    uint256 len = tokens.length;    uint256[] memory amounts = new uint256[](len);    for (uint256 i = 0; i < len; i++) {      amounts[i] = IERC20(tokens[i]).balanceOf(address(this));    }    PowerIndexPoolInterface(_pool).exitPool(_totalInputAmount, amounts);    for (uint256 i = 0; i < len; i++) {      amounts[i] = IERC20(tokens[i]).balanceOf(address(this)).sub(amounts[i]);    }    uint256 outputTokenBalanceBefore = usdc.balanceOf(address(this));    for (uint256 i = 0; i < len; i++) {      VaultConfig storage vc = vaultConfig[tokens[i]];      uint256 lpTokenBalanceBefore = IERC20(vc.lpToken).balanceOf(address(this));      IVault(tokens[i]).<mask0>;      uint256 lpTokenAmount = IERC20(vc.lpToken).balanceOf(address(this)).sub(lpTokenBalanceBefore);      if (vc.depositorType == 2) {        ICurveZapDepositor(vc.depositor).remove_liquidity_one_coin(vc.lpToken, lpTokenAmount, int8(vc.depositorIndex), 1);      } else {        ICurveDepositor(vc.depositor).remove_liquidity_one_coin(lpTokenAmount, int8(vc.depositorIndex), 1);      }    }    totalOutputAmount = usdc.balanceOf(address(this)).sub(outputTokenBalanceBefore);    require(totalOutputAmount != 0, \"NULL_OUTPUT\");  }"