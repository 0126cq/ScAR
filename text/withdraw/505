"function redeem(uint256 share) public nonReentrant {        require(share > 0, \"Cannot withdraw 0\");        require(totalSupply() > 0, \"No value redeemable\");        uint256 tokenTotal = totalSupply();        _burn(_msgSender(),share);         bool nonContract = false;        if(tx.origin == _msgSender()){            nonContract = true;         }else{            require(userInfo[_msgSender()].depositTime < now && userInfo[_msgSender()].depositTime > 0, \"Contract depositor cannot redeem in same transaction\");        }        if(share <= userInfo[_msgSender()].shareEstimate){            userInfo[_msgSender()].shareEstimate = userInfo[_msgSender()].shareEstimate.sub(share);        }else{            userInfo[_msgSender()].shareEstimate = 0;            require(nonContract == true, \"Contract depositors cannot take out more than what they put in\");        }        uint256 withdrawAmount = 0;        if(currentStrategy != StabilizeStrategy(address(0))){            withdrawAmount = currentStrategy.<mask0>;             require(withdrawAmount > 0, \"Failed to withdraw from the strategy\");        }else{            if(share < tokenTotal){                uint256 _balance = getNormalizedTotalBalance(address(this));                uint256 _myBalance = _balance.mul(share).div(tokenTotal);                withdrawPerBalance(_msgSender(), _myBalance, false);                 withdrawAmount = _myBalance;            }else{                uint256 _balance = getNormalizedTotalBalance(address(this));                withdrawPerBalance(_msgSender(), _balance, true);                withdrawAmount = _balance;            }        }        emit Unwrapped(_msgSender(), withdrawAmount);    }"