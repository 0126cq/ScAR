"function withdraw(uint256 amount) public discountCHI updateReward(msg.sender) checkNextEpoch {        require(amount > 0, \"Cannot withdraw 0\");        claim();        require(amount <= stakers[msg.sender].stake, \"!balance\");        uint256 actualWithdrawAmount = amount;        uint256 b = yfv.balanceOf(address(this));        if (b < actualWithdrawAmount) {            if (controller != address(0)) {                uint256 _withdraw = actualWithdrawAmount.sub(b);                IController(controller).<mask0>;                uint256 _after = yfv.balanceOf(address(this));                uint256 _diff = _after.sub(b);                if (_diff < _withdraw) {                    actualWithdrawAmount = b.add(_diff);                }            } else {                actualWithdrawAmount = b;            }        }        stakers[msg.sender].payout = stakers[msg.sender].payout.sub(            global.earnings_per_share.mul(amount).div(magnitude)        );        stakers[msg.sender].stake = stakers[msg.sender].stake.sub(amount);        global.total_stake = global.total_stake.sub(amount);        if (block.timestamp < unfrozenStakeTime(msg.sender)) {            if (unlockWithdrawFee == 0) revert(\"Coin is still frozen\");            uint256 withdrawFee = amount.mul(unlockWithdrawFee).div(10000);            uint256 r = amount.sub(withdrawFee);            if (actualWithdrawAmount > r) {                withdrawFee = actualWithdrawAmount.sub(r);                actualWithdrawAmount = r;                if (yfvInsuranceFund != address(0)) {                     safeTokenTransfer(yfv, yfvInsuranceFund, withdrawFee);                    emit RewardPaid(yfvInsuranceFund, withdrawFee);                } else {                     yfv.burn(withdrawFee);                    emit Burned(withdrawFee);                }            }        }        safeTokenTransfer(yfv, msg.sender, actualWithdrawAmount);        emit Withdrawn(msg.sender, amount, actualWithdrawAmount);    }"