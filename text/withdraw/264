"function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss){        bool liquidateAll = _amountNeeded >= estimatedTotalAssets()? true : false;        if (liquidateAll){ \t            (uint256 _mToken, ) = MMFarmingPool(mmFarmingPool).userInfo(mmFarmingPoolId, address(this));            MMFarmingPool(mmFarmingPool).withdraw(mmFarmingPoolId, _mToken);            MMVault(mmVault).<mask0>;            _liquidatedAmount = IERC20(want).balanceOf(address(this));            uint256 ttDebt = vault.strategies(address(this)).totalDebt;            uint256 _liquidateAllLoss = 0;            if (_liquidatedAmount < ttDebt){               _liquidateAllLoss = ttDebt.sub(_liquidatedAmount);            }            return (_liquidatedAmount, _liquidateAllLoss);\t\t  \t\t          } else{ \t            uint256 _before = IERC20(want).balanceOf(address(this));            if (_before < _amountNeeded){                           uint256 _gap = _amountNeeded.sub(_before);\t               uint256 _mShare = _convertWantToMToken(_gap);\t\t\t               uint256 _mmVault = IERC20(mmVault).balanceOf(address(this));               if (_mmVault < _mShare){                   _withdrawFromFarming(_mShare, _mmVault);               }               MMVault(mmVault).withdraw(_mShare);               uint256 _after = IERC20(want).balanceOf(address(this));               require(_after > _before, '!mismatchMushroomsVaultWithdraw');               return (_after, _amountNeeded > _after? _amountNeeded.sub(_after): 0);\t\t            } else{               return (_amountNeeded, _loss);            }\t\t        }    }"