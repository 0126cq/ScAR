"function mintPassWithAllocation(    uint256 count,    uint256 allocated,    bytes32[] calldata proof  ) external payable {    address sender = _msgSender();    bytes32 leaf = keccak256(abi.encode(sender, allocated));    if (!proof.verify(_rootHash, leaf)) {      revert InvalidProof(sender, allocated, leaf, _rootHash);    } else {      emit ProofValidated(sender, allocated, leaf, _rootHash);    }    uint256 supply = totalSupply(0);    if (supply + count > total) {      revert InsufficientSupply(total, supply, count);    }    uint256 claiming = _claimed[_msgSender()];    uint256 remaining = (claiming < allocated) ? allocated - claiming : 0;    uint256 paid = remaining > count ? 0 : count - remaining;    emit TokensClaimed(sender, claiming, count, paid);    uint256 cost = paid * price;    if (msg.value < cost) {      revert InsufficientFunds(cost, msg.value);    }    _mint(sender, 0, count, \"minted from presale\");    _claimed[sender] += (count - paid);    if (msg.value > cost) {      uint256 refund = msg.value - cost;      (bool success, ) = payable(sender).<mask0>;      require(success);    }  }"