"function stakeToBreed(uint256 _ATokenId, uint256 _BTokenId) external virtual whenNotPaused nonReentrant{        Stake storage stake = stakes[_msgSender()];        bool limitedTokenStaked;        require(_exists(_ATokenId), \"Token A does not exist.\");        require(_exists(_BTokenId), \"Token B does not exist.\");        require(limitedIdsAreSet, \"Breeding can only start when limited ids are set.\");        require(!ticketSale, \"Ticket sale must end.\");        require(stakingStarted, \"Staking has not started.\");        require(!stake.staked, \"User is already breeding.\");        if (isLimited[_ATokenId]) {            require(!limitedGaveBirth[_ATokenId], \"Limited token has already gave birth.\");            limitedTokenStaked = true;        }        if (isLimited[_BTokenId]) {            require(!limitedGaveBirth[_BTokenId], \"Limited token has already gave birth.\");            if (!limitedTokenStaked) limitedTokenStaked = true;        }        require(            ownerOf(_ATokenId) == _msgSender() &&            ownerOf(_BTokenId) == _msgSender(),            \"One of the token IDs do not belong to the caller.\"        );        require(            _checkStamina(_ATokenId) != 0 &&            _checkStamina(_BTokenId) != 0,            \"One of thetoken ID's stamina is 0.\"        );        stake.staked = true;        stake.stakedAt = block.timestamp;        stake.stakedIds.push(_ATokenId);        stake.stakedIds.push(_BTokenId);        _safeTransfer(_msgSender(), address(this), _ATokenId, \"\");        <mask0>;        emit UserStaked(_msgSender(), _ATokenId, _BTokenId, limitedTokenStaked);    }"