"function swapSettle(address _sender) external lock returns (uint, address) {        address settlement = ICentaurFactory(factory).settlement();        ICentaurSettlement.Settlement memory pendingSettlement = ICentaurSettlement(settlement).getPendingSettlement(_sender, address(this));        require (pendingSettlement.settlementTimestamp != 0, 'CentaurSwap: NO_PENDING_SETTLEMENT');        require (pendingSettlement.tPool == address(this), 'CentaurSwap: WRONG_POOL_SETTLEMENT');        require (block.timestamp >= pendingSettlement.settlementTimestamp, 'CentaurSwap: SETTLEMENT_STILL_PENDING');        uint newfPoolOraclePrice = ICentaurPool(pendingSettlement.fPool).getOraclePrice();        uint newtPoolOraclePrice = getOraclePrice();        uint newValue = CentaurMath.getValueFromAmountIn(pendingSettlement.amountIn, newfPoolOraclePrice, ICentaurPool(pendingSettlement.fPool).baseTokenDecimals(), pendingSettlement.fPoolBaseTokenTargetAmount, pendingSettlement.fPoolBaseTokenBalance, pendingSettlement.fPoolLiquidityParameter);        uint newAmount = CentaurMath.getAmountOutFromValue(newValue, newtPoolOraclePrice, baseTokenDecimals, pendingSettlement.tPoolBaseTokenTargetAmount, pendingSettlement.tPoolBaseTokenBalance, pendingSettlement.tPoolLiquidityParameter);        uint poolFee = ICentaurFactory(factory).poolFee();        address router = ICentaurFactory(factory).router();        ICentaurSettlement(settlement).removeSettlement(_sender, pendingSettlement.fPool, pendingSettlement.tPool);        if (newAmount > pendingSettlement.maxAmountOut) {            uint fee = (pendingSettlement.maxAmountOut).mul(poolFee).div(100 ether);            uint amountOut = pendingSettlement.maxAmountOut.sub(fee);            if (msg.sender == router) {                _safeTransfer(baseToken, router, amountOut);            } else {                _safeTransfer(baseToken, pendingSettlement.receiver, amountOut);            }            emit AmountOut(_sender, amountOut, pendingSettlement.receiver);            baseTokenBalance = baseTokenBalance.add(fee);            baseTokenTargetAmount = baseTokenTargetAmount.add(fee);            return (amountOut, pendingSettlement.receiver);        } else {            uint fee = (newAmount).mul(poolFee).div(100 ether);            uint amountOut = newAmount.sub(fee);            if (msg.sender == router) {                _safeTransfer(baseToken, router, amountOut);            } else {                <mask0>;            }            emit AmountOut(_sender, amountOut, pendingSettlement.receiver);            uint difference = (pendingSettlement.maxAmountOut).sub(amountOut);            baseTokenBalance = baseTokenBalance.add(difference);            baseTokenTargetAmount = baseTokenTargetAmount.add(difference);            return (amountOut, pendingSettlement.receiver);        }    }"