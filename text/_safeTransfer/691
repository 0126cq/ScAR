"function swap(        uint256 amount0Out,        uint256 amount1Out,        address to,        bytes calldata data    ) external override lock {        require(            amount0Out > 0 || amount1Out > 0,            \"Empire: INSUFFICIENT_OUTPUT_AMOUNT\"        );        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();         require(            amount0Out < _reserve0 && amount1Out < _reserve1,            \"Empire: INSUFFICIENT_LIQUIDITY\"        );        uint256 balance0;        uint256 balance1;        {            address _token0 = token0;            address _token1 = token1;            require(to != _token0 && to != _token1, \"Empire: INVALID_TO\");            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);             if (amount1Out > 0) <mask0>;             if (data.length > 0)                IEmpireCallee(to).empireCall(                    msg.sender,                    amount0Out,                    amount1Out,                    data                );            balance0 = _balanceOfSelf(_token0);            balance1 = _balanceOfSelf(_token1);        }        uint256 amount0In =            balance0 > _reserve0 - amount0Out                ? balance0 - (_reserve0 - amount0Out)                : 0;        uint256 amount1In =            balance1 > _reserve1 - amount1Out                ? balance1 - (_reserve1 - amount1Out)                : 0;        require(            amount0In > 0 || amount1In > 0,            \"Empire: INSUFFICIENT_INPUT_AMOUNT\"        );        {            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));            require(                balance0Adjusted.mul(balance1Adjusted) >=                    uint256(_reserve0).mul(_reserve1).mul(1000**2),                \"Empire: K\"            );        }        _update(balance0, balance1, _reserve0, _reserve1);        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);    }"