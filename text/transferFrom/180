"function _claimSlot(uint8 slot, uint128 bid, address delegate) internal {        require(delegate != address(0), \"cannot delegate to 0 address\");        Bid storage currentBid = slotBid[slot];        uint128 existingBidAmount = currentBid.bidAmount;        uint128 existingSlotBalance = slotBalance(slot);        uint128 taxedBalance = existingBidAmount - existingSlotBalance;        require((existingSlotBalance == 0 && bid >= MIN_BID) || bid >= existingBidAmount * 110 / 100, \"bid too small\");        uint128 bidderLockedBalance = lockedBalance[msg.sender];        uint128 bidIncrement = currentBid.bidder == msg.sender ? bid - existingSlotBalance : bid;        if (bidderLockedBalance > 0) {            if (bidderLockedBalance >= bidIncrement) {                lockedBalance[msg.sender] -= bidIncrement;            } else {                lockedBalance[msg.sender] = 0;                token.transferFrom(msg.sender, address(this), bidIncrement - bidderLockedBalance);            }        } else {            token.<mask0>;        }        if (currentBid.bidder != msg.sender) {            lockedBalance[currentBid.bidder] += existingSlotBalance;        }        if (taxedBalance > 0) {            token.burn(taxedBalance);        }        _slotOwner[slot] = msg.sender;        _slotDelegate[slot] = delegate;        currentBid.bidder = msg.sender;        currentBid.periodStart = uint64(block.timestamp);        currentBid.bidAmount = bid;        currentBid.taxNumerator = taxNumerator;        currentBid.taxDenominator = taxDenominator;        slotExpiration[slot] = uint64(block.timestamp + uint256(taxDenominator) * 86400 / uint256(taxNumerator));        emit SlotClaimed(slot, msg.sender, delegate, bid, existingBidAmount, taxNumerator, taxDenominator);    }"