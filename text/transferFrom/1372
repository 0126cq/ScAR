"function bidForAuction(address _nft, uint256 _tokenId, uint256 _tokenAmount) public payable{        Auction storage act = TokenAuctions[_nft][_tokenId];        require(            act.onAuction == true && act.expiresAt > block.timestamp,            \"MarketPlace: Token expired from auction\"        );        if(act.quikTrade){          require(                _tokenAmount >= act.startingPrice,                \"MarketPlace: Bid amount is lower than startingPrice\"          );          if (act.currentBidPrice != 0) {              require(                  _tokenAmount >=                      (act.currentBidPrice +                          cutPer10000(minimunBidPer10000, act.currentBidPrice)),                  \"MarketPlace: Bid Amount is less than minimunBid required\"              );          }        }        else{          require(                  msg.value >= act.startingPrice,                  \"MarketPlace: Bid amount is lower than startingPrice\"                );          if (act.currentBidPrice != 0) {              require(                  msg.value >=                      (act.currentBidPrice +                          cutPer10000(minimunBidPer10000, act.currentBidPrice)),                  \"MarketPlace: Bid Amount is less than minimunBid required\"              );            }        }        address currentBidder = act.currentBidder;        uint256 prevBidPrice = act.currentBidPrice;        act.currentBidPrice = 0;        if(act.quikTrade){          IERC20(tradeToken).<mask0>;          if(currentBidder != address(0))              IERC20(tradeToken).transfer(currentBidder, prevBidPrice);        }        else{          if(currentBidder != address(0))              withdrawETH(currentBidder, prevBidPrice);        }        if(act.quikTrade){          act.currentBidPrice = _tokenAmount;        }else{          act.currentBidPrice = msg.value;        }        act.currentBidder = msg.sender;        emit BidCreated(_nft, _tokenId, msg.sender, _tokenAmount);    }"