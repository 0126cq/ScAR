"function buyBatchTokens(address beneficiary, uint256[] memory tokenIds) public payable{        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");        uint256 tokenAmount = _landPerToken * tokenIds.length;        require(tokenAmount <= _land.allowance(_msgSender(), address(this)), \"Crowdsale: Not enough CLD allowance\");        for (uint256 i = 0; i < tokenIds.length; ++i) {            require(tokenIds[i] < getMaxTokenCount(), \"Crowdsale: tokenId must be less than max token count\");            (uint256 x, uint256 y) = cellById(tokenIds[i]);            require(x < 38 || x > 53 || y < 28 || y > 43, \"Crowdsale: tokenId should not be in the unsold range\");            require(!_cellToken.exists(tokenIds[i]), \"Crowdsale: token already minted\");        }        uint256 balance = _land.balanceOf(_msgSender());        if (tokenAmount <= balance){            _land.transferFrom(_msgSender(), _wallet, tokenAmount);        }        else{            require(msg.value > 0, \"Crowdsale: Not enough CLD or ETH\");            uint256 newAmount = _getTokenAmount(msg.value);            require(newAmount.add(balance) >= tokenAmount, \"Crowdsale: Not enough CLD or ETH\");            _land.<mask0>;            _land.transferFrom(_msgSender(), _wallet, tokenAmount);            _wallet.transfer(msg.value);        }        _tokenRaised += tokenAmount;        for (uint256 i = 0; i < tokenIds.length; ++i) {            _cellToken.mint(beneficiary, tokenIds[i]);            emit TokensPurchased(msg.sender, beneficiary, tokenIds[i]);        }    }"