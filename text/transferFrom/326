"function deposit(address _uToken, uint256[] calldata tokenIDs, uint256[] calldata amounts, uint256[] calldata prices, address contractAddr) external {        if(notAnyAllowed[_uToken]) {            for (uint8 i=0; i<200; i++) {                if (i == tokenIDs.length) {                    break;                }                require(allowedNFTs[_uToken][contractAddr][tokenIDs[i]], \"PointShop: Attempted deposit of non-whitelisted NFT\");            }        }        require(Converter(_uToken).issuer() == msg.sender ||         isShopAdmin[_uToken][msg.sender] || isPublic[_uToken], \"PointShop: Only shop admin can add to shop\");        require(tokenIDs.length <= 50, \"PointShop: A maximum of 50 tokens can be deposited in one go\");        require(tokenIDs.length > 0, \"PointShop: You must specify at least one token ID\");        if (ERC165Checker.supportsInterface(contractAddr, 0xd9b67a26)){            IERC1155(contractAddr).safeBatchTransferFrom(msg.sender, address(this), tokenIDs, amounts, VALIDATOR);            for (uint8 i = 0; i < 50; i++){                if (tokenIDs.length == i){                    break;                }                nfts[_uToken][currentNFTIndex[_uToken]++] = NFT(contractAddr, tokenIDs[i], amounts[i], prices[i]);            }        }        else {            for (uint8 i = 0; i < 50; i++){                if (tokenIDs.length == i){                    break;                }                IERC721(contractAddr).<mask0>;                nfts[_uToken][currentNFTIndex[_uToken]++] = NFT(contractAddr, tokenIDs[i], 1, prices[i]);            }        }        emit Deposited(_uToken, tokenIDs, amounts, contractAddr);    }"