"function stakeNFT(uint256 tokenId) public payable nonReentrant {        _getStakeFeeIfNeed(msg.value, msg.sender);        StakeInfo storage staker = stakeInfo[msg.sender];        NFTInfo memory ntfInfo = getAmountFromTokenId(tokenId);        uint256 amout0InGpool = (ntfInfo.token0 == address(gpoolToken))            ? ntfInfo.amount0            : tokenInGpool(ntfInfo.token0, ntfInfo.amount0);        uint256 amout1InGpool = (ntfInfo.token1 == address(gpoolToken))            ? ntfInfo.amount1            : tokenInGpool(ntfInfo.token1, ntfInfo.amount1);        uint256 amount = amout0InGpool + amout1InGpool;        require(            gpoolInUSDC(staker.amount + amount + staker.nftInGpoolAmount) >= USDC_THRESHOLD,            \"minimum stake does not match\"        );        positionManager.<mask0>;        if (staker.startStake == 0) {            staker.startStake = block.timestamp;        }        StakeType stakeType = StakeType.NFT;        uint256 length = poolInfo.length;        for (uint256 pid = 0; pid < length; ++pid) {            PoolInfo storage pool = poolInfo[pid];            if (block.timestamp <= pool.openTime) {                continue;            }            RewardInfo storage user = rewardInfo[pid][msg.sender];            updatePool(pid, stakeType);            uint256 pending = ((staker.nftInGpoolAmount * pool.accRewardPerShare[stakeType]) / ACCUMULATED_MULTIPLIER) -                user.rewardDebt[stakeType];            user.pendingReward = user.pendingReward + pending;            user.rewardDebt[stakeType] =                ((staker.nftInGpoolAmount + amount) * pool.accRewardPerShare[stakeType]) /                ACCUMULATED_MULTIPLIER;        }        staker.nftInGpoolAmount += amount;        totalNFTStaked += amount;        nftRecords[msg.sender][tokenId] = amount;        emit StakeNFT(msg.sender, tokenId, amount, staker.startStake);    }"