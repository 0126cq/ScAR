"function _executeOrder(    address nftAddress,    uint256 assetId,    uint256 price,    bytes memory fingerprint  )   internal returns (Order memory)  {    _requireERC721(nftAddress);    address sender = _msgSender();    ERC721Verifiable nftRegistry = ERC721Verifiable(nftAddress);    if (nftRegistry.supportsInterface(InterfaceId_ValidateFingerprint)) {      require(        nftRegistry.verifyFingerprint(assetId, fingerprint),        \"The asset fingerprint is not valid\"      );    }    Order memory order = orderByAssetId[nftAddress][assetId];    require(order.id != 0, \"Asset not published\");    address seller = order.seller;    require(seller != address(0), \"Invalid address\");    require(seller != sender, \"Unauthorized user\");    require(order.price == price, \"The price is not correct\");    require(block.timestamp < order.expiresAt, \"The order expired\");    require(seller == nftRegistry.ownerOf(assetId), \"The seller is no longer the owner\");    uint mineShareAmount = 0;    bytes32 orderId = order.id;    delete orderByAssetId[nftAddress][assetId];    if (ownerCutPerMillion > 0 && seller == sellerAddress) {      mineShareAmount = price.mul(ownerCutPerMillion).div(1000000);      emit SpayMining(        orderId,        assetId,        seller,        sender,        nftAddress,        price,        mineShareAmount      );    }    require(      acceptedToken.<mask0>,      \"Transfering the sale amount to the seller failed\"    );    nftRegistry.safeTransferFrom(      seller,      sender,      assetId    );    emit OrderSuccessful(      orderId,      assetId,      seller,      nftAddress,      price,      sender    );    return order;  }"