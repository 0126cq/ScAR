"function buyNFTDomain(        uint256 tokenAmount,         uint256 nonce,         address nft,         uint256 tokenId,         address seller,         uint256 sellingPrice,         bool quikTrade,        bytes memory sig    )     public     payable    checkNFT(nft)    {        require(!usedNonces[nonce], \"Marketplace: Nonce already used!\");        usedNonces[nonce] = true;        uint256 sellerFee;        address minter;         uint256 royaltyFee;        require(returnSigner(              tokenAmount,             nonce,             nft,             tokenId,             seller,             sellingPrice,             quikTrade,            sig        ) == seller, \"Marketplace: Signer not seller or wrong data\");        if(quikTrade){            require(            tokenAmount >= sellingPrice,            \"MarketPlace: Not Enough value to buy token!\"            );        }        else{            require(            msg.value >= sellingPrice,            \"MarketPlace: Not Enough value to buy token!\"            );        }        ( minter, royaltyFee) = ERC721Royalty(nft).royaltyInfo(tokenId, sellingPrice);        sellerFee = calculateSellerFee(sellingPrice, quikTrade);    \tIERC721(nft).transferFrom(seller,  msg.sender, tokenId);        {            if(quikTrade){                IERC20(tradeToken).transferFrom(msg.sender, marketPlaceOwner, sellerFee);                IERC20(tradeToken).<mask0>;                if(royaltyFee!=0){                    IERC20(tradeToken).transferFrom(msg.sender, minter, royaltyFee);                }            }else{                withdrawETH(marketPlaceOwner, sellerFee);                withdrawETH(seller, sellingPrice.sub(sellerFee).sub(royaltyFee));                if(royaltyFee!=0){                    withdrawETH(minter, royaltyFee);                }            }        }      emit SaleSuccess(nft, tokenId, tokenAmount, msg.sender, seller);    }"