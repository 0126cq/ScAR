"function initialize(        uint256 supply,        address wallet_,        address recipient_,        uint256 price    )    public payable    {        require(wallet == address(0));        recordedTotalSupply   = ShardedWallet(payable(wallet_)).totalSupply();        string memory name_   = ShardedWallet(payable(wallet_)).name();        string memory symbol_ = ShardedWallet(payable(wallet_)).symbol();        etherLPToken = LiquidityToken(Clones.clone(address(_template)));        shardLPToken = LiquidityToken(Clones.clone(address(_template)));        etherLPToken.initialize(address(this), string(abi.encodePacked(name_, \"-EtherLP\")), string(abi.encodePacked(symbol_, \"-ELP\")));        shardLPToken.initialize(address(this), string(abi.encodePacked(name_, \"-ShardLP\")), string(abi.encodePacked(symbol_, \"-SLP\")));        wallet    = wallet_;        recipient = recipient_;        deadline  = block.timestamp + ShardedWallet(payable(wallet_)).governance().getConfig(wallet_, LIQUIDITY_TIMELOCK);        emit Initialized(wallet_);        if (supply > 0) {            require(ShardedWallet(payable(wallet_)).<mask0>);        }        {            uint256 decimals_ = ShardedWallet(payable(wallet_)).decimals();            curve.x = recordedTotalSupply;            curve.k = recordedTotalSupply * recordedTotalSupply * price / 10**decimals_;        }        etherLPToken.controllerMint(address(this), msg.value);        shardLPToken.controllerMint(address(this), supply);        _etherLPExtra.underlyingSupply = msg.value;        _shardLPExtra.underlyingSupply = supply;        emit EtherSupplied(address(this), msg.value);        emit ShardsSupplied(address(this), supply);    }"