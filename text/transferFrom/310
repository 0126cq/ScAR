"function _buy(        address _nftContractAddress,        uint64 _saleId,        address _currency    )        internal        returns(uint256)    {        PetSale storage petSale = PetSales[_saleId];        require(acceptedNFTs.contains(_nftContractAddress), \"SHFStore: contract address not allowed\");        require(petSale.status == SaleStatus.Ongoing, \"SHFStore: Sale must be on going\");        require((_currency == address(0)) || (_currency == binanceUSD), \"SHFStore: Currency not allowed\");        require(petSale.limit > petSale.bought, \"SHFStore: sale reached limit\");        uint256 petSalePrice = petSale.price;        if (_currency == address(0)) {            petSalePrice = getLatestPrice(petSale.price);            require(msg.value >= petSalePrice, \"SHFStore: Not enough balance\");        } else{            petSalePrice = petSale.price * 10**18;            IERC20(_currency).<mask0>;        }        petSale.bought++;        ShibaFriendPet(_nftContractAddress).mintBuy(msg.sender, petSale.tier,petSale.batchId);        if (petSale.bought == petSale.limit) {            emit SaleEnded(_nftContractAddress, petSale.batchId, petSale.tier);        }        return petSalePrice;    }"