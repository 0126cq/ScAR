"function executeAdvanced(    AdvancedCall[] calldata calls  ) external override onlyOwner() returns (    AdvancedCallReturn[] memory callResults  ) {    for (uint256 i = 0; i < calls.length; i++) {      if (calls[i].value == 0) {        _ensureValidGenericCallTarget(calls[i].to);      }    }    callResults = new AdvancedCallReturn[](calls.length);    _selfCallContext = this.executeAdvanced.selector;    (bool externalOk, bytes memory rawCallResults) = address(this).call(      abi.<mask0>    );    if (      rawCallResults.length > 68 &&       rawCallResults[0] == bytes1(0x08) &&      rawCallResults[1] == bytes1(0xc3) &&      rawCallResults[2] == bytes1(0x79) &&      rawCallResults[3] == bytes1(0xa0)    ) {      assembly {        returndatacopy(0, 0, returndatasize())        revert(0, returndatasize())      }    }    if (!externalOk) {      delete _selfCallContext;    }    callResults = abi.decode(rawCallResults, (AdvancedCallReturn[]));    for (uint256 i = 0; i < callResults.length; i++) {      AdvancedCall memory currentCall = calls[i];      if (callResults[i].ok) {        emit CallSuccess(          !externalOk,           currentCall.to,          uint256(callResults[i].callValue),          callResults[i].callData,          callResults[i].returnData        );      } else {        emit CallFailure(          currentCall.to,          uint256(callResults[i].callValue),          callResults[i].callData,          _decodeRevertReason(callResults[i].returnData)        );        break;      }    }  }"