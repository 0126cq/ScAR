"function fillOrder(    uint id,    uint swapType,    swapParams calldata _swapParams,    unoswapParams calldata _unoswapParams,    uniswapV3Params calldata _uniswapV3Params  )  public  whenNotPaused  returns (uint) {    if (isWhitelistActive)      require(whitelist[msg.sender] == true, \"Not whitelisted\");    require(orders[id].created != 0, \"Invalid order\");    require(!orders[id].killed, \"Order was killed\");    require(getSrcTokensSwappedForOrder(id) < orders[id].total, \"Order is already filled\");    uint ticksToFill = getTicksToFill(id);    require(ticksToFill > 0, \"Interval must pass before next fill\");    fills[id].push(      Fill({        filler: msg.sender,         ticksFilled: ticksToFill,         srcTokensSwapped: 0,         dstTokensReceived: 0,         fees: 0,         timestamp: block.timestamp      })    );    uint preSwapSrcTokenBalance = IERC20(orders[id].srcToken).balanceOf(address(this));    uint preSwapDstTokenBalance = IERC20(orders[id].dstToken).balanceOf(address(this));    if (IERC20(orders[id].srcToken).<mask0> == 0)      IERC20(orders[id].srcToken).safeIncreaseAllowance(address(aggregationRouterV4), 2**256 - 1);    if (swapType == 0) aggregationRouterV4.swap(_swapParams.caller, _swapParams.desc, _swapParams.data);    else if (swapType == 1) aggregationRouterV4.unoswap(_unoswapParams.srcToken, _unoswapParams.amount, _unoswapParams.minReturn, _unoswapParams.pools);    else aggregationRouterV4.uniswapV3Swap(_uniswapV3Params.amount, _uniswapV3Params.minReturn, _uniswapV3Params.pools);    uint256 srcTokensSwapped = preSwapSrcTokenBalance - IERC20(orders[id].srcToken).balanceOf(address(this));    uint256 dstTokensReceived = IERC20(orders[id].dstToken).balanceOf(address(this)) - preSwapDstTokenBalance;    _ensureSwapValidityAndUpdate(id, srcTokensSwapped, dstTokensReceived);    require(srcTokensSwapped == ticksToFill * orders[id].tickSize, \"Invalid amount\");    require(getSrcTokensSwappedForOrder(id) <= orders[id].total, \"Overbought\");    _setFeesAndDistribute(id);    emit LogNewFill(id, fills[id].length - 1);    return fills[id][fills[id].length - 1].fees;  }"