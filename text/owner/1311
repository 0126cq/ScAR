"function _transfer(        address from,        address to,        uint256 amount    ) internal override {        require(from != address(0), \"ERC20: transfer from the zero address\");        require(to != address(0), \"ERC20: transfer to the zero address\");         if(amount == 0) {            super._transfer(from, to, 0);            return;        }        if(limitsInEffect){            if (                from != <mask0> &&                to != owner() &&                to != address(0) &&                to != address(0xdead) &&                !swapping            ){                if(!tradingActive){                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");                }                if (gasLimitActive && automatedMarketMakerPairs[from]) {                    require(tx.gasprice <= gasPriceLimit, \"Gas price exceeds limit.\");                }                if (transferDelayEnabled){                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");                        _holderLastTransferTimestamp[tx.origin] = block.number;                    }                }                if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {                        require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");                }            }        }        if(airDropLimitInEffect){             if(airDropLimitLiftDate <= block.timestamp){                airDropLimitInEffect = false;              } else {                uint256 senderBalance = balanceOf(from);                 if(_isAirdoppedWallet[from] && senderBalance.sub(amount) < _airDropTokensRemaining[from]){                    require(_airDropAddressNextSellDate[from] <= block.timestamp && block.timestamp >= airDropLimitLiftDate.sub(9 days), \"_transfer:: Please read the contract for your next sale date.\");                    uint256 airDropMaxSell = getWalletMaxAirdropSell(from);                     uint256 tokensToSubtract = amount.add(_airDropTokensRemaining[from]).sub(senderBalance);                    require(tokensToSubtract <= airDropMaxSell, \"_transfer:: May not sell more than allocated tokens in a single day until the Limit is lifted.\");                    _airDropTokensRemaining[from] = _airDropTokensRemaining[from].sub(tokensToSubtract);                    _airDropAddressNextSellDate[from] = block.timestamp + (1 days * (tokensToSubtract.mul(100).div(airDropMaxSell)))/100;                 }            }        }"