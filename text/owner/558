"function _transfer(address sender, address recipient, uint256 amount) private returns (bool) {        require(sender != address(0), \"ERC20: transfer from the zero address\");        require(recipient != address(0), \"ERC20: transfer to the zero address\");        require(!zerobot[sender] && !zerobot[recipient], \"To/from address is blacklisted!\");        require(amount > 0, \"Transfer amount must be greater than zero\");        if(inSwapAndLiquify)        {             return _basicTransfer(sender, recipient, amount);         }        else        {            if(sender != <mask0> && recipient != owner()) {                require(amount <= maxbuy, \"Transfer amount exceeds the maxTxAmount.\");            }            uint256 contractTokenBalance = balanceOf(address(this));            bool overMinimumTokenBalance = contractTokenBalance >= minimumTokensBeforeSwap;            if (overMinimumTokenBalance && !inSwapAndLiquify && sender != uniswapV2Pair && swapAndLiquifyEnabled)             {                if(swapAndLiquifyByLimitOnly)                    contractTokenBalance = minimumTokensBeforeSwap;                swapAndLiquify(contractTokenBalance);                }            _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");            uint256 finalAmount = (zerotaxwallet[sender] || zerotaxwallet[recipient]) ?                                          amount : getfee(sender, recipient, amount);            if(checkWalletLimit && !zerolimit[recipient])                require(balanceOf(recipient).add(finalAmount) <= maxwallet);            _balances[recipient] = _balances[recipient].add(finalAmount);            emit Transfer(sender, recipient, finalAmount);            return true;        }    }"