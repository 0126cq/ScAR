"function _transfer(        address sender,        address recipient,        uint256 amount    ) internal {        require(            isOpen ||                sender == owner() ||                recipient == owner() ||                _notDegens[sender] ||                _notDegens[recipient],            \"Not Open\"        );        require(!isDegenlisted[sender], \"DGA: Sender is degenlisted\");        require(!isDegenlisted[recipient], \"DGA: Recipient is degenlisted\");        require(sender != address(0), \"DGA: transfer from the zero address\");        require(recipient != address(0), \"DGA: transfer to the zero address\");        uint256 _maxTxAmount = (totalSupply() * maxTxBPS) / 10000;        uint256 _maxWallet = (totalSupply() * maxWalletBPS) / 10000;        require(            amount <= _maxTxAmount || _isExcludedFromMaxTx[sender],            \"TX Limit Exceeded\"        );        if (            sender != <mask0> &&            recipient != address(this) &&            recipient != address(DEAD) &&            recipient != uniswapV2Pair        ) {            uint256 currentBalance = balanceOf(recipient);            require(                _isExcludedFromMaxWallet[recipient] ||                    (currentBalance + amount <= _maxWallet)            );        }        uint256 senderBalance = _balances[sender];        require(            senderBalance >= amount,            \"DGA: transfer amount exceeds balance\"        );        uint256 contractTokenBalance = balanceOf(address(this));        uint256 contractNativeBalance = address(this).balance;        bool canSwap = contractTokenBalance >= swapTokensAtAmount;        if (            swapEnabled &&             canSwap &&             !swapping &&             !automatedMarketMakerPairs[sender] &&             sender != address(uniswapV2Router) &&             sender != owner() &&            recipient != owner()        ) {            swapping = true;            if (!swapAllToken) {                contractTokenBalance = swapTokensAtAmount;            }            _executeSwap(contractTokenBalance, contractNativeBalance);            lastSwapTime = block.timestamp;            swapping = false;        }        bool takeFee;        if (            sender == address(uniswapV2Pair) ||            recipient == address(uniswapV2Pair)        ) {            takeFee = true;        }        if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {            takeFee = false;        }        if (swapping || !taxEnabled) {            takeFee = false;        }        if (takeFee) {            uint256 jeetMulitplier = (recipient == uniswapV2Pair && jeetTaxEnabled) ? 2 : 1;            uint256 fees = (amount * totalFeeBPS) / 10000;            uint256 jeetFees = fees * jeetMulitplier;            amount -= jeetFees;            _executeTransfer(sender, address(this), jeetFees);        }        _executeTransfer(sender, recipient, amount);        dividendTracker.setBalance(payable(sender), balanceOf(sender));        dividendTracker.setBalance(payable(recipient), balanceOf(recipient));    }"