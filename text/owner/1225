"function selfBreedMonsterBuds(        SelfBreed calldata breed,        bytes calldata signature    ) external payable virtual onlyAllowed returns (uint256) {        bool status = SignatureCheckerUpgradeable.isValidSignatureNow(            <mask0>,            breed.signKey,            signature        );        require(status == true, \"$PackwoodERC721: cannot breed[ERROR]\");        require(            breedValue == msg.value,            \"$PackwoodERC721: Amount is incorrect\"        );        address owner_req = (MonsterParent.ownerOf(breed.req_token_id));        address owner_accept = (ownerOf(breed.accept_token_id));        require(selfBreedStatus == true, \"$PackwoodERC721: Breeding is closed\");        require(            owner_req == owner_accept && owner_req == msg.sender,            \"$PackwoodERC721: Cannot Self Breed\"        );        require(            breedInfo[breed.accept_token_id].breedCount < 2,            \"$PackwoodERC721: Exceeds max breed count\"        );        require(            block.timestamp >= breedInfo[breed.accept_token_id].timstamp,            \"$PackwoodERC721: cannot breed now\"        );        uint256 countOfAccept = breedInfo[breed.accept_token_id].breedCount;        breedInfomation storage accept_data = breedInfo[breed.accept_token_id];        accept_data.tokenId = breed.accept_token_id;        accept_data.breedCount = countOfAccept + 1;        accept_data.timstamp = block.timestamp + 1512000;        uint256 newItem = MonsterParent.breedUpdation(            breed.req_token_id,            msg.sender        );        payable(feeSKTWallet).transfer(msg.value);         emit monsterPackwoodSelfBreed(            msg.sender,            breed.req_token_id,            breed.accept_token_id,            MonsterParent.tokenURI(newItem),            newItem,            msg.value        );        return newItemId;    }"