"function _transfer(address sender, address recipient, uint256 amount) private {            require(sender != address(0), \"ERC20: transfer from the zero address\");            require(amount > 0, \"Transfer amount must be greater than zero\");            if(_isAntiDumpEnabled == true && sender != owner() && recipient != owner()){                if(sender == uniswapV2Pair){                    uint256 timePassed = block.timestamp - _antiBot[recipient];                    require(timePassed > antiDumpTime,'You must wait between trades');                    _antiBot[recipient] = block.timestamp;                }                else if(recipient == uniswapV2Pair){                    uint256 timePassed = block.timestamp - _antiBot[sender];                    require(timePassed > antiDumpTime,'You must wait between trades');                    _antiBot[sender] = block.timestamp;                }                else if(sender != uniswapV2Pair && recipient != uniswapV2Pair){                    uint256 timePassed1 = block.timestamp - _antiBot[sender];                    uint256 timePassed2 = block.timestamp - _antiBot[recipient];                    require(timePassed1 > antiDumpTime && timePassed2 > antiDumpTime, 'You Must Wait Some Time Between Transactions');                    _antiBot[sender] = block.timestamp;                    _antiBot[recipient] = block.timestamp;                }            }            if(_isWhitelist[sender] == true) {                uint256 time_since_purchase = block.timestamp - _lockedTime[sender];                if(time_since_purchase < _lockPreSale[sender]){                    require((balanceOf(sender) - amount) >= _lockedAmount[sender], 'You Must Wait Some Time From Original Transaction');                }                else {                    _isWhitelist[sender] == false;                }            }            if(sender != <mask0> && recipient != owner())                require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");            uint256 contractTokenBalance = balanceOf(address(this));            if(contractTokenBalance >= _maxTxAmount)            {                contractTokenBalance = _maxTxAmount;            }            bool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForCharity;            if (!inSwap && swapEnabled && overMinTokenBalance && sender != uniswapV2Pair) {                swapTokensForEth(contractTokenBalance);                uint256 contractETHBalance = address(this).balance;                if(contractETHBalance > 0) {                    sendETHToCharity(address(this).balance);                }            }            bool takeFee = true;            if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){                takeFee = false;            }            _tokenTransfer(sender,recipient,amount,takeFee);        }"