"function _buyShards(address buyer, uint256 amount, uint256 maxCost) internal returns (uint256) {        IGovernance governance = ShardedWallet(payable(wallet)).governance();        address     owner      = ShardedWallet(payable(wallet)).<mask0>;        address     artist     = ShardedWallet(payable(wallet)).artistWallet();        require(owner == address(0) || governance.isModule(wallet, owner));        uint256[3] memory fees;        fees[0] =                            governance.getConfig(wallet, PCT_FEE_SUPPLIERS);        fees[1] =                            governance.getConfig(wallet, PCT_FEE_NIFTEX);        fees[2] = artist == address(0) ? 0 : governance.getConfig(wallet, PCT_FEE_ARTIST);        uint256 amountWithFee = amount * (10**18 + fees[0] + fees[1] + fees[2]) / 10**18;        uint256 newX = curve.x - amountWithFee;        uint256 newY = curve.k / newX;        require(newX > 0 && newY > 0);        uint256 cost = newY - curve.k / curve.x;        require(cost <= maxCost);        require(ShardedWallet(payable(wallet)).balanceOf(address(this)) - _shardLPExtra.feeToNiftex - _shardLPExtra.feeToArtist >= amount * (10**18 + fees[1] + fees[2]) / 10**18);        curve.x = curve.x - amount * (10**18 + fees[1] + fees[2]) / 10**18;        _shardLPExtra.underlyingSupply += amount * fees[0] / 10**18;        _shardLPExtra.feeToNiftex      += amount * fees[1] / 10**18;        _shardLPExtra.feeToArtist      += amount * fees[2] / 10**18;        ShardedWallet(payable(wallet)).transfer(buyer, amount);        emit ShardsBought(buyer, amount, cost);        return cost;    }"