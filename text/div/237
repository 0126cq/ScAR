"function timeRebalance(        address keeper,        uint256 minAmountEth,        uint256 minAmountUsdc,        uint256 minAmountOsqth    ) external override nonReentrant notPaused {        (bool isTimeRebalanceAllowed, uint256 auctionTriggerTime) = IVaultMath(vaultMath).isTimeRebalance();        require(isTimeRebalanceAllowed, \"C10\");        (uint256 ethUsdcPrice, ) = IVaultMath(vaultMath).getPrices();        uint256 cachedPrice = IVaultStorage(vaultStorage).ethPriceAtLastRebalance();        uint256 ratio = cachedPrice > ethUsdcPrice ? cachedPrice.<mask0> : ethUsdcPrice.div(cachedPrice);        uint256 cachedValue = IVaultStorage(vaultStorage).totalValue();        if (ratio <= IVaultStorage(vaultStorage).rebalanceThreshold() && cachedValue != 0) {            IVaultStorage(vaultStorage).setSnapshot(                IVaultStorage(vaultStorage).orderEthUsdcLower(),                IVaultStorage(vaultStorage).orderEthUsdcUpper(),                IVaultStorage(vaultStorage).orderOsqthEthLower(),                IVaultStorage(vaultStorage).orderOsqthEthUpper(),                block.timestamp,                IVaultMath(vaultMath).getIV(),                cachedValue,                cachedPrice            );            emit SharedEvents.NoRebalance(keeper, auctionTriggerTime, ratio);        } else {            _executeAuction(                keeper,                auctionTriggerTime,                Constants.AuctionMinAmounts(minAmountEth, minAmountUsdc, minAmountOsqth)            );            emit SharedEvents.TimeRebalance(keeper, auctionTriggerTime, minAmountEth, minAmountUsdc, minAmountOsqth);        }    }"