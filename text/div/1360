"function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {        uint currentP = P;        uint newP;        assert(_LUSDLossPerUnitStaked <= DECIMAL_PRECISION);        uint newProductFactor = uint(DECIMAL_PRECISION).sub(_LUSDLossPerUnitStaked);        uint128 currentScaleCached = currentScale;        uint128 currentEpochCached = currentEpoch;        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];        uint marginalETHGain = _ETHGainPerUnitStaked.mul(currentP);        uint newS = currentS.add(marginalETHGain);        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;        emit S_Updated(newS, currentEpochCached, currentScaleCached);        if (newProductFactor == 0) {            currentEpoch = currentEpochCached.add(1);            emit EpochUpdated(currentEpoch);            currentScale = 0;            emit ScaleUpdated(currentScale);            newP = DECIMAL_PRECISION;        } else if (currentP.mul(newProductFactor).<mask0> < SCALE_FACTOR) {            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);             currentScale = currentScaleCached.add(1);            emit ScaleUpdated(currentScale);        } else {            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);        }        assert(newP > 0);        P = newP;        emit P_Updated(newP);    }"