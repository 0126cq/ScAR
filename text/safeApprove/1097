"function topup(address user, address bToken, uint amount, bool resetApprove) external onlyMember {        address avatar = registry.avatarOf(user);        address cToken = bComptroller.b2c(bToken);        (uint minTopup, uint maxTopup, bool small) = getDebtTopupInfo(user, bToken);        address underlying = _getUnderlying(cToken);        uint memberBalance = balance[msg.sender][underlying];        require(memberBalance >= amount, \"Pool: topup-insufficient-balance\");        require(ICushion(avatar).remainingLiquidationAmount() == 0, \"Pool: cannot-topup-in-liquidation\");        TopupInfo storage info = topped[avatar];        _untopOnMembers(user, avatar, cToken, small);        MemberTopupInfo storage memberInfo = info.memberInfo[msg.sender];        require(add_(amount, memberInfo.amountTopped) >= minTopup, \"Pool: topup-amount-small\");        require(add_(amount, memberInfo.amountTopped) <= maxTopup, \"Pool: topup-amount-big\");        if(small && memberInfo.expire != 0 && memberInfo.expire <= now) {            require(smallTopupWinner(avatar) == msg.sender, \"Pool: topup-not-your-turn\");        }        balance[msg.sender][underlying] = sub_(memberBalance, amount);        topupBalance[msg.sender][underlying] = add_(topupBalance[msg.sender][underlying], amount);        if(small && memberInfo.expire <= now) {            memberInfo.expire = add_(now, holdingTime);        }        memberInfo.amountTopped = add_(memberInfo.amountTopped, amount);        memberInfo.amountLiquidated = 0;        info.debtToLiquidatePerMember = 0;        info.cToken = cToken;        if(_isCEther(cToken)) {            ICushionCEther(avatar).topup.value(amount)();        } else {            if(resetApprove) IERC20(underlying).safeApprove(avatar, 0);            IERC20(underlying).<mask0>;            ICushionCErc20(avatar).topup(cToken, amount);        }    }"