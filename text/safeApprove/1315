"function prepareReturn(uint256 _debtOutstanding)        internal        override        returns (            uint256 _profit,            uint256 _loss,            uint256 _debtPayment        )    {        uint before = want.balanceOf(address(this));        IVoterProxy(proxy).harvest(gauge);        uint256 _crv = IERC20(crv).balanceOf(address(this));        if (_crv > 0) {            _crv = _adjustCRV(_crv);            IERC20(crv).safeApprove(dex, 0);            IERC20(crv).safeApprove(dex, _crv);            address[] memory path = new address[](3);            path[0] = crv;            path[1] = weth;            path[2] = link;                        Uni(dex).swapExactTokensForTokens(_crv, uint256(0), path, address(this), now);        }        uint256 _link = IERC20(link).balanceOf(address(this));        if (_link > 0) {            IERC20(link).<mask0>;            IERC20(link).safeApprove(curve, _link);            ICurveFi(curve).add_liquidity([_link, 0], 0);        }        _profit = want.balanceOf(address(this)).sub(before);        uint _total = estimatedTotalAssets();        uint _debt = vault.strategies(address(this)).totalDebt;        if(_total < _debt) {            _loss = _debt - _total;            _profit = 0;        }        if (_debtOutstanding > 0) {            _withdrawSome(_debtOutstanding);            _debtPayment = Math.min(_debtOutstanding, balanceOfWant().sub(_profit));        }    }"