"function buyDelegationBoost(        address delegator,        address receiver,        uint256 percent,        uint256 duration,         uint256 maxFeeAmount    ) external nonReentrant whenNotPaused returns(uint256){        require(            delegator != address(0) && receiver != address(0),            \"Warden: Zero address\"        );        require(warden.userIndex(delegator) != 0, \"Warden: Not registered\");        require(maxFeeAmount > 0, \"Warden: No fees\");        require(            percent >= warden.minPercRequired(),            \"Warden: Percent under min required\"        );        require(percent <= MAX_PCT, \"Warden: Percent over 100\");        uint256 previousBalance = feeToken.balanceOf(address(this));        feeToken.safeTransferFrom(msg.sender, address(this), maxFeeAmount);        if(feeToken.allowance(address(this), address(warden)) != 0) feeToken.safeApprove(address(warden), 0);        feeToken.<mask0>;        uint256 nbTokens = delegationBoost.total_minted(delegator);        uint256[256] memory expiredBoosts;         uint256 nbExpired = 0;        for (uint256 i = 0; i < nbTokens;) {            uint256 tokenId = delegationBoost.token_of_delegator_by_index(                delegator,                i            );            if (delegationBoost.token_expiry(tokenId) < block.timestamp) {                expiredBoosts[nbExpired] = tokenId;                nbExpired++;            }            unchecked{ ++i; }        }        if (nbExpired > 0) {            delegationBoost.batch_cancel_boosts(expiredBoosts);        }        uint newTokenId = warden.buyDelegationBoost(delegator, receiver, percent, duration, maxFeeAmount);        require(newTokenId != 0, \"Boost buy fail\");        uint256 endBalance = feeToken.balanceOf(address(this));        feeToken.safeTransfer(msg.sender, (endBalance - previousBalance));        return newTokenId;    }"