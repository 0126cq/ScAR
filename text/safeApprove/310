"function _initializeStrat(        address _vault,        address _balancerVault,        address _balancerPool,        address _gaugeFactory,        address _minter,        uint256 _maxSlippageIn,        uint256 _maxSlippageOut,        uint256 _maxSingleDeposit,        uint256 _minDepositPeriod)    internal {        healthCheck = address(0xDDCea799fF1699e98EDF118e0629A974Df7DF012);        bpt = IBalancerPool(_balancerPool);        balancerPoolId = bpt.getPoolId();        balancerVault = IBalancerVault(_balancerVault);        (IERC20[] memory tokens,,) = balancerVault.getPoolTokens(balancerPoolId);        require(tokens.length > 0, \"Empty Pool\");        numTokens = uint8(tokens.length);        assets = new IAsset[](numTokens);        tokenIndex = type(uint8).max;        for (uint8 i = 0; i < numTokens; i++) {            if (tokens[i] == want) {                tokenIndex = i;            }            assets[i] = IAsset(address(tokens[i]));        }        require(tokenIndex != type(uint8).max, \"token not supported in pool!\");        maxSlippageIn = _maxSlippageIn;        maxSlippageOut = _maxSlippageOut;        maxSingleDeposit = _maxSingleDeposit.mul(10 ** uint256(ERC20(address(want)).decimals()));        minDepositPeriod = _minDepositPeriod;        require(_gaugeFactory != address(0));        gaugeFactory = ILiquidityGaugeFactory(_gaugeFactory);        gauge = IStakingLiquidityGauge(gaugeFactory.getPoolGauge(address(bpt)));        minter = IBalancerMinter(_minter);        require(address(gauge) != address(0));        require(address(gauge.lp_token()) == address(bpt));        want.safeApprove(address(balancerVault), max);        IERC20(bpt).<mask0>;        toggles = Toggles({doSellRewards : true, doClaimRewards : true, doCollectTradingFees : true});        keepBips = 1000;        keep = governance();    }"