"function harvest() public {        require(msg.sender == strategist || msg.sender == governance, \"!authorized\");        VoterProxy(proxy).harvest(gauge);        uint256 _crv = IERC20(crv).balanceOf(address(this));        if (_crv > 0) {            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);            IERC20(crv).safeTransfer(voter, _keepCRV);            _crv = _crv.sub(_keepCRV);            IERC20(crv).safeApprove(uni, 0);            IERC20(crv).<mask0>;            address[] memory path = new address[](3);            path[0] = crv;            path[1] = weth;            path[2] = dai;            Uni(uni).swapExactTokensForTokens(_crv, uint256(0), path, address(this), now.add(1800));        }        uint256 _dai = IERC20(dai).balanceOf(address(this));        if (_dai > 0) {            IERC20(dai).safeApprove(ydai, 0);            IERC20(dai).safeApprove(ydai, _dai);            yERC20(ydai).deposit(_dai);        }        uint256 _ydai = IERC20(ydai).balanceOf(address(this));        if (_ydai > 0) {            IERC20(ydai).safeApprove(curve, 0);            IERC20(ydai).safeApprove(curve, _ydai);            ICurveFi(curve).add_liquidity([_ydai, 0, 0, 0], 0);        }        uint256 _want = IERC20(want).balanceOf(address(this));        if (_want > 0) {            uint256 _fee = _want.mul(performanceFee).div(performanceMax);            IERC20(want).safeTransfer(IController(controller).rewards(), _fee);            deposit();        }        VoterProxy(proxy).lock();    }"