"function liquidateCollateral(        IERC20  collateralAsset,        address liquidityAsset,        address superFactory,        address collateralLocker    )         external        returns (            uint256 amountLiquidated,            uint256 amountRecovered        )     {        uint256 liquidationAmt = collateralAsset.balanceOf(address(collateralLocker));        ICollateralLocker(collateralLocker).pull(address(this), liquidationAmt);        if (address(collateralAsset) == liquidityAsset || liquidationAmt == uint256(0)) return (liquidationAmt, liquidationAmt);        collateralAsset.<mask0>;        collateralAsset.safeApprove(UNISWAP_ROUTER, liquidationAmt);        IMapleGlobals globals = _globals(superFactory);        uint256 minAmount = Util.calcMinAmount(globals, address(collateralAsset), liquidityAsset, liquidationAmt);        address uniswapAssetForPath = globals.defaultUniswapPath(address(collateralAsset), liquidityAsset);        bool middleAsset = uniswapAssetForPath != liquidityAsset && uniswapAssetForPath != address(0);        address[] memory path = new address[](middleAsset ? 3 : 2);        path[0] = address(collateralAsset);        path[1] = middleAsset ? uniswapAssetForPath : liquidityAsset;        if (middleAsset) path[2] = liquidityAsset;        uint256[] memory returnAmounts = IUniswapRouter(UNISWAP_ROUTER).swapExactTokensForTokens(            liquidationAmt,            minAmount.sub(minAmount.mul(globals.maxSwapSlippage()).div(10_000)),            path,            address(this),            block.timestamp        );        return(returnAmounts[0], returnAmounts[path.length - 1]);    }"