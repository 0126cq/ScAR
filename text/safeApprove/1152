"function deposit(uint amountToDeposit, address depositToken, uint _amountOutMin, uint _deadline, uint contributionLimit, bytes calldata signature) external noContractsAllowed whenSaleOpen {        require(verify(contributionLimit, signature), \"invalid signature!\");        require(amountToDeposit > 0, \"Cannot deposit 0 Tokens!\");        require(depositToken != address(0), \"Deposit Token Cannot be 0!\");        require(depositToken != TRUSTED_REWARD_TOKEN_ADDRESS, \"Deposit token cannot be same as reward token!\");        require(trustedDepositTokens[depositToken], \"Deposit token not trusted yet!\");        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), amountToDeposit);        uint amountToStake = amountToDeposit;        if (depositToken != TRUSTED_DEPOSIT_TOKEN_ADDRESS) {            IERC20(depositToken).safeApprove(address(uniswapV2Router), 0);            IERC20(depositToken).<mask0>;            uint oldDepositTokenBalance = IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).balanceOf(address(this));            address[] memory path;            if (depositToken == uniswapV2Router.WETH() ||                 TRUSTED_DEPOSIT_TOKEN_ADDRESS == uniswapV2Router.WETH()) {                path = new address[](2);                path[0] = depositToken;                path[1] = TRUSTED_DEPOSIT_TOKEN_ADDRESS;            } else {                path = new address[](3);                path[0] = depositToken;                path[1] = uniswapV2Router.WETH();                path[2] = TRUSTED_DEPOSIT_TOKEN_ADDRESS;            }            uniswapV2Router.swapExactTokensForTokens(amountToDeposit, _amountOutMin, path, address(this), _deadline);            uint newDepositTokenBalance = IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).balanceOf(address(this));            amountToStake = newDepositTokenBalance.sub(oldDepositTokenBalance);        }        require(amountToStake > 0, \"Cannot stake 0 Tokens\");        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountToStake);        totalDepositedTokens = totalDepositedTokens.add(amountToStake);        require(totalDepositedTokens <= FUNDRAISER_GOAL_IN_DEPOSIT_TOKENS, \"CANNOT CONTRIBUTE, EXCEEDS GOAL!\");        require(depositedTokens[msg.sender] <= contributionLimit * 10**DEPOSIT_TOKEN_DECIMALS , \"Contribution Limit for tier exceeded!\");        uint contractBalance = IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).balanceOf(address(this));        IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeTransfer(owner, contractBalance);        holders.add(msg.sender);        stakingTime[msg.sender] = now;        emit Deposit(msg.sender, amountToStake);    }"