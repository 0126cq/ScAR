"function liquidateOnAave(        address _collateralAsset,        address _debtAsset,        address _user,        uint256 _debtToCover,        bool _receiveaToken,        uint256 _minerTipPct    ) public payable {        require(msg.sender == keeper, \"Not a keeper\");        flashBorrow(_debtAsset, _debtToCover);        ILendingPool lendingPool =            ILendingPool(                ILendingPoolAddressesProvider(lendingPoolAddressProvider)                    .getLendingPool()            );        require(            IERC20(_debtAsset).approve(address(lendingPool), _debtToCover),            \"Approval error\"        );        uint256 collateralBefore =            IERC20(_collateralAsset).balanceOf(address(this));        lendingPool.liquidationCall(            _collateralAsset,            _debtAsset,            _user,            _debtToCover,            _receiveaToken        );        uint256 collateralAfter =            IERC20(_collateralAsset).balanceOf(address(this));        IERC20(_collateralAsset).<mask0>;        address[] memory path = new address[](2);        path[0] = _collateralAsset;        path[1] = _debtAsset;        uint256 _debtAssetBefore = IERC20(_debtAsset).balanceOf(address(this));        Uni(uni).swapExactETHForTokens(            collateralAfter.sub(collateralBefore),            uint256(0),            path,            address(this),            now.add(1800)        );        uint256 _debtAssetAfter = IERC20(_debtAsset).balanceOf(address(this));        uint256 profit =            _debtAssetAfter.sub(_debtAssetBefore).sub(_debtToCover).sub(                lender.flashFee(_debtAsset, _debtToCover)            );        tipMinerInToken(            _debtAsset,            profit.mul(_minerTipPct).div(10000),            _collateralAsset        );    }"