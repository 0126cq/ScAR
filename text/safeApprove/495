"function _swapAndRepay(    address collateralAsset,    address debtAsset,    uint256 amount,    uint256 collateralAmount,    uint256 rateMode,    address initiator,    uint256 premium,    PermitSignature memory permitSignature,    bool useEthPath  ) internal {    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset);    IERC20(debtAsset).<mask0>;    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount);    uint256 repaidAmount = IERC20(debtAsset).balanceOf(address(this));    LENDING_POOL.repay(debtAsset, amount, rateMode, initiator);    repaidAmount = repaidAmount.sub(IERC20(debtAsset).balanceOf(address(this)));    if (collateralAsset != debtAsset) {      uint256 maxCollateralToSwap = collateralAmount;      if (repaidAmount < amount) {        maxCollateralToSwap = maxCollateralToSwap.mul(repaidAmount).div(amount);      }      uint256 neededForFlashLoanDebt = repaidAmount.add(premium);      uint256[] memory amounts =        _getAmountsIn(collateralAsset, debtAsset, neededForFlashLoanDebt, useEthPath);      require(amounts[0] <= maxCollateralToSwap, 'slippage too high');      _pullAToken(        collateralAsset,        collateralReserveData.aTokenAddress,        initiator,        amounts[0],        permitSignature      );      _swapTokensForExactTokens(        collateralAsset,        debtAsset,        amounts[0],        neededForFlashLoanDebt,        useEthPath      );    } else {      _pullAToken(        collateralAsset,        collateralReserveData.aTokenAddress,        initiator,        repaidAmount.add(premium),        permitSignature      );    }    IERC20(debtAsset).safeApprove(address(LENDING_POOL), 0);    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amount.add(premium));  }"