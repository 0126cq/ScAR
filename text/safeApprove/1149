"function vesting() external onlyOwner {        require(!isVesting, \"Already in vesting state\");        ICERC20[] memory _cTokens = new ICERC20[](1);        _cTokens[0] = cToken;        comptroller.claimComp(address(this), _cTokens);        uint256 _cTokenAll = cToken.balanceOf(address(this));        if (_cTokenAll > 0) {            uint256 error = cToken.redeem(_cTokenAll);            require(error == 0, \"Failed to redeem from Compound\");        }        if (compToken.balanceOf(address(this)) > 0) {            uint256 _amountIn = compToken.balanceOf(address(this));            compToken.<mask0>;            address[] memory _path = new address[](3);            _path[0] = address(compToken);            _path[1] = WETH;            _path[2] = address(token);            uint256[] memory _amountsOut = uniswapRouter.getAmountsOut(_amountIn, _path);            if (_amountsOut[2] > 0) {                uint256 _amountOutMin = _amountsOut[2].mul(amountOutMinPerc).div(DENOMINATOR);                uniswapRouter.swapExactTokensForTokens(                    _amountIn, _amountOutMin, _path, address(this), block.timestamp.add(deadline));            }        }        uint256 _r = token.balanceOf(address(this));        if (_r > pool) {            uint256 _p = _r.sub(pool);            uint256 _fee = _p.mul(profileSharingFeePercentage).div(DENOMINATOR);            token.safeTransfer(treasuryWallet, _fee.mul(treasuryFee).div(DENOMINATOR));            token.safeTransfer(communityWallet, _fee.mul(communityFee).div(DENOMINATOR));        }        pool = token.balanceOf(address(this));        isVesting = true;    }"