"function distribute(uint256 vaultId) external override virtual nonReentrant {    require(nftxVaultFactory != address(0));    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));    if (distributionPaused || allocTotal == 0) {      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);      return;    }     uint256 length = feeReceivers.length;    uint256 leftover;    for (uint256 i; i < length; ++i) {      FeeReceiver memory _feeReceiver = feeReceivers[i];      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);      if (!complete) {        uint256 remaining = IERC20Upgradeable(_vault).allowance(address(this), _feeReceiver.receiver);        IERC20Upgradeable(_vault).<mask0>;        leftover = remaining;      } else {        leftover = 0;      }    }    if (leftover != 0) {      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);    }  }"