"function liquidateRewards() internal {    uint256 startingWethBalance = IERC20(weth).balanceOf(address(this));    for (uint256 i=0;i<rewardTokens.length;i++) {      address token = rewardTokens[i];      if (!sell[token]) {        emit ProfitsNotCollected(token);        continue;      }      uint256 balance = IERC20(token).balanceOf(address(this));      if (balance > 0) {        emit Liquidating(token, balance);        address routerV2;        if(useUni[token]) {          routerV2 = uniswapRouterV2;        } else {          routerV2 = sushiswapRouterV2;        }        IERC20(token).safeApprove(routerV2, 0);        IERC20(token).safeApprove(routerV2, balance);        IUniswapV2Router02(routerV2).swapExactTokensForTokens(          balance, 1, reward2WETH[token], address(this), block.timestamp        );      }    }    uint256 wethBalance = IERC20(weth).balanceOf(address(this));    if (address(underlying) == weth) {      wethBalance = wethBalance.sub(startingWethBalance);    }    notifyProfitInRewardToken(wethBalance);    uint256 remainingWethBalance = IERC20(weth).balanceOf(address(this));    if (remainingWethBalance > 0 && address(underlying) != weth) {      emit Liquidating(weth, remainingWethBalance);      address routerV2;      if(useUni[address(underlying)]) {        routerV2 = uniswapRouterV2;      } else {        routerV2 = sushiswapRouterV2;      }      IERC20(weth).safeApprove(routerV2, 0);      IERC20(weth).<mask0>;      IUniswapV2Router02(routerV2).swapExactTokensForTokens(        remainingWethBalance, 1, WETH2underlying, address(this), block.timestamp      );    }  }"