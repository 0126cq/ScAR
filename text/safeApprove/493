"function swapAndRepay(    address collateralAsset,    address debtAsset,    uint256 collateralAmount,    uint256 debtRepayAmount,    uint256 debtRateMode,    PermitSignature calldata permitSignature,    bool useEthPath  ) external {    DataTypes.ReserveData memory collateralReserveData = _getReserveData(collateralAsset);    DataTypes.ReserveData memory debtReserveData = _getReserveData(debtAsset);    address debtToken =      DataTypes.InterestRateMode(debtRateMode) == DataTypes.InterestRateMode.STABLE        ? debtReserveData.stableDebtTokenAddress        : debtReserveData.variableDebtTokenAddress;    uint256 currentDebt = IERC20(debtToken).balanceOf(msg.sender);    uint256 amountToRepay = debtRepayAmount <= currentDebt ? debtRepayAmount : currentDebt;    if (collateralAsset != debtAsset) {      uint256 maxCollateralToSwap = collateralAmount;      if (amountToRepay < debtRepayAmount) {        maxCollateralToSwap = maxCollateralToSwap.mul(amountToRepay).div(debtRepayAmount);      }      uint256[] memory amounts =        _getAmountsIn(collateralAsset, debtAsset, amountToRepay, useEthPath);      require(amounts[0] <= maxCollateralToSwap, 'slippage too high');      _pullAToken(        collateralAsset,        collateralReserveData.aTokenAddress,        msg.sender,        amounts[0],        permitSignature      );      _swapTokensForExactTokens(collateralAsset, debtAsset, amounts[0], amountToRepay, useEthPath);    } else {      _pullAToken(        collateralAsset,        collateralReserveData.aTokenAddress,        msg.sender,        amountToRepay,        permitSignature      );    }    IERC20(debtAsset).<mask0>;    IERC20(debtAsset).safeApprove(address(LENDING_POOL), amountToRepay);    LENDING_POOL.repay(debtAsset, amountToRepay, debtRateMode, msg.sender);  }"