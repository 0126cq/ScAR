"function prepareReturn(uint256 _debtOutstanding)        internal        override        returns (            uint256 _profit,            uint256 _loss,            uint256 _debtPayment        )    {        uint before = want.balanceOf(address(this));        IVoterProxy(proxy).harvest(gauge);        uint256 _crv = IERC20(crv).balanceOf(address(this));        if (_crv > 0) {            _crv = _adjustCRV(_crv);            IERC20(crv).safeApprove(dex, 0);            IERC20(crv).safeApprove(dex, _crv);            address[] memory path = new address[](3);            path[0] = crv;            path[1] = weth;            path[2] = wbtc;            Uni(dex).swapExactTokensForTokens(_crv, uint256(0), path, address(this), now);        }        IVoterProxy(proxy).claimRewards(gauge, pnt);        uint256 _pnt = IERC20(pnt).balanceOf(address(this));        if (_pnt > 0) {            IERC20(pnt).safeApprove(uniswap, 0);            IERC20(pnt).safeApprove(uniswap, _pnt);            address[] memory path = new address[](3);            path[0] = pnt;            path[1] = weth;            path[2] = wbtc;            Uni(uniswap).swapExactTokensForTokens(_pnt, uint256(0), path, address(this), now);        }        uint256 _wbtc = IERC20(wbtc).balanceOf(address(this));        if (_wbtc > 0) {            IERC20(wbtc).safeApprove(curve, 0);            IERC20(wbtc).<mask0>;            ICurveFi(curve).add_liquidity([0, 0, _wbtc, 0], 0);        }        _profit = want.balanceOf(address(this)).sub(before);        uint _total = estimatedTotalAssets();        uint _debt = vault.strategies(address(this)).totalDebt;        if(_total < _debt) _loss = _debt - _total;        uint _losss;        if (_debtOutstanding > 0) {            (_debtPayment, _losss) = liquidatePosition(_debtOutstanding);        }        _loss = _loss.add(_losss);    }"