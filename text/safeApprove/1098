"function liquidateBorrow(        address borrower,        address bTokenCollateral,        address bTokenDebt,        uint underlyingAmtToLiquidate    )        public onlyMember    {        address cTokenCollateral = bComptroller.b2c(bTokenCollateral);        address cTokenDebt = bComptroller.b2c(bTokenDebt);        address avatar = registry.avatarOf(borrower);        TopupInfo storage info = topped[avatar];        require(info.memberInfo[msg.sender].amountTopped > 0, \"Pool: member-didnt-topup\");        uint debtToLiquidatePerMember = info.debtToLiquidatePerMember;        if(debtToLiquidatePerMember == 0) {            uint numMembers = 0;            for(uint i = 0 ; i < members.length ; i++) {                if(info.memberInfo[members[i]].amountTopped > 0) {                    numMembers++;                }            }            debtToLiquidatePerMember = ICushion(avatar).getMaxLiquidationAmount(cTokenDebt) / numMembers;            info.debtToLiquidatePerMember = debtToLiquidatePerMember;        }        MemberTopupInfo memory memberInfo = info.memberInfo[msg.sender];        require(memberInfo.amountTopped > 0, \"Pool: member-didnt-topup\");        require(            add_(memberInfo.amountLiquidated, underlyingAmtToLiquidate) <= debtToLiquidatePerMember,            \"Pool: amount-too-big\"        );        uint amtToDeductFromTopup = mul_(underlyingAmtToLiquidate, memberInfo.amountTopped) / (            sub_(debtToLiquidatePerMember, memberInfo.amountLiquidated)        );        uint amtToRepayOnCompound = sub_(underlyingAmtToLiquidate, amtToDeductFromTopup);        address debtUnderlying = _getUnderlying(cTokenDebt);        require(balance[msg.sender][debtUnderlying] >= amtToRepayOnCompound, \"Pool: low-member-balance\");        if(! _isCEther(cTokenDebt)) {            IERC20(debtUnderlying).<mask0>;        }        require(            ICushion(avatar).liquidateBorrow.value(debtUnderlying == ETH_ADDR ?                                                   amtToRepayOnCompound :                                                   0)(underlyingAmtToLiquidate, amtToDeductFromTopup, cTokenCollateral) == 0,            \"Pool: liquidateBorrow-failed\"        );        balance[msg.sender][debtUnderlying] = sub_(balance[msg.sender][debtUnderlying],  amtToRepayOnCompound);        _shareLiquidationProceeds(cTokenCollateral, msg.sender);        info.memberInfo[msg.sender].amountLiquidated = add_(memberInfo.amountLiquidated, underlyingAmtToLiquidate);        info.memberInfo[msg.sender].amountTopped = sub_(memberInfo.amountTopped, amtToDeductFromTopup);        topupBalance[msg.sender][debtUnderlying] = sub_(topupBalance[msg.sender][debtUnderlying], amtToDeductFromTopup);        if(IAvatar(avatar).toppedUpAmount() == 0) {            delete topped[avatar];         }        emit MemberBite(msg.sender, avatar, cTokenDebt, cTokenCollateral, underlyingAmtToLiquidate);    }"