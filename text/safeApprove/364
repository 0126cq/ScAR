"function liquidate(        uint256 _pid,        int128 _coinId,        address _user,        uint256 _amount    )        external        override        onlyLendingMarket        nonReentrant        returns (address, uint256)    {        PoolInfo storage pool = poolInfo[_pid];        IOriginConvexRewardPool(pool.originCrvRewards).withdrawAndUnwrap(            _amount,            true        );        IVirtualBalanceWrapper(pool.virtualBalance).withdrawFor(_user, _amount);        if (IConvexRewardPool(pool.rewardCrvPool).earned(_user) > 0) {            IConvexRewardPool(pool.rewardCrvPool).getReward(_user);        }        if (IConvexRewardPool(pool.rewardCvxPool).earned(_user) > 0) {            IConvexRewardPool(pool.rewardCvxPool).getReward(_user);        }        IConvexRewardPool(pool.rewardCrvPool).withdraw(_user);        IConvexRewardPool(pool.rewardCvxPool).withdraw(_user);        IERC20(pool.lpToken).safeApprove(pool.curveSwapAddress, 0);        IERC20(pool.lpToken).<mask0>;        address underlyToken = ICurveSwap(pool.curveSwapAddress).coins(            uint256(_coinId)        );        ICurveSwap(pool.curveSwapAddress).remove_liquidity_one_coin(            _amount,            _coinId,            0        );        if (underlyToken == ZERO_ADDRESS) {            uint256 totalAmount = address(this).balance;            msg.sender.sendValue(totalAmount);            return (ZERO_ADDRESS, totalAmount);        } else {            uint256 totalAmount = IERC20(underlyToken).balanceOf(address(this));            IERC20(underlyToken).safeTransfer(msg.sender, totalAmount);            return (underlyToken, totalAmount);        }    }"