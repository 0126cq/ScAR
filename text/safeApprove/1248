"function zap(        address _curve,        uint256 _zapAmount,        uint256 _deadline,        uint256 _minLPAmount,        bool isFromBase    ) public returns (uint256) {        (address base, uint256 swapAmount) = calcSwapAmountForZap(_curve, _zapAmount, isFromBase);        if (isFromBase) {            IERC20(base).safeTransferFrom(msg.sender, address(this), _zapAmount);            IERC20(base).safeApprove(_curve, 0);            IERC20(base).<mask0>;            Curve(_curve).originSwap(base, address(USDC), swapAmount, 0, _deadline);        } else {            USDC.safeTransferFrom(msg.sender, address(this), _zapAmount);            USDC.safeApprove(_curve, 0);            USDC.safeApprove(_curve, swapAmount);            Curve(_curve).originSwap(address(USDC), base, swapAmount, 0, _deadline);        }        (uint256 depositAmount, uint256 baseAmount, uint256 quoteAmount) = _calcDepositAmount(_curve, base);        IERC20(base).safeApprove(_curve, 0);        IERC20(base).safeApprove(_curve, baseAmount);        USDC.safeApprove(_curve, 0);        USDC.safeApprove(_curve, quoteAmount);        (uint256 lpAmount, ) = Curve(_curve).deposit(depositAmount, _deadline);        require(lpAmount >= _minLPAmount, \"!Zap/not-enough-lp-amount\");        IERC20(_curve).transfer(msg.sender, IERC20(_curve).balanceOf(address(this)));        IERC20(base).transfer(msg.sender, IERC20(base).balanceOf(address(this)));        USDC.transfer(msg.sender, USDC.balanceOf(address(this)));        return lpAmount;    }"