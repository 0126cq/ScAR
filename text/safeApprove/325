"function _swapTokensForExactTokens(    address assetToSwapFrom,    address assetToSwapTo,    uint256 maxAmountToSwap,    uint256 amountToReceive,    bool useEthPath  ) internal returns (uint256) {    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);    uint256 fromAssetPrice = _getPrice(assetToSwapFrom);    uint256 toAssetPrice = _getPrice(assetToSwapTo);    uint256 expectedMaxAmountToSwap =      amountToReceive        .mul(toAssetPrice.mul(10**fromAssetDecimals))        .div(fromAssetPrice.mul(10**toAssetDecimals))        .percentMul(PercentageMath.PERCENTAGE_FACTOR.add(MAX_SLIPPAGE_PERCENT));    require(maxAmountToSwap < expectedMaxAmountToSwap, 'maxAmountToSwap exceed max slippage');    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);    IERC20(assetToSwapFrom).<mask0>;    address[] memory path;    if (useEthPath) {      path = new address[](3);      path[0] = assetToSwapFrom;      path[1] = WETH_ADDRESS;      path[2] = assetToSwapTo;    } else {      path = new address[](2);      path[0] = assetToSwapFrom;      path[1] = assetToSwapTo;    }    uint256[] memory amounts =      UNISWAP_ROUTER.swapTokensForExactTokens(        amountToReceive,        maxAmountToSwap,        path,        address(this),        block.timestamp      );    emit Swapped(assetToSwapFrom, assetToSwapTo, amounts[0], amounts[amounts.length - 1]);    return amounts[0];  }"