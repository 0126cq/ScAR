"function swap(        address from_vault,        address to_vault,        uint256 amount,        uint256 min_amount_out,        Swap[] calldata instructions,        uint256 donation,        uint256 origin    ) public {        address token = Vault(from_vault).token();        address target = Vault(to_vault).token();        Vault(from_vault).transferFrom(msg.sender, address(this), amount);        amount = Vault(from_vault).withdraw(amount, address(this));        uint256 n_coins;        for (uint256 i = 0; i < instructions.length; i++) {            if (instructions[i].deposit) {                n_coins = registry.get_n_coins(instructions[i].pool)[0];                uint256[] memory list = new uint256[](n_coins);                list[instructions[i].n] = amount;                approve(token, instructions[i].pool, amount);                if (n_coins == 2) {                    StableSwap(instructions[i].pool).add_liquidity(                        [list[0], list[1]],                        1                    );                } else if (n_coins == 3) {                    StableSwap(instructions[i].pool).add_liquidity(                        [list[0], list[1], list[2]],                        1                    );                } else if (n_coins == 4) {                    StableSwap(instructions[i].pool).add_liquidity(                        [list[0], list[1], list[2], list[3]],                        1                    );                }                token = registry.get_lp_token(instructions[i].pool);                amount = IERC20(token).balanceOf(address(this));            } else {                token = registry.get_coins(instructions[i].pool)[                    instructions[i].n                ];                amount = remove_liquidity_one_coin(                    token,                    instructions[i].pool,                    amount,                    instructions[i].n                );            }        }        <mask0>;        if(donation != 0) {            uint256 donating = (amount * donation) / MAX_DONATION;            SafeERC20.safeTransfer(IERC20(target), owner, donating);            amount -= donating;        }        approve(target, to_vault, amount);        uint256 out  = Vault(to_vault).deposit(amount, msg.sender);        require(out >= min_amount_out, \"out too low\");        if (origin != UNKNOWN_ORIGIN){            emit Orgin(origin);        }    }"