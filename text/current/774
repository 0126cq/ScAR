"function _purchase(        address to,        uint256 requested,        uint256 costMetadata    ) internal nonReentrant whenNotPaused {        SellerConfig memory config = sellerConfig;        uint256 n = config.maxPerTx == 0            ? requested            : Math.min(requested, config.maxPerTx);        uint256 maxAvailable;        uint256 sold;        if (config.reserveFreeQuota) {            maxAvailable = config.totalInventory - config.freeQuota;            sold = _totalSold.current() - purchasedFreeOfCharge.<mask0>;        } else {            maxAvailable = config.totalInventory;            sold = _totalSold.current();        }        n = Math.min(n, maxAvailable - sold);        require(n > 0, \"Seller: Sold out\");        if (config.maxPerAddress > 0) {            bool alsoLimitSender = _msgSender() != to;            bool alsoLimitOrigin = tx.origin != _msgSender() && tx.origin != to;            n = _capExtra(n, to, \"Buyer limit\");            if (alsoLimitSender) {                n = _capExtra(n, _msgSender(), \"Sender limit\");            }            if (alsoLimitOrigin) {                n = _capExtra(n, tx.origin, \"Origin limit\");            }            _bought[to] += n;            if (alsoLimitSender) {                _bought[_msgSender()] += n;            }            if (alsoLimitOrigin) {                _bought[tx.origin] += n;            }        }        uint256 _cost = cost(n, costMetadata);        if (msg.value < _cost) {            revert(                string(                    abi.encodePacked(                        \"Seller: Costs \",                        (_cost / 1e9).toString(),                        \" GWei\"                    )                )            );        }        _totalSold.add(n);        assert(_totalSold.current() <= config.totalInventory);        _handlePurchase(to, n, false);        if (_cost > 0) {            beneficiary.sendValue(_cost);            emit Revenue(beneficiary, n, _cost);        }        if (msg.value > _cost) {            address payable reimburse = payable(_msgSender());            uint256 refund = msg.value - _cost;            (bool success, bytes memory returnData) = reimburse.call{                value: refund            }(\"\");            require(success, string(returnData));            emit Refund(reimburse, refund);        }    }"