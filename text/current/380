"function purchase(uint256 numberOfTokens) external payable {        require(_publicGOAT.current() < GOAT_MAX,\"Purchase would exceed GOAT_MAX\");        if (msg.sender != owner()) {            require(numberOfTokens <= PURCHASE_LIMIT,\"Can only mint up to purchase limit\");            require(PRICE() * numberOfTokens <= msg.value,\"ETH amount is not sufficient\");            if (block.timestamp < _activeDateTime) {                if (_enableOnChainWhiteList == true) {                    require(_mappingWhiteList[msg.sender] == true, \"Not registered to WhiteList\");                   }                _mappingPresaleMintCount[msg.sender] = _mappingPresaleMintCount[msg.sender] + numberOfTokens;                require(block.timestamp > _activeDateTime - PRESALE_HOURS , \"Mint is not activated for presale\");                require(_mappingPresaleMintCount[msg.sender] <= PRESALE_MINT_LIMIT,\"Overflow for PRESALE_MINT_LIMIT\");            } else {                _mappingPublicMintCount[msg.sender] = _mappingPublicMintCount[msg.sender] + numberOfTokens;                require(_mappingPublicMintCount[msg.sender] <= PUBLIC_MINT_LIMIT,\"Overflow for PUBLIC_MINT_LIMIT\");            }            if (FEE_PERCENT > 0) {                uint256 feeAmount = (msg.value * FEE_PERCENT) / 100;                _PaymentAddress.transfer(msg.value - feeAmount);            } else {                _PaymentAddress.transfer(msg.value);            }        }        for (uint256 i = 0; i < numberOfTokens; i++) {            uint256 tokenId = _publicGOAT.<mask0>;            if (_publicGOAT.current() < GOAT_MAX) {                _publicGOAT.increment();                if (!_exists(tokenId)) _safeMint(msg.sender, tokenId);            }        }    }"