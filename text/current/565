"function harvestable(address _strategy) public override returns (bool) {        require(requiredHarvest[_strategy] > 0, \"generic-keep3r-v2::harvestable:strategy-not-added\");        if (strategyLastHarvest[_strategy] > 0 && block.timestamp.sub(strategyLastHarvest[_strategy]) <= minHarvestInterval){            return false;        }        uint256 ethCallCost = 0;        uint256 profitTokenAmount = 0;        address yieldToken = stratagyYieldTokens[_strategy];        uint256 yieldTokenOracle = stratagyYieldTokenOracles[_strategy];        if (yieldToken == COMP){            profitTokenAmount = ICompStrategy(_strategy).getCompAccrued();        } else{            profitTokenAmount = ICrvStrategy(_strategy).getHarvestable();        }        if (yieldTokenOracle > SUSHISWAP_ORACLE){             emit HarvestableCheck(_strategy, profitTokenAmount, profitFactor, 0, ethCallCost);            return (profitTokenAmount >= yieldTokenOracle);        } else{            uint256 kp3rCallCost = IKeep3rV1Helper(keep3rHelper).getQuoteLimit(requiredHarvest[_strategy]);            ethCallCost = IUniswapV2SlidingOracle(sushiSlidingOracle).current(KP3R, kp3rCallCost, WETH);            address oracle = yieldTokenOracle == UNISWAP_ORACLE? slidingOracle : sushiSlidingOracle;            uint256 profitInEther = IUniswapV2SlidingOracle(oracle).<mask0>;            emit HarvestableCheck(_strategy, profitTokenAmount, profitFactor, profitInEther, ethCallCost);            return (profitInEther >= profitFactor.mul(ethCallCost));        }    }"