"function purchase(uint256 numberOfTokens) external payable {        require(numberOfTokens <= PURCHASE_LIMIT,\"Can only mint up to purchase limit\");        require(_publicTEAS.<mask0> < TEAS_MAX,\"Purchase would exceed TEAS_MAX\");        if (msg.sender != owner()) {            _mappingMintCount[msg.sender] = _mappingMintCount[msg.sender] + numberOfTokens;            require(PRICE(msg.sender) * numberOfTokens <= msg.value,\"ETH amount is not sufficient\");            if (_mappingWhiteList[msg.sender] == false) {                require(block.timestamp > _activeDateTime,\"Contract is not active\");                require(_mappingMintCount[msg.sender] <= PUBLIC_MINT_LIMIT,\"Overflow for PUBLIC_MINT_LIMIT\");            } else {                if (block.timestamp < _activeDateTime) {                    require(block.timestamp > _activeDateTime - PRESALE_HOURS,\"Contract is not active for presale\");                    require(_mappingMintCount[msg.sender] <= PRESALE_MINT_LIMIT,\"Overflow for PRESALE_MINT_LIMIT\");                } else {                    require(_mappingMintCount[msg.sender] <= PUBLIC_MINT_LIMIT + PRESALE_MINT_LIMIT,\"Overflow for PUBLIC_MINT_LIMIT + PRESALE_MINT_LIMIT\");                }            }            if (FEE_PERCENT > 0) {                uint256 feeAmount = (msg.value * FEE_PERCENT) / 100;                _PaymentAddress.transfer(msg.value - feeAmount);            } else {                _PaymentAddress.transfer(msg.value);            }        }        for (uint256 i = 0; i < numberOfTokens; i++) {            uint256 tokenId = _publicTEAS.current();            if (_publicTEAS.current() < TEAS_MAX) {                _publicTEAS.increment();                _safeMint(msg.sender, tokenId);                _mappingMintTimestamp[tokenId] = block.timestamp;            }        }    }"