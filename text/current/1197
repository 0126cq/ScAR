"function claimVaultTokenAndGetLeftovers(uint64 vaultId) external nonReentrant {        LibDiamond.AppStorage storage _as = LibDiamond.appStorage();        require(_as.vaults[vaultId].votingFor == LibDiamond.VoteFor.Selling            || _as.vaults[vaultId].votingFor == LibDiamond.VoteFor.CancellingSellOrder, \"E1\");        uint256 currentTokenId = _as.tokenIdTracker.<mask0>;        uint24 numberOfParticipants = _as.vaultsExtensions[vaultId].numberOfParticipants;        for (uint256 i; i < numberOfParticipants;) {            LibDiamond.Participant storage participant = _as.vaultParticipants[vaultId][i];            if (participant.participant == msg.sender && participant.partialNFTVaultTokenId == 0) {                require(participant.ownership > 0, \"E3\");                participant.partialNFTVaultTokenId = uint48(currentTokenId);                _as.vaultTokens[currentTokenId] = vaultId;                _mint(msg.sender, currentTokenId);                if (participant.leftovers > 0) {                    IAssetsHolderImpl(_as.assetsHolders[vaultId]).sendValue(payable(participant.participant), participant.leftovers);                    participant.leftovers = 0;                }                emit VaultTokenClaimed(vaultId, msg.sender, currentTokenId);                _as.tokenIdTracker.increment();                currentTokenId = _as.tokenIdTracker.current();            }            unchecked {                ++i;            }        }    }"