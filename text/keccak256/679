"function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;        bytes memory keyhash = new bytes(32);        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);        if (!(<mask0> == keccak256(sha256(context_name, queryId)))) return false;        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;        bytes memory commitmentSlice1 = new bytes(8+1+32);        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);        bytes memory sessionPubkey = new bytes(64);        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);        bytes32 sessionPubkeyHash = sha256(sessionPubkey);        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){             delete oraclize_randomDS_args[queryId];        } else return false;        bytes memory tosign1 = new bytes(32+8+1+32);        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);        }        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];    }"