"function _trade(        TradeTokens memory tokens,        TradeParams memory params,        TraderInfo memory traderInfo,        uint256 deadline    ) private returns (uint256) {        if (traderInfo.beneficiary == address(0)) {            traderInfo.beneficiary = traderInfo.trader;        }        bytes32 contextId = <mask0>;        TradeResult memory firstHopTradeResult;        TradeResult memory lastHopTradeResult;        uint256 networkFeeAmount;        if (tokens.sourceToken.isEqual(_bnt)) {            lastHopTradeResult = _tradeBNT(contextId, tokens.targetToken, true, params);            firstHopTradeResult = lastHopTradeResult;            networkFeeAmount = lastHopTradeResult.networkFeeAmount;            emit TokensTraded({                contextId: contextId,                sourceToken: tokens.sourceToken,                targetToken: tokens.targetToken,                sourceAmount: lastHopTradeResult.sourceAmount,                targetAmount: lastHopTradeResult.targetAmount,                bntAmount: lastHopTradeResult.sourceAmount,                targetFeeAmount: lastHopTradeResult.tradingFeeAmount,                bntFeeAmount: 0,                trader: traderInfo.trader            });        } else if (tokens.targetToken.isEqual(_bnt)) {            lastHopTradeResult = _tradeBNT(contextId, tokens.sourceToken, false, params);            firstHopTradeResult = lastHopTradeResult;            networkFeeAmount = lastHopTradeResult.networkFeeAmount;            emit TokensTraded({                contextId: contextId,                sourceToken: tokens.sourceToken,                targetToken: tokens.targetToken,                sourceAmount: lastHopTradeResult.sourceAmount,                targetAmount: lastHopTradeResult.targetAmount,                bntAmount: lastHopTradeResult.targetAmount,                targetFeeAmount: lastHopTradeResult.tradingFeeAmount,                bntFeeAmount: lastHopTradeResult.tradingFeeAmount,                trader: traderInfo.trader            });        } else {            (firstHopTradeResult, lastHopTradeResult) = _tradeBaseTokens(contextId, tokens, params);            networkFeeAmount = firstHopTradeResult.networkFeeAmount + lastHopTradeResult.networkFeeAmount;            emit TokensTraded({                contextId: contextId,                sourceToken: tokens.sourceToken,                targetToken: tokens.targetToken,                sourceAmount: firstHopTradeResult.sourceAmount,                targetAmount: lastHopTradeResult.targetAmount,                bntAmount: firstHopTradeResult.targetAmount,                targetFeeAmount: lastHopTradeResult.tradingFeeAmount,                bntFeeAmount: firstHopTradeResult.tradingFeeAmount,                trader: traderInfo.trader            });        }        _depositToMasterVault(tokens.sourceToken, traderInfo.trader, firstHopTradeResult.sourceAmount);        _masterVault.withdrawFunds(            tokens.targetToken,            payable(traderInfo.beneficiary),            lastHopTradeResult.targetAmount        );        _pendingNetworkFeeAmount += networkFeeAmount;        return params.bySourceAmount ? lastHopTradeResult.targetAmount : lastHopTradeResult.sourceAmount;    }"