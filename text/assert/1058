"function exitMarket(address cTokenAddress) external returns (uint256) {        CToken cToken = CToken(cTokenAddress);        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\");         if (amountOwed != 0) {            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);        }        uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);        if (allowed != 0) {            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);        }        Market storage marketToExit = markets[cTokenAddress];        if (marketToExit.version == Version.COLLATERALCAP) {            CCollateralCapErc20Interface(cTokenAddress).unregisterCollateral(msg.sender);        }        if (!marketToExit.accountMembership[msg.sender]) {            return uint256(Error.NO_ERROR);        }        delete marketToExit.accountMembership[msg.sender];        CToken[] memory userAssetList = accountAssets[msg.sender];        uint256 len = userAssetList.length;        uint256 assetIndex = len;        for (uint256 i = 0; i < len; i++) {            if (userAssetList[i] == cToken) {                assetIndex = i;                break;            }        }        <mask0>;        CToken[] storage storedList = accountAssets[msg.sender];        if (assetIndex != storedList.length - 1) {            storedList[assetIndex] = storedList[storedList.length - 1];        }        storedList.length--;        emit MarketExited(cToken, msg.sender);        return uint256(Error.NO_ERROR);    }"