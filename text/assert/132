"function borrowAllowed(address cToken, address borrower, uint borrowAmount) external override returns (uint) {        require(!borrowGuardianPaused[cToken], \"borrow is paused\");        if (!markets[cToken].isListed) {            return uint(Error.MARKET_NOT_LISTED);        }        if (!markets[cToken].accountMembership[borrower]) {            require(msg.sender == cToken, \"sender must be cToken\");            Error err = addToMarketInternal(CToken(msg.sender), borrower);            if (err != Error.NO_ERROR) {                return uint(err);            }            <mask0>;        }        if (oracle.getUnderlyingPrice(cToken) == 0) {            return uint(Error.PRICE_ERROR);        }        uint borrowCap = borrowCaps[cToken];        if (borrowCap != 0) {            uint totalBorrows = CToken(cToken).totalBorrows();            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");        }        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);        if (err != Error.NO_ERROR) {            return uint(err);        }        if (shortfall > 0) {            return uint(Error.INSUFFICIENT_LIQUIDITY);        }        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});        updateCompBorrowIndex(cToken, borrowIndex);        distributeBorrowerComp(cToken, borrower, borrowIndex);        return uint(Error.NO_ERROR);    }"