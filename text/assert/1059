"function borrowAllowed(        address cToken,        address borrower,        uint256 borrowAmount    ) external returns (uint256) {        require(!borrowGuardianPaused[cToken], \"borrow is paused\");        if (!isMarketListed(cToken)) {            return uint256(Error.MARKET_NOT_LISTED);        }        if (!markets[cToken].accountMembership[borrower]) {            require(msg.sender == cToken, \"sender must be cToken\");            Error err = addToMarketInternal(CToken(msg.sender), borrower);            if (err != Error.NO_ERROR) {                return uint256(err);            }            <mask0>;        }        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {            return uint256(Error.PRICE_ERROR);        }        uint256 borrowCap = borrowCaps[cToken];        if (borrowCap != 0) {            uint256 totalBorrows = CToken(cToken).totalBorrows();            uint256 nextTotalBorrows = add_(totalBorrows, borrowAmount);            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");        }        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(            borrower,            CToken(cToken),            0,            borrowAmount        );        if (err != Error.NO_ERROR) {            return uint256(err);        }        if (shortfall > 0) {            return uint256(Error.INSUFFICIENT_LIQUIDITY);        }        return uint256(Error.NO_ERROR);    }"