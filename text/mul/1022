"function accrue() public {        AccrueInfo memory _accrueInfo = accrueInfo;        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;        if (elapsedTime == 0) {            return;        }        _accrueInfo.lastAccrued = uint64(block.timestamp);        Rebase memory _totalBorrow = totalBorrow;        if (_totalBorrow.base == 0) {            if (_accrueInfo.interestPerSecond != STARTING_INTEREST_PER_SECOND) {                _accrueInfo.interestPerSecond = STARTING_INTEREST_PER_SECOND;                emit LogAccrue(0, 0, STARTING_INTEREST_PER_SECOND, 0);            }            accrueInfo = _accrueInfo;            return;        }        uint256 extraAmount = 0;        uint256 feeFraction = 0;        Rebase memory _totalAsset = totalAsset;        extraAmount = uint256(_totalBorrow.elastic).mul(_accrueInfo.interestPerSecond).mul(elapsedTime) / 1e18;        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount.to128());        uint256 fullAssetAmount = bentoBox.toAmount(asset, _totalAsset.elastic, false).add(_totalBorrow.elastic);        uint256 feeAmount = extraAmount.mul(PROTOCOL_FEE) / PROTOCOL_FEE_DIVISOR;         feeFraction = feeAmount.mul(_totalAsset.base) / fullAssetAmount;        _accrueInfo.feesEarnedFraction = _accrueInfo.feesEarnedFraction.add(feeFraction.to128());        totalAsset.base = _totalAsset.base.add(feeFraction.to128());        totalBorrow = _totalBorrow;        uint256 utilization = uint256(_totalBorrow.elastic).mul(UTILIZATION_PRECISION) / fullAssetAmount;        if (utilization < MINIMUM_TARGET_UTILIZATION) {            uint256 underFactor = MINIMUM_TARGET_UTILIZATION.sub(utilization).mul(FACTOR_PRECISION) / MINIMUM_TARGET_UTILIZATION;            uint256 scale = INTEREST_ELASTICITY.add(underFactor.mul(underFactor).mul(elapsedTime));            _accrueInfo.interestPerSecond = uint64(uint256(_accrueInfo.interestPerSecond).mul(INTEREST_ELASTICITY) / scale);            if (_accrueInfo.interestPerSecond < MINIMUM_INTEREST_PER_SECOND) {                _accrueInfo.interestPerSecond = MINIMUM_INTEREST_PER_SECOND;             }        } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {            uint256 overFactor = utilization.sub(MAXIMUM_TARGET_UTILIZATION).<mask0> / FULL_UTILIZATION_MINUS_MAX;            uint256 scale = INTEREST_ELASTICITY.add(overFactor.mul(overFactor).mul(elapsedTime));            uint256 newInterestPerSecond = uint256(_accrueInfo.interestPerSecond).mul(scale) / INTEREST_ELASTICITY;            if (newInterestPerSecond > MAXIMUM_INTEREST_PER_SECOND) {                newInterestPerSecond = MAXIMUM_INTEREST_PER_SECOND;             }            _accrueInfo.interestPerSecond = uint64(newInterestPerSecond);        }        emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);        accrueInfo = _accrueInfo;    }"