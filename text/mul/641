"function _distributeFunds(    address nftContract,    uint256 tokenId,    address payable seller,    uint256 price  )    internal    returns (      uint256 foundationFee,      uint256 creatorFee,      uint256 ownerRev    )  {    address payable[] memory creatorRecipients;    uint256[] memory creatorShares;    address payable ownerRevTo;    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(      nftContract,      tokenId,      seller,      price    );    nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;    _sendValueWithFallbackWithdrawWithLowGasLimit(getFoundationTreasury(), foundationFee);    if (creatorFee > 0) {      if (creatorRecipients.length > 1) {        uint256 maxCreatorIndex = creatorRecipients.length - 1;        if (maxCreatorIndex > MAX_CREATOR_INDEX) {          maxCreatorIndex = MAX_CREATOR_INDEX;        }        uint256 totalShares;        for (uint256 i = 0; i <= maxCreatorIndex; i++) {          if (creatorShares[i] > BASIS_POINTS) {            maxCreatorIndex = 0;            break;          }          totalShares = totalShares.add(creatorShares[i]);        }        if (totalShares == 0) {          maxCreatorIndex = 0;        }        uint256 totalDistributed;        for (uint256 i = 1; i <= maxCreatorIndex; i++) {          uint256 share = (creatorFee.<mask0>) / totalShares;          totalDistributed = totalDistributed.add(share);          _sendValueWithFallbackWithdrawWithMediumGasLimit(creatorRecipients[i], share);        }        _sendValueWithFallbackWithdrawWithMediumGasLimit(creatorRecipients[0], creatorFee.sub(totalDistributed));      } else {        _sendValueWithFallbackWithdrawWithMediumGasLimit(creatorRecipients[0], creatorFee);      }    }    _sendValueWithFallbackWithdrawWithMediumGasLimit(ownerRevTo, ownerRev);  }"