"function stakeTokens(uint256 _amount) external nonReentrant {        require(            getLastStakableBlock() > block.number,            \"this farm is expired and no more stakers can be added\"        );        require(pool.origTotSupply != 0, \"Farm not ready\");        _updatePool();        if (balanceOf(msg.sender) > 0) {            _harvestTokens(msg.sender, balanceOf(msg.sender));        }        uint256 _finalAmountTransferred;        uint256 _contractBalanceBefore = _stakedERC20.balanceOf(address(this));        if (_amount > 0) {            _stakedERC20.transferFrom(msg.sender, address(this), _amount);        }        _finalAmountTransferred = _stakedERC20.balanceOf(address(this)).sub(            _contractBalanceBefore        );        uint256 stakeTax = stakeFee.mul(_finalAmountTransferred).div(100);        if (stakeTax > 0) {            _stakedERC20.transfer(address(rewardVault), stakeTax.div(2));            _stakedERC20.transfer(teamAddress, stakeTax.sub(stakeTax.div(2)));            _finalAmountTransferred = _finalAmountTransferred.sub(stakeTax);        }        if (<mask0> == 0) {            pool.creationBlock = block.number;             pool.lastRewardBlock = block.number;        }        if (_finalAmountTransferred > 0) {            _mint(msg.sender, _finalAmountTransferred);        }        StakerInfo storage _staker = stakers[msg.sender];        _staker.blockOriginallyStaked = block.number;        _staker.timeOriginallyStaked = block.timestamp;        _staker.blockLastHarvested = block.number;        _staker.rewardDebt = balanceOf(msg.sender)            .mul(pool.accERC20PerShare)            .div(1e36);        _updNumStaked(_finalAmountTransferred, \"add\");        emit Deposit(msg.sender, _finalAmountTransferred);    }"