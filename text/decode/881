"function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();        uint256 blockNumber = payload.getBlockNumber();        bytes32 exitHash = keccak256(            abi.encodePacked(                blockNumber,                MerklePatriciaProof._getNibbleArray(branchMaskBytes),                payload.getReceiptLogIndex()            )        );        require(            processedExits[exitHash] == false,            \"FxRootTunnel: EXIT_ALREADY_PROCESSED\"        );        processedExits[exitHash] = true;        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();        ExitPayloadReader.Log memory log = receipt.getLog();        require(fxChildTunnel == log.getEmitter(), \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\");        bytes32 receiptRoot = payload.getReceiptRoot();        require(            MerklePatriciaProof.verify(                receipt.toBytes(),                 branchMaskBytes,                 payload.getReceiptProof(),                 receiptRoot            ),            \"FxRootTunnel: INVALID_RECEIPT_PROOF\"        );        _checkBlockMembershipInCheckpoint(            blockNumber,            payload.getBlockTime(),            payload.getTxRoot(),            receiptRoot,            payload.getHeaderNumber(),            payload.getBlockProof()        );        ExitPayloadReader.LogTopics memory topics = log.getTopics();        require(            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG,             \"FxRootTunnel: INVALID_SIGNATURE\"        );        (bytes memory message) = abi.<mask0>;         return message;    }"