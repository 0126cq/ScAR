"function onFlashLoan(        address initiator,        address token,        uint256 amount,        uint256 fee,        bytes calldata data    ) external returns (bytes32) {        require(msg.sender == address(flashLender), \"Untrusted lender\");        require(initiator == address(this), \"Untrusted loan initiator\");        LiquidationData memory liqData = abi.<mask0>;        _approve(IERC20(token), address(liqData.dolaRouter), amount);        address[] memory entryPath = _getDolaPath(token);        require(            liqData.amount ==                liqData.dolaRouter.swapExactTokensForTokens(                    amount,                    0,                    entryPath,                    address(this),                    liqData.deadline                )[entryPath.length - 1],            \"Incorrect DOLA amount received\"        );        _approve(dola, liqData.cErc20, liqData.amount);        ICErc20(liqData.cErc20).liquidateBorrow(            liqData.borrower,            liqData.amount,            liqData.cTokenCollateral        );        uint256 seizedBal =            IERC20(liqData.cTokenCollateral).balanceOf(address(this));        _approve(IERC20(liqData.cTokenCollateral), liqData.cErc20, seizedBal);        uint256 ethBalBefore = address(this).balance;         ICErc20(liqData.cTokenCollateral).redeem(seizedBal);        address underlying;        if (address(this).balance > ethBalBefore) {            weth.deposit{value: address(this).balance}();            underlying = address(weth);        } else {            underlying = ICErc20(liqData.cTokenCollateral).underlying();        }        uint256 underlyingBal = IERC20(underlying).balanceOf(address(this));        uint256 tokensReceived;        if (underlying != token) {            _approve(                IERC20(underlying),                address(liqData.exitRouter),                underlyingBal            );            address[] memory exitPath = _getExitPath(underlying, token);            tokensReceived = liqData.exitRouter.swapExactTokensForTokens(                underlyingBal,                0,                exitPath,                address(this),                liqData.deadline            )[exitPath.length - 1];        } else {            tokensReceived = underlyingBal;        }        require(            tokensReceived >= amount + fee + liqData.minProfit,            \"Not enough profit\"        );        IERC20(token).safeTransfer(            liqData.caller,            tokensReceived - (amount + fee)        );        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");    }"