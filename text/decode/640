"function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32) {    LiquidationData memory liqData = abi.<mask0>;    require(msg.sender == address(flashLender), \"Untrusted lender\");    require(token == address(USDC), \"Not USDC\");    require(initiator == address(this), \"Untrusted loan initiator\");    uint256 amountOwed = amount + fee;    _approve(USDC, address(pool), amount);    uint256 usdpReceived = pool.exchange_underlying(usdcIndex, usdpIndex, amount, 0);    _approve(USDP, address(liqAuction), usdpReceived);    liqAuction.buyout(liqData.asset, liqData.user);    uint256 collateralReceived = IERC20(liqData.asset).balanceOf(address(this));    IERC20(0xB4AdA607B9d6b2c9Ee07A275e9616B84AC560139).approve(0xB4AdA607B9d6b2c9Ee07A275e9616B84AC560139, collateralReceived);    IYearn(0xB4AdA607B9d6b2c9Ee07A275e9616B84AC560139).withdraw(collateralReceived);    uint256 bal = IERC20(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B).balanceOf(address(this));    ICurvePool(0xA79828DF1850E8a3A3064576f380D90aECDD3359).remove_liquidity_one_coin(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B, bal, 2, 0);    uint256 usdcReceived = USDC.balanceOf(address(this));    require(usdcReceived > amountOwed + liqData.minProfit, \"Less than minProfit\");    USDC.safeTransfer(liqData.caller, usdcReceived - amountOwed);    return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");  }"