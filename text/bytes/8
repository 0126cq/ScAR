"function _applyFractionsAndTransferEach(        OrderParameters memory orderParameters,        uint256 numerator,        uint256 denominator,        bytes32 fulfillerConduitKey,        address recipient    ) internal {        uint256 startTime = orderParameters.startTime;        uint256 endTime = orderParameters.endTime;        bytes memory accumulator = new <mask0>;        unchecked {            function(OfferItem memory, address, bytes32, bytes memory)                internal _transferOfferItem;            {                function(ReceivedItem memory, address, bytes32, bytes memory)                    internal _transferReceivedItem = _transfer;                assembly {                    _transferOfferItem := _transferReceivedItem                }            }            uint256 totalOfferItems = orderParameters.offer.length;            for (uint256 i = 0; i < totalOfferItems; ++i) {                OfferItem memory offerItem = orderParameters.offer[i];                if (offerItem.itemType == ItemType.NATIVE) {                    revert InvalidNativeOfferItem();                }                {                    uint256 amount = _applyFraction(                        offerItem.startAmount,                        offerItem.endAmount,                        numerator,                        denominator,                        startTime,                        endTime,                        false                    );                    assembly {                        mstore(                            add(offerItem, ReceivedItem_amount_offset),                            amount                        )                        mstore(                            add(offerItem, ReceivedItem_recipient_offset),                            recipient                        )                    }                }                _transferOfferItem(                    offerItem,                    orderParameters.offerer,                    orderParameters.conduitKey,                    accumulator                );            }        }        uint256 etherRemaining = msg.value;        unchecked {            function(ConsiderationItem memory, address, bytes32, bytes memory)                internal _transferConsiderationItem;            {                function(ReceivedItem memory, address, bytes32, bytes memory)                    internal _transferReceivedItem = _transfer;                assembly {                    _transferConsiderationItem := _transferReceivedItem                }            }            uint256 totalConsiderationItems = orderParameters                .consideration                .length;            for (uint256 i = 0; i < totalConsiderationItems; ++i) {                ConsiderationItem memory considerationItem = (                    orderParameters.consideration[i]                );                uint256 amount = _applyFraction(                    considerationItem.startAmount,                    considerationItem.endAmount,                    numerator,                    denominator,                    startTime,                    endTime,                    true                );                assembly {                    mstore(                        add(considerationItem, ReceivedItem_amount_offset),                        amount                    )                    mstore(                        add(considerationItem, ReceivedItem_recipient_offset),                        mload(                            add(                                considerationItem,                                ConsiderationItem_recipient_offset                            )                        )                    )                }                if (considerationItem.itemType == ItemType.NATIVE) {                    if (amount > etherRemaining) {                        revert InsufficientEtherSupplied();                    }                    etherRemaining -= amount;                }                _transferConsiderationItem(                    considerationItem,                    msg.sender,                    fulfillerConduitKey,                    accumulator                );            }        }        _triggerIfArmed(accumulator);        if (etherRemaining != 0) {            _transferEth(payable(msg.sender), etherRemaining);        }    }"