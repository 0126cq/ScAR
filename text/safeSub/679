"function safeBatchTransferFrom(        address from,        address to,        uint256[] calldata ids,        uint256[] calldata values,        bytes calldata data    )        override        external    {        require(            to != address(0x0),            \"CANNOT_TRANSFER_TO_ADDRESS_ZERO\"        );        require(            ids.length == values.length,            \"TOKEN_AND_VALUES_LENGTH_MISMATCH\"        );        require(            from == msg.sender || isApprovedForAll(from, msg.sender),            \"INSUFFICIENT_ALLOWANCE\"        );        for (uint256 i = 0; i < ids.length; ++i) {            uint256 id = ids[i];            uint256 value = values[i];            if (isNonFungible(id)) {                require(                    value == 1,                    \"AMOUNT_EQUAL_TO_ONE_REQUIRED\"                );                require(                    nfOwners[id] == from,                    \"NFT_NOT_OWNED_BY_FROM_ADDRESS\"                );                nfOwners[id] = to;            } else {                balances[id][from] = balances[id][from].<mask0>;                balances[id][to] = balances[id][to].safeAdd(value);            }        }        emit TransferBatch(msg.sender, from, to, ids, values);        if (to.isContract()) {            bytes4 callbackReturnValue = IERC1155Receiver(to).onERC1155BatchReceived(                msg.sender,                from,                ids,                values,                data            );            require(                callbackReturnValue == ERC1155_BATCH_RECEIVED,                \"BAD_RECEIVER_RETURN_VALUE\"            );        }    }"