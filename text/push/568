"function _transfer(        address from,        address to,        uint256 amount    ) private {        require(from != address(0), \"ERC20: transfer from the zero address\");        require(to != address(0), \"ERC20: transfer to the zero address\");        require(amount > 0, \"Transfer amount must be greater than zero\");        if (!_isExcludedFromFee[to] && !_isExcludedFromFee[from]) {            require(tradingOpen, \"TOKEN: Trading not yet started\");            require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");            require(                !bots[from] && !bots[to],                \"TOKEN: Your account is blacklisted!\"            );            if (sniiperProtection) {                if (                    launchedAt > 0 &&                    from == uniswapV2Pair &&                    !_liquidityHolders[from] &&                    !_liquidityHolders[to]                ) {                    if (block.number - launchedAt <= wipeBlocks) {                        if (!_isSniiper[to]) {                            _sniipers.<mask0>;                        }                        _isSniiper[to] = true;                    }                }            }            if (to != uniswapV2Pair) {                if (from == uniswapV2Pair && transferDelay) {                    require(                        _lastTX[tx.origin] + 3 minutes < block.timestamp &&                            _lastTX[to] + 3 minutes < block.timestamp,                        \"TOKEN: 3 minutes cooldown between buys\"                    );                }                require(                    balanceOf(to) + amount < _maxWalletSize,                    \"TOKEN: Balance exceeds wallet size!\"                );            }            uint256 contractTokenBalance = balanceOf(address(this));            bool canSwap = contractTokenBalance >= _swapTokensAtAmount;            if (contractTokenBalance >= _swapTokensAtAmount) {                contractTokenBalance = _swapTokensAtAmount;            }            if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled) {                swapTokensForEth(contractTokenBalance);                 uint256 contractETHBalance = address(this).balance;                if (contractETHBalance > 0 ether) {                    sendETHToFee(address(this).balance);                }            }        }        bool takeFee = true;        if (            (_isExcludedFromFee[from] || _isExcludedFromFee[to]) ||            (from != uniswapV2Pair && to != uniswapV2Pair)        ) {            takeFee = false;        } else {            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {                _taxFee = _taxFeeOnBuy;            }            if (to == uniswapV2Pair && from != address(uniswapV2Router)) {                _taxFee = _taxFeeOnSell;            }        }        _lastTX[tx.origin] = block.timestamp;        _lastTX[to] = block.timestamp;        _tokenTransfer(from, to, amount, takeFee);    }"