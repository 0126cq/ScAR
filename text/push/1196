"function createOption(address underlying, address currency, uint priceFloor, uint priceCap) public returns (address call_, address put) {        require(underlying != currency, 'IDENTICAL_ADDRESSES');        require(underlying != address(0) && currency != address(0), 'ZERO_ADDRESS');        require(priceFloor < priceCap, 'priceCap should biger than priceFloor');        require(config[_permissionless_] != 0 || _msgSender() == governor);        require(calls[underlying][currency][priceFloor][priceCap] == address(0), 'the Call/Put exist already');             bytes memory bytecode = type(InitializableProductProxy).creationCode;        bytes32 salt = keccak256(abi.encodePacked(_Call_, underlying, currency, priceFloor, priceCap));        assembly {            call_ := create2(0, add(bytecode, 32), mload(bytecode), salt)        }        InitializableProductProxy(payable(call_)).__InitializableProductProxy_init(address(this), _Call_, abi.encodeWithSignature('__Call_init(address,address,uint256,uint256)', underlying, currency, priceFloor, priceCap));        salt = keccak256(abi.encodePacked(_Put_, underlying, currency, priceFloor, priceCap));        assembly {            put := create2(0, add(bytecode, 32), mload(bytecode), salt)        }        InitializableProductProxy(payable(put)).__InitializableProductProxy_init(address(this), _Put_, abi.encodeWithSignature('__Put_init(address,address,uint256,uint256)',  underlying, currency, priceFloor, priceCap));        calls[underlying][currency][priceFloor][priceCap] = call_;        puts [underlying][currency][priceFloor][priceCap] = put;        allCalls.<mask0>;        allPuts.push(put);        emit CreateOption(_msgSender(), underlying, currency, priceFloor, priceCap, call_, put, allCalls.length);    }"