"function updateVtb(address token, address lender, uint incAmount, uint decAmount) external override onlyNutmeg {        require(block.number >= DIST_START_BLOCK, 'updateVtb: invalid block number');        require(incAmount == 0 || decAmount == 0, 'updateVtb: update amount is invalid');        uint amount = incAmount.add(decAmount);        require(amount > 0, 'updateVtb: update amount should be positive');        CURRENT_EPOCH = (block.number.sub(DIST_START_BLOCK)).div(BLOCKS_PER_EPOCH);        if (CURRENT_EPOCH >= NUM_EPOCH) return;        _fillVtbGap(token, lender);        _fillTotalVtbGap(token);        uint dv = echoMap[CURRENT_EPOCH].endBlock.sub( block.number ).mul(amount);        uint epochDv = BLOCKS_PER_EPOCH.mul(amount);        if (incAmount > 0) {            vtbMap[token][lender][CURRENT_EPOCH] = vtbMap[token][lender][CURRENT_EPOCH].add(dv);            totalVtbMap[token][CURRENT_EPOCH] = totalVtbMap[token][CURRENT_EPOCH].add(dv);            futureVtbMap[token][lender] = futureVtbMap[token][lender].add(epochDv);            futureTotalVtbMap[token] = futureTotalVtbMap[token].add(epochDv);        } else {            vtbMap[token][lender][CURRENT_EPOCH] = vtbMap[token][lender][CURRENT_EPOCH].sub(dv);            totalVtbMap[token][CURRENT_EPOCH] = totalVtbMap[token][CURRENT_EPOCH].sub(dv);            futureVtbMap[token][lender] = futureVtbMap[token][lender].sub(epochDv);            futureTotalVtbMap[token] = futureTotalVtbMap[token].sub(epochDv);        }        if (!addedPoolMap[token]) {            pools.<mask0>;            addedPoolMap[token] = true;        }    }"