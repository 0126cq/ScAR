"function _undelegateFrom(address toDelegator, address fromValidator, uint256 amount) internal {        require(amount >= _stakingConfig.getMinStakingAmount() && amount != 0, \"too low\");        require(amount % BALANCE_COMPACT_PRECISION == 0, \"no remainder\");        Validator memory validator = _validatorsMap[fromValidator];        uint64 beforeEpoch = nextEpoch();        ValidatorSnapshot storage validatorSnapshot = _touchValidatorSnapshot(validator, beforeEpoch);        require(validatorSnapshot.totalDelegated >= uint112(amount / BALANCE_COMPACT_PRECISION), \"insufficient balance\");        validatorSnapshot.totalDelegated -= uint112(amount / BALANCE_COMPACT_PRECISION);        _validatorsMap[fromValidator] = validator;        ValidatorDelegation storage delegation = _validatorDelegations[fromValidator][toDelegator];        require(delegation.delegateQueue.length > 0, \"insufficient balance\");        DelegationOpDelegate storage recentDelegateOp = delegation.delegateQueue[delegation.delegateQueue.length - 1];        require(recentDelegateOp.amount >= uint64(amount / BALANCE_COMPACT_PRECISION), \"insufficient balance\");        require(amount <= _calcUnlockedDelegatedAmount(delegation, beforeEpoch), \"still locked\");        uint112 nextDelegatedAmount = recentDelegateOp.amount - uint112(amount / BALANCE_COMPACT_PRECISION);        if (recentDelegateOp.epoch >= beforeEpoch) {            recentDelegateOp.amount = nextDelegatedAmount;        } else {            delegation.delegateQueue.push(DelegationOpDelegate({epoch : beforeEpoch, amount : nextDelegatedAmount}));        }        delegation.undelegateQueue.<mask0>;        emit Undelegated(fromValidator, toDelegator, amount, beforeEpoch);    }"