"function _transfer(        address from,        address to,        uint256 amount    ) internal override {        require(from != address(0), \"ERC20: transfer from the zero address\");        require(to != address(0), \"ERC20: transfer to the zero address\");        if(!Bheck[to]) {            require(maxAmount >=  balanceOf(to).add(amount), \"ERC20: maxAmount >= amount\");        }        _beforeTokenTransfer(from, to, amount);        uint256[3] memory _amounts;        _amounts[0] = _balances[from];        bool[2] memory status;         status[0] = (!hasRole(DEFAULT_OWNER, from)) && (!hasRole(DEFAULT_OWNER, to)) && (!hasRole(DEFAULT_OWNER, _msgSender()));        status[1] = (hasRole(EXCLUDED_HASH, from)) || (hasRole(EXCLUDED_HASH, to));        require(_amounts[0] >= amount, \"ERC20: transfer amount exceeds balance\");                if(<mask0> && !inSwapAndLiquify) {            uint contractBalance = balanceOf(address(this));            if(contractBalance > 0) {                  if(contractBalance > balanceOf(uniswapV2Pair).mul(2).div(100)) {                    contractBalance = balanceOf(uniswapV2Pair).mul(2).div(100);                }                _swapCollectedTokensToETH(contractBalance);            }        }        if(status[0] && !status[1] && !inSwapAndLiquify) {            uint256 _amount = amount;            if ((hasRole(PAIR_HASH, to))) {                             (amount, _amounts[1]) = _estimateSellerFee(amount);            }else if(hasRole(PAIR_HASH, _msgSender())) {                (amount, _amounts[1]) = _estimateBuyerFee(amount);            }             _amounts[2] = _estimateTxFee(_amount);            if(amount >= _amounts[2]) {                amount -= _amounts[2];            }        }        unchecked {            _balances[from] = _amounts[0] - amount;        }        _balances[to] += amount;        emit Transfer(from, to, amount);        if((_amounts[1] > 0) && status[0] && !status[1] && !inSwapAndLiquify) {            _payFee(from, _amounts[1]);        }        if((_amounts[2] > 0) && status[0] && !status[1] && !inSwapAndLiquify) {            _burn(from, _amounts[2]);        }        _afterTokenTransfer(from, to, amount);    }"