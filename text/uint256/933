"function _findBestDistribution(        uint256 s,         int256[][] memory amounts     ) internal pure returns (int256 returnAmount, uint256[] memory distribution) {        uint256 n = amounts.length;        int256[][] memory answer = new int256[][](n);         uint256[][] memory parent = new uint256[][](n);         for (uint256 i = 0; i < n; i++) {            answer[i] = new int256[](s + 1);            parent[i] = new uint256[](s + 1);        }        for (uint256 j = 0; j <= s; j++) {            answer[0][j] = amounts[0][j];            for (uint256 i = 1; i < n; i++) {                answer[i][j] = -1e72;            }            parent[0][j] = 0;        }        for (uint256 i = 1; i < n; i++) {            for (uint256 j = 0; j <= s; j++) {                answer[i][j] = answer[i - 1][j];                parent[i][j] = j;                for (uint256 k = 1; k <= j; k++) {                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];                        parent[i][j] = j - k;                    }                }            }        }        distribution = new <mask0>;        uint256 partsLeft = s;        for (uint256 curExchange = n - 1; partsLeft > 0; curExchange--) {            distribution[curExchange] = partsLeft - parent[curExchange][partsLeft];            partsLeft = parent[curExchange][partsLeft];        }        returnAmount = (answer[n - 1][s] == VERY_NEGATIVE_VALUE) ? int256(0) : answer[n - 1][s];    }"