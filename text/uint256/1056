"function _calcBptOutGivenExactTokensIn(        uint256[] memory balances,        uint256[] memory normalizedWeights,        uint256[] memory amountsIn,        uint256 bptTotalSupply,        uint256 swapFeePercentage    ) internal pure returns (uint256) {        uint256[] memory balanceRatiosWithFee = new <mask0>;        uint256 invariantRatioWithFees = 0;        for (uint256 i = 0; i < balances.length; i++) {            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(normalizedWeights[i]));        }        uint256 invariantRatio = FixedPoint.ONE;        for (uint256 i = 0; i < balances.length; i++) {            uint256 amountInWithoutFee;            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE.sub(swapFeePercentage)));            } else {                amountInWithoutFee = amountsIn[i];            }            uint256 balanceRatio = balances[i].add(amountInWithoutFee).divDown(balances[i]);            invariantRatio = invariantRatio.mulDown(balanceRatio.powDown(normalizedWeights[i]));        }        if (invariantRatio > FixedPoint.ONE) {            return bptTotalSupply.mulDown(invariantRatio.sub(FixedPoint.ONE));        } else {            return 0;        }    }"