"function _findBestDistribution(        uint256 s,                        int256[][] memory amounts     )        internal        pure        returns (            int256 returnAmount,            uint256[] memory distribution        )    {        uint256 n = amounts.length;        int256[][] memory answer = new int256[][](n);         uint256[][] memory parent = new <mask0>;         for (uint i = 0; i < n; i++) {            answer[i] = new int256[](s + 1);            parent[i] = new uint256[](s + 1);        }        for (uint j = 0; j <= s; j++) {            answer[0][j] = amounts[0][j];            for (uint i = 1; i < n; i++) {                answer[i][j] = -1e72;            }            parent[0][j] = 0;        }        for (uint i = 1; i < n; i++) {            for (uint j = 0; j <= s; j++) {                answer[i][j] = answer[i - 1][j];                parent[i][j] = j;                for (uint k = 1; k <= j; k++) {                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];                        parent[i][j] = j - k;                    }                }            }        }        distribution = new uint256[](DEXES_COUNT*PATHS_COUNT*PATHS_SPLIT);        uint256 partsLeft = s;        unchecked {            for (uint curExchange = n - 1; partsLeft > 0; curExchange--) {                distribution[curExchange] = partsLeft - parent[curExchange][partsLeft];                partsLeft = parent[curExchange][partsLeft];            }        }        returnAmount = (answer[n - 1][s] == VERY_NEGATIVE_VALUE) ? int256(0) : answer[n - 1][s];    }"