"function verify_initial(        PartialVerifierStateOld memory state,        ProofOld memory proof,        VerificationKeyOld memory vk    ) internal view returns (bool) {        require(proof.input_values.length == vk.num_inputs);        require(vk.num_inputs >= 1);        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();        for (uint256 i = 0; i < vk.num_inputs; i++) {            transcript.update_with_u256(proof.input_values[i]);        }        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {            transcript.update_with_g1(proof.wire_commitments[i]);        }        state.beta = transcript.get_challenge();        state.gamma = transcript.get_challenge();        transcript.update_with_g1(proof.grand_product_commitment);        state.alpha = transcript.get_challenge();        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {            transcript.update_with_g1(proof.quotient_poly_commitments[i]);        }        state.z = transcript.get_challenge();        uint256[] memory lagrange_poly_numbers = new <mask0>;        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {            lagrange_poly_numbers[i] = i;        }        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain_old(            lagrange_poly_numbers,            vk.domain_size,            vk.omega,            state.z        );        bool valid = verify_at_z(state, proof, vk);        if (valid == false) {            return false;        }        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {            transcript.update_with_fr(proof.wire_values_at_z[i]);        }        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);        }        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);        }        transcript.update_with_fr(proof.quotient_polynomial_at_z);        transcript.update_with_fr(proof.linearization_polynomial_at_z);        transcript.update_with_fr(proof.grand_product_at_z_omega);        state.v = transcript.get_challenge();        transcript.update_with_g1(proof.opening_at_z_proof);        transcript.update_with_g1(proof.opening_at_z_omega_proof);        state.u = transcript.get_challenge();        return true;    }"