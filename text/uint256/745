"function withdrawNft(uint256 _contractId, address _recipient, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256 _requestsId, uint32 _stamina, bytes calldata _state)     public onlyMinter {      if (requestWithdrawn[_requestsId]) {        return;      }      requestWithdrawn[_requestsId] = true;      WithdrawNftVars memory _locals = WithdrawNftVars(0, 0, 0);      IRainiCard nftContract = IRainiCard(nftContracts[_contractId]);      _locals.tokenId = findHeldToken(_contractId, _cardId, _cardLevel, _mintedContractChar, _number);      _locals.amount = 0;      if (_locals.tokenId > 0) {        _locals.amount = nftContract.balanceOf(address(this), _locals.tokenId);      }      _locals.leftAmount = _amount;      if (_locals.amount > 0) {        if (_locals.amount > _amount) {          _locals.leftAmount = 0;          nftContract.safeTransferFrom(address(this), _recipient, _locals.tokenId, _amount, bytes(''));        } else {          _locals.leftAmount -= _locals.amount;          nftContract.safeTransferFrom(address(this), _recipient, _locals.tokenId, _locals.amount, bytes(''));          _setHeldToken(0, _contractId, _cardId, _cardLevel, _mintedContractChar, _number);        }        updateStamina(address(nftContract), _locals.tokenId, _stamina);        updateSubContractState(address(nftContract), _cardId, _locals.tokenId, _state);      }       if (_locals.leftAmount > 0) {        if (hasSubcontracts[_contractId]) {          nftContract.mint(_recipient, _cardId, _cardLevel, _locals.leftAmount, _mintedContractChar, _number, new <mask0>);          updateSubContractState(address(nftContract), _cardId, nftContract.maxTokenId(), _state);        } else {          nftContract.mint(_recipient, _cardId, _cardLevel, _locals.leftAmount, _mintedContractChar, _number);        }        updateStamina(address(nftContract), nftContract.maxTokenId(), _stamina);      }      emit CardsWithdrawn(_contractId, _recipient, _requestsId, _cardId, _amount);  }"