"function borrow(        address _reserve,        uint256 _amount,        uint256 _interestRateMode,        uint16 _referralCode    )        external        nonReentrant        onlyActiveReserve(_reserve)        onlyUnfreezedReserve(_reserve)        onlyAmountGreaterThanZero(_amount)    {        BorrowLocalVars memory vars;        require(core.isReserveBorrowingEnabled(_reserve), \"Reserve is not enabled for borrowing\");        require(            uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||                <mask0> == _interestRateMode,            \"Invalid interest rate mode selected\"        );        vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);        vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);        require(            vars.availableLiquidity >= _amount,            \"There is not enough liquidity available in the reserve\"        );        (            ,            vars.userCollateralBalanceETH,            vars.userBorrowBalanceETH,            vars.userTotalFeesETH,            vars.currentLtv,            vars.currentLiquidationThreshold,            ,            vars.healthFactorBelowThreshold        ) = dataProvider.calculateUserGlobalData(msg.sender);        require(vars.userCollateralBalanceETH > 0, \"The collateral balance is 0\");        require(            !vars.healthFactorBelowThreshold,            \"The borrower can already be liquidated so he cannot borrow more\"        );        vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);        require(vars.borrowFee > 0, \"The amount to borrow is too small\");        vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(            _reserve,            _amount,            vars.borrowFee,            vars.userBorrowBalanceETH,            vars.userTotalFeesETH,            vars.currentLtv        );        require(            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,            \"There is not enough collateral to cover a new borrow\"        );        if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) {            require(                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),                \"User cannot borrow the selected amount with a stable rate\"            );            uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();            uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);            require(                _amount <= maxLoanSizeStable,                \"User is trying to borrow too much liquidity at a stable rate\"            );        }        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(            _reserve,            msg.sender,            _amount,            vars.borrowFee,            vars.rateMode        );        core.transferToUser(_reserve, msg.sender, _amount);        emit Borrow(            _reserve,            msg.sender,            _amount,            _interestRateMode,            vars.finalUserBorrowRate,            vars.borrowFee,            vars.borrowBalanceIncrease,            _referralCode,            block.timestamp        );    }"