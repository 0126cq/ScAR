"function _calcBptOutGivenExactTokensIn(        uint256 amp,        uint256[] memory balances,        uint256[] memory amountsIn,        uint256 bptTotalSupply,        uint256 swapFeePercentage    ) internal pure returns (uint256) {        uint256 sumBalances = 0;        for (uint256 i = 0; i < balances.length; i++) {            sumBalances = sumBalances.add(balances[i]);        }        uint256[] memory balanceRatiosWithFee = new <mask0>;        uint256 invariantRatioWithFees = 0;        for (uint256 i = 0; i < balances.length; i++) {            uint256 currentWeight = balances[i].divDown(sumBalances);            balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);            invariantRatioWithFees = invariantRatioWithFees.add(balanceRatiosWithFee[i].mulDown(currentWeight));        }        uint256[] memory newBalances = new uint256[](balances.length);        for (uint256 i = 0; i < balances.length; i++) {            uint256 amountInWithoutFee;            if (balanceRatiosWithFee[i] > invariantRatioWithFees) {                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithFees.sub(FixedPoint.ONE));                uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);                amountInWithoutFee = nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));            } else {                amountInWithoutFee = amountsIn[i];            }            newBalances[i] = balances[i].add(amountInWithoutFee);        }        uint256 currentInvariant = _calculateInvariant(amp, balances, true);        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);        uint256 invariantRatio = newInvariant.divDown(currentInvariant);        if (invariantRatio > FixedPoint.ONE) {            return bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE);        } else {            return 0;        }    }"