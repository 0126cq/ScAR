"function _calcBptInGivenExactTokensOut(        uint256 amp,        uint256[] memory balances,        uint256[] memory amountsOut,        uint256 bptTotalSupply,        uint256 swapFeePercentage    ) internal pure returns (uint256) {        uint256 sumBalances = 0;        for (uint256 i = 0; i < balances.length; i++) {            sumBalances = sumBalances.add(balances[i]);        }        uint256[] memory balanceRatiosWithoutFee = new uint256[](amountsOut.length);        uint256 invariantRatioWithoutFees = 0;        for (uint256 i = 0; i < balances.length; i++) {            uint256 currentWeight = balances[i].divUp(sumBalances);            balanceRatiosWithoutFee[i] = balances[i].sub(amountsOut[i]).divUp(balances[i]);            invariantRatioWithoutFees = invariantRatioWithoutFees.add(balanceRatiosWithoutFee[i].mulUp(currentWeight));        }        uint256[] memory newBalances = new <mask0>;        for (uint256 i = 0; i < balances.length; i++) {            uint256 amountOutWithFee;            if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {                uint256 nonTaxableAmount = balances[i].mulDown(invariantRatioWithoutFees.complement());                uint256 taxableAmount = amountsOut[i].sub(nonTaxableAmount);                amountOutWithFee = nonTaxableAmount.add(taxableAmount.divUp(FixedPoint.ONE - swapFeePercentage));            } else {                amountOutWithFee = amountsOut[i];            }            newBalances[i] = balances[i].sub(amountOutWithFee);        }        uint256 currentInvariant = _calculateInvariant(amp, balances, true);        uint256 newInvariant = _calculateInvariant(amp, newBalances, false);        uint256 invariantRatio = newInvariant.divDown(currentInvariant);        return bptTotalSupply.mulUp(invariantRatio.complement());    }"