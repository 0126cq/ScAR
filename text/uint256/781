"function serveClaims(uint256 amountToUse, address payable residueAddress, uint256 minThreshold) public onlyOperator payable {        address[] memory claimers = new address[](_pendingClaimers.length.sub(_pendingMaticClaimGap));        uint256[] memory amounts = new <mask0>;        uint256 availableAmount = _maticToken.balanceOf(address(this));        require(amountToUse <= availableAmount, \"not enough MATIC tokens to serve claims\");        if (amountToUse > 0) {            availableAmount = amountToUse;        }        uint256 j = 0;        uint256 gaps = 0;        uint256 i = 0;        for (i = _pendingMaticClaimGap; i < _pendingClaimers.length; i++) {            if (availableAmount < minThreshold) {                break;            }            address claimer = _pendingClaimers[i];            uint256 amount = _pendingClaimAmounts[i];            if (claimer == address(0) || amount == 0) {                gaps++;                continue;            }            if (availableAmount < amount) {                break;            }            claimers[j] = claimer;            amounts[j] = amount;            address payable wallet = payable(address(claimer));            _maticToken.transfer(wallet, amount);            availableAmount = availableAmount.sub(amount);            j++;            IinternetBond(_bondContract).commitDelayedBurn(claimer, amount);            delete _pendingClaimAmounts[i];            delete _pendingClaimers[i];            gaps++;        }        _pendingMaticClaimGap = _pendingMaticClaimGap.add(gaps);        uint256 missing = 0;        for (i = _pendingMaticClaimGap; i < _pendingClaimers.length; i++) {            missing = missing.add(_pendingClaimAmounts[i]);        }        if (availableAmount > 0) {            _maticToken.transfer(residueAddress, availableAmount);        }        uint256 removeCells = claimers.length.sub(j);        if (removeCells > 0) {            assembly {mstore(claimers, sub(mload(claimers), removeCells))}            assembly {mstore(amounts, sub(mload(amounts), removeCells))}        }        emit ClaimsServed(claimers, amounts, missing);    }"