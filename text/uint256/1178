"function _delta(bool fullMode) internal {        if (deltaCredit > 0 && totalWeight > 0) {            uint256 cpLength = chainPaths.length;            uint256[] memory deficit = new <mask0>;            uint256 totalDeficit = 0;            for (uint256 i = 0; i < cpLength; ++i) {                ChainPath storage cp = chainPaths[i];                uint256 balLiq = totalLiquidity.mul(cp.weight).div(totalWeight);                uint256 currLiq = cp.lkb.add(cp.credits);                if (balLiq > currLiq) {                    deficit[i] = balLiq - currLiq;                    totalDeficit = totalDeficit.add(deficit[i]);                }            }            uint256 spent;            if (totalDeficit == 0) {                if (fullMode && deltaCredit > 0) {                    for (uint256 i = 0; i < cpLength; ++i) {                        ChainPath storage cp = chainPaths[i];                        uint256 amtToCredit = deltaCredit.mul(cp.weight).div(totalWeight);                        spent = spent.add(amtToCredit);                        cp.credits = cp.credits.add(amtToCredit);                    }                }             } else if (totalDeficit <= deltaCredit) {                if (fullMode) {                    uint256 excessCredit = deltaCredit - totalDeficit;                    for (uint256 i = 0; i < cpLength; ++i) {                        if (deficit[i] > 0) {                            ChainPath storage cp = chainPaths[i];                            uint256 amtToCredit = deficit[i].add(excessCredit.mul(cp.weight).div(totalWeight));                            spent = spent.add(amtToCredit);                            cp.credits = cp.credits.add(amtToCredit);                        }                    }                } else {                    for (uint256 i = 0; i < cpLength; ++i) {                        if (deficit[i] > 0) {                            ChainPath storage cp = chainPaths[i];                            uint256 amtToCredit = deficit[i];                            spent = spent.add(amtToCredit);                            cp.credits = cp.credits.add(amtToCredit);                        }                    }                }            } else {                for (uint256 i = 0; i < cpLength; ++i) {                    if (deficit[i] > 0) {                        ChainPath storage cp = chainPaths[i];                        uint256 proportionalDeficit = deficit[i].mul(deltaCredit).div(totalDeficit);                        spent = spent.add(proportionalDeficit);                        cp.credits = cp.credits.add(proportionalDeficit);                    }                }            }            deltaCredit = deltaCredit.sub(spent);        }    }"