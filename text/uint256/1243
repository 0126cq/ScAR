"function claimRewardsMaster(        uint256[] memory _epochGroup,        address[] memory _feeHandlerGroup    ) public {        require(_epochGroup.length > 0, \"cRMaster: _epochGroup required\");        require(            isOrderedSet(_epochGroup),            \"cRMaster: order and uniqueness required\"        );        require(            _feeHandlerGroup.length > 0,            \"cRMaster: _feeHandlerGroup required\"        );        uint256[] memory accruedByFeeHandler = new <mask0>;        uint256 feeId = 0;        for (uint256 j = 0; j < _epochGroup.length; j++) {            uint256 _epoch = _epochGroup[j];            feeId = getEpochDFeeDataId(_epoch, feeId);            DFeeData storage epochDFee = delegationFees[feeId];            if (!epochDFee.applied) {                applyFee(epochDFee);            }            (uint256 stake, uint256 delegatedStake, ) = kyberStaking                .getStakerRawData(address(this), _epoch);            for (uint256 i = 0; i < _feeHandlerGroup.length; i++) {                RewardInfo memory rewardInfo = _claimRewardsFromKyber(                    _epoch,                    _feeHandlerGroup[i],                    epochDFee,                    stake,                    delegatedStake                );                if (rewardInfo.totalRewards == 0) {                    continue;                }                accruedByFeeHandler[i] = accruedByFeeHandler[i].add(                    rewardInfo.poolMasterShare                );                if (!successfulClaimByFeeHandler[_feeHandlerGroup[i]]) {                    successfulClaimByFeeHandler[_feeHandlerGroup[i]] = true;                }            }        }        address poolMaster = owner();        for (uint256 k = 0; k < accruedByFeeHandler.length; k++) {            _sendTokens(                rewardTokenByFeeHandler[_feeHandlerGroup[k]],                poolMaster,                accruedByFeeHandler[k],                \"cRMaster: poolMaster share transfer failed\"            );        }    }"