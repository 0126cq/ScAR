"function swapBack() private {        uint256 contractBalance = balanceOf(address(this));        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForBuyBack + tokensForDev;        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);        uint256 initialETHBalance = address(this).balance;        <mask0>;         uint256 ethBalance = address(this).balance.sub(initialETHBalance);        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);        uint256 ethForBuyBack = ethBalance.mul(tokensForBuyBack).div(totalTokensToSwap);        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev - ethForBuyBack;        tokensForLiquidity = 0;        tokensForMarketing = 0;        tokensForBuyBack = 0;        tokensForDev = 0;        (bool success,) = address(marketingWallet).call{value: ethForMarketing}(\"\");        (success,) = address(devWallet).call{value: ethForDev}(\"\");        if(liquidityTokens > 0 && ethForLiquidity > 0){            addLiquidity(liquidityTokens, ethForLiquidity);            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);        }        if(buyBuyBackFee == 0 && sellBuyBackFee == 0 && address(this).balance >= 1 ether){            (success,) = address(marketingWallet).call{value: address(this).balance}(\"\");        }    }"