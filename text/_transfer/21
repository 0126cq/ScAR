"function _performFinalChecksAndExecuteOrders(        AdvancedOrder[] memory advancedOrders,        Execution[] memory executions    ) internal returns (bool[] memory availableOrders) {        uint256 totalOrders = advancedOrders.length;        availableOrders = new bool[](totalOrders);        unchecked {            for (uint256 i = 0; i < totalOrders; ++i) {                AdvancedOrder memory advancedOrder = advancedOrders[i];                if (advancedOrder.numerator == 0) {                    continue;                }                availableOrders[i] = true;                ConsiderationItem[] memory consideration = (                    advancedOrder.parameters.consideration                );                for (uint256 j = 0; j < consideration.length; ++j) {                    uint256 unmetAmount = consideration[j].startAmount;                    if (unmetAmount != 0) {                        revert ConsiderationNotMet(i, j, unmetAmount);                    }                }            }        }        uint256 etherRemaining = msg.value;        bytes memory accumulator = new bytes(AccumulatorDisarmed);        for (uint256 i = 0; i < executions.length; ) {            Execution memory execution = executions[i];            ReceivedItem memory item = execution.item;            if (item.itemType == ItemType.NATIVE) {                if (item.amount > etherRemaining) {                    revert InsufficientEtherSupplied();                }                unchecked {                    etherRemaining -= item.amount;                }            }            <mask0>;            unchecked {                ++i;            }        }        _triggerIfArmed(accumulator);        if (etherRemaining != 0) {            _transferEth(payable(msg.sender), etherRemaining);        }        _clearReentrancyGuard();        return (availableOrders);    }"