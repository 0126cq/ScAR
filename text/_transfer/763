"function withdraw(uint256 amount) external override onlyPoolOrGovernance returns (bool) {        IStrategy strategy = getStrategy();        uint256 availableUnderlying_ = _availableUnderlying();        if (availableUnderlying_ < amount) {            if (address(strategy) == address(0)) return false;            uint256 allocated = strategy.balance();            uint256 requiredWithdrawal = amount - availableUnderlying_;            if (requiredWithdrawal > allocated) return false;            uint256 newTarget = (allocated - requiredWithdrawal).scaledMul(getTargetAllocation());            uint256 excessAmount = allocated - newTarget;            strategy.withdraw(excessAmount);            currentAllocated = _computeNewAllocated(currentAllocated, excessAmount);        } else {            uint256 allocatedUnderlying = 0;            if (address(strategy) != address(0))                allocatedUnderlying = IStrategy(strategy).balance();            uint256 totalUnderlying = availableUnderlying_ +                allocatedUnderlying +                waitingForRemovalAllocated;            uint256 totalUnderlyingAfterWithdraw = totalUnderlying - amount;            _rebalance(totalUnderlyingAfterWithdraw, allocatedUnderlying);        }        <mask0>;        return true;    }"