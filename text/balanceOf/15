"function fillQuoteEthToToken(        address buyTokenAddress,        address payable target,        bytes calldata swapCallData,        uint256 feeAmount    ) external payable nonReentrant onlyApprovedTarget(target) {        uint256 initialTokenBalance = ERC20(buyTokenAddress).<mask0>;        uint256 initialEthAmount = address(this).balance - msg.value;        uint256 sellAmount = msg.value - feeAmount;        (bool success, bytes memory res) = target.call{value: sellAmount}(            swapCallData        );        if (!success) {            assembly {                let returndata_size := mload(res)                revert(add(32, res), returndata_size)            }        }        {            uint256 finalTokenBalance = ERC20(buyTokenAddress).balanceOf(                address(this)            );            require(initialTokenBalance < finalTokenBalance, \"NO_TOKENS\");        }        SafeTransferLib.safeTransfer(            ERC20(buyTokenAddress),            msg.sender,            ERC20(buyTokenAddress).balanceOf(address(this)) -                initialTokenBalance        );        {            uint256 finalEthAmount = address(this).balance - feeAmount;            if (finalEthAmount > initialEthAmount) {                SafeTransferLib.safeTransferETH(                    msg.sender,                    finalEthAmount - initialEthAmount                );            }        }    }"