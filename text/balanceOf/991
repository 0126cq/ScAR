"function tokensOfOwnerIn(        address owner,        uint256 start,        uint256 stop    ) external view returns (uint256[] memory) {        unchecked {            if (start >= stop) revert InvalidQueryRange();            uint256 tokenIdsIdx;            uint256 stopLimit = _currentIndex;            if (start < _startTokenId()) {                start = _startTokenId();            }            if (stop > stopLimit) {                stop = stopLimit;            }            uint256 tokenIdsMaxLength = <mask0>;            if (start < stop) {                uint256 rangeLength = stop - start;                if (rangeLength < tokenIdsMaxLength) {                    tokenIdsMaxLength = rangeLength;                }            } else {                tokenIdsMaxLength = 0;            }            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);            if (tokenIdsMaxLength == 0) {                return tokenIds;            }            TokenOwnership memory ownership = explicitOwnershipOf(start);            address currOwnershipAddr;            if (!ownership.burned) {                currOwnershipAddr = ownership.addr;            }            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {                ownership = _ownerships[i];                if (ownership.burned) {                    continue;                }                if (ownership.addr != address(0)) {                    currOwnershipAddr = ownership.addr;                }                if (currOwnershipAddr == owner) {                    tokenIds[tokenIdsIdx++] = i;                }            }            assembly {                mstore(tokenIds, tokenIdsIdx)            }            return tokenIds;        }    }"