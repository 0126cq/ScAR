"function withdraw (uint256 receiptTokenAmount) public ifNotReentrantWithdrawal {        require(receiptTokenAmount > 0, \"Invalid withdrawal amount\");        _reentrancyMutexForWithdrawals = 1;        compute();        require(_receiptToken.<mask0> >= receiptTokenAmount, \"Insufficient balance of tokens\");        uint256 withdrawalAmount = toErc20Amount(receiptTokenAmount);        require(withdrawalAmount <= _records[currentPeriod].totalDeposited, \"Invalid withdrawal amount\");        uint256 maxWithdrawalAmount = _records[currentPeriod].totalDeposited * (uint256(100) - uint256(investmentPercent)) / uint256(100);        require(withdrawalAmount <= maxWithdrawalAmount, \"Max withdrawal amount exceeded\");        uint256 currentBalance = underlyingTokenInterface.balanceOf(address(this));        require(currentBalance >= withdrawalAmount, \"Insufficient funds in the buffer\");        uint256 feeAmount = (flatFeePercent > 0) ? withdrawalAmount * flatFeePercent / uint256(100) / _decimalsMultiplier : 0;        require(feeAmount < withdrawalAmount, \"Invalid fee\");        uint256 withdrawalAmountAfterFees = withdrawalAmount - feeAmount;        _records[currentPeriod].totalDeposited -= withdrawalAmount;        _receiptToken.burn(msg.sender, receiptTokenAmount);        require(underlyingTokenInterface.transfer(msg.sender, withdrawalAmountAfterFees), \"Token transfer failed\");        if (feeAmount > 0) {            require(underlyingTokenInterface.transfer(feesAddress, feeAmount), \"Fee transfer failed\");        }        emit OnVaultWithdrawal(address(underlyingTokenInterface), msg.sender, withdrawalAmount, receiptTokenAmount, feeAmount);        _reentrancyMutexForWithdrawals = 0;     }"