"function tryBuyItem(        BuyItemParams memory _buyOrder,        uint16 _inputSettingsBitFlag,        uint256 _maxSpendAllowanceLeft    )        internal        returns (            uint256 totalPrice,            bool success,            BuyError buyError        )    {        uint256 quantityToBuy = _buyOrder.quantity;        ITroveMarketplace.ListingOrBid memory listing = troveMarketplace            .listings(_buyOrder.nftAddress, _buyOrder.tokenId, _buyOrder.owner);        if (listing.quantity < quantityToBuy) {            if (                SettingsBitFlag.checkSetting(                    _inputSettingsBitFlag,                    SettingsBitFlag.INSUFFICIENT_QUANTITY_ERC1155                )            ) {                quantityToBuy = listing.quantity;            } else {                return (0, false, BuyError.INSUFFICIENT_QUANTITY_ERC1155);            }        }        if ((listing.pricePerItem * quantityToBuy) > _maxSpendAllowanceLeft) {            return (0, false, BuyError.EXCEEDING_MAX_SPEND);        }        BuyItemParams[] memory buyItemParams = new BuyItemParams[](1);        buyItemParams[0] = _buyOrder;        uint256 totalSpent = 0;        uint256 value = (_buyOrder.paymentToken == address(weth))            ? (_buyOrder.maxPricePerItem * quantityToBuy)            : 0;        try troveMarketplace.buyItems{value: value}(buyItemParams) {            if (                SettingsBitFlag.checkSetting(                    _inputSettingsBitFlag,                    SettingsBitFlag.EMIT_SUCCESS_EVENT_LOGS                )            ) {                emit SuccessBuyItem(                    _buyOrder.nftAddress,                    _buyOrder.tokenId,                    _buyOrder.owner,                    msg.sender,                    quantityToBuy,                    listing.pricePerItem                );            }            if (                IERC165(_buyOrder.nftAddress).supportsInterface(                    INTERFACE_ID_ERC721                )            ) {                IERC721(_buyOrder.nftAddress).safeTransferFrom(                    address(this),                    msg.sender,                    _buyOrder.tokenId                );            } else if (                IERC165(_buyOrder.nftAddress).<mask0>            ) {                IERC1155(_buyOrder.nftAddress).safeTransferFrom(                    address(this),                    msg.sender,                    _buyOrder.tokenId,                    quantityToBuy,                    \"\"                );            } else revert InvalidNFTAddress();            totalSpent = listing.pricePerItem * quantityToBuy;        } catch (bytes memory errorReason) {            if (                SettingsBitFlag.checkSetting(                    _inputSettingsBitFlag,                    SettingsBitFlag.EMIT_FAILURE_EVENT_LOGS                )            ) {                emit CaughtFailureBuyItem(                    _buyOrder.nftAddress,                    _buyOrder.tokenId,                    _buyOrder.owner,                    msg.sender,                    quantityToBuy,                    listing.pricePerItem,                    errorReason                );            }            if (                SettingsBitFlag.checkSetting(                    _inputSettingsBitFlag,                    SettingsBitFlag.MARKETPLACE_BUY_ITEM_REVERTED                )            ) revert FirstBuyReverted(errorReason);            return (0, false, BuyError.BUY_ITEM_REVERTED);        }        return (totalSpent, true, BuyError.NONE);    }"