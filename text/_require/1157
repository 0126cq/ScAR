"function _withdrawInternal(        uint256 _amountIn,        uint256 _minAmountOut,        address payable _to,        bool _withPenalty,        address _unwindStrategy,        uint256 _pricePerShare,        uint256 _strategyNAV,        uint256 _fee    ) internal {        _onlyUnpaused();        _checkLastPricePerShare(_pricePerShare);        uint256 prevBalance = balanceOf(_to);        <mask0>;        _require(block.timestamp.sub(_getLastDepositAt(_to)) >= depositHardlock, Errors.DEPOSIT_HARDLOCK);        uint256 lockedBalance = contributors[_to].lockedBalance;        _amountIn = _amountIn > prevBalance.sub(lockedBalance) ? prevBalance.sub(lockedBalance) : _amountIn;        _require(_amountIn <= prevBalance.sub(lockedBalance), Errors.TOKENS_STAKED);        uint256 amountOut = _sharesToReserve(_amountIn, _pricePerShare);        if (_withPenalty && !(_liquidReserve() >= amountOut)) {            amountOut = amountOut.sub(amountOut.preciseMul(EARLY_WITHDRAWAL_PENALTY));            _onlyNonZero(_unwindStrategy);            IStrategy(_unwindStrategy).unwindStrategy(amountOut.add(amountOut.preciseMul(5e16)), _strategyNAV);        }        _require(amountOut >= _minAmountOut && _amountIn > 0, Errors.RECEIVE_MIN_AMOUNT);        _require(_liquidReserve() >= amountOut, Errors.MIN_LIQUIDITY);        _burn(_to, _amountIn);        if (_fee > 0) {            IERC20(reserveAsset).safeTransfer(msg.sender, _fee);        }        _updateContributorWithdrawalInfo(_to, amountOut, prevBalance, balanceOf(_to), _amountIn);        contributors[_to].nonce++;        _safeSendReserveAsset(_to, amountOut.sub(_fee));        emit GardenWithdrawal(_to, _to, amountOut, _amountIn, block.timestamp);    }"