"function _internalDeposit(        uint256 _amountIn,        uint256 _minAmountOut,        address _to,        address _from,        uint256 _pricePerShare,        uint256 _minContribution,        address _referrer    ) private {        _onlyUnpaused();        _onlyNonZero(_to);        _checkLastPricePerShare(_pricePerShare);        bool canDeposit = !privateGarden || IMardukGate(controller.mardukGate()).canJoinAGarden(address(this), _to);        _require(_isCreator(_to) || canDeposit, Errors.USER_CANNOT_JOIN);        if (maxDepositLimit > 0) {            _require(_liquidReserve().add(_amountIn) <= maxDepositLimit, Errors.MAX_DEPOSIT_LIMIT);        }        <mask0>;        uint256 reserveAssetBalanceBefore = IERC20(reserveAsset).balanceOf(address(this));        if (reserveAsset == WETH && msg.value > 0) {            IWETH(WETH).deposit{value: msg.value}();        } else {            IERC20(reserveAsset).safeTransferFrom(_from, address(this), _amountIn);        }        _require(            IERC20(reserveAsset).balanceOf(address(this)).sub(reserveAssetBalanceBefore) == _amountIn,            Errors.MSG_VALUE_DO_NOT_MATCH        );        uint256 previousBalance = balanceOf(_to);        uint256 normalizedAmountIn = _amountIn.preciseDiv(uint256(10)**ERC20Upgradeable(reserveAsset).decimals());        uint256 sharesToMint = normalizedAmountIn.preciseDiv(_pricePerShare);        _require(sharesToMint >= _minAmountOut, Errors.RECEIVE_MIN_AMOUNT);        _mint(_to, sharesToMint);        controller.addAffiliateReward(_from, _referrer != address(0) ? _referrer : _from, _amountIn);        _updateContributorDepositInfo(_to, previousBalance, _amountIn, sharesToMint);        contributors[_to].nonce++;        emit GardenDeposit(_to, _minAmountOut, _amountIn, block.timestamp);    }"