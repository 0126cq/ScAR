"function _beforeTokenTransfer(        address operator,        address from,        address to,        uint256[] memory ids,        uint256[] memory amounts,        bytes memory data    ) internal virtual override {        super.<mask0>;        PoolStorage.Layout storage l = PoolStorage.layout();        for (uint256 i; i < ids.length; i++) {            uint256 id = ids[i];            uint256 amount = amounts[i];            if (amount == 0) continue;            if (from == address(0)) {                l.tokenIds.add(id);            }            if (to == address(0) && _totalSupply(id) == 0) {                l.tokenIds.remove(id);            }            if (                id == UNDERLYING_FREE_LIQ_TOKEN_ID ||                id == BASE_FREE_LIQ_TOKEN_ID ||                id == UNDERLYING_RESERVED_LIQ_TOKEN_ID ||                id == BASE_RESERVED_LIQ_TOKEN_ID            ) {                if (from != address(0) && to != address(0)) {                    bool isCallPool = id == UNDERLYING_FREE_LIQ_TOKEN_ID ||                        id == UNDERLYING_RESERVED_LIQ_TOKEN_ID;                    require(                        l.depositedAt[from][isCallPool] + (1 days) <                            block.timestamp,                        \"liq lock 1d\"                    );                }            }            if (                id == UNDERLYING_FREE_LIQ_TOKEN_ID ||                id == BASE_FREE_LIQ_TOKEN_ID            ) {                bool isCallPool = id == UNDERLYING_FREE_LIQ_TOKEN_ID;                uint256 minimum = l.getMinimumAmount(isCallPool);                if (from != address(0)) {                    uint256 balance = _balanceOf(from, id);                    if (balance > minimum && balance <= amount + minimum) {                        require(                            balance - l.pendingDepositsOf(from, isCallPool) >=                                amount,                            \"Insuf balance\"                        );                        l.removeUnderwriter(from, isCallPool);                    }                    if (to != address(0)) {                        _subUserTVL(l, from, isCallPool, amount);                        _addUserTVL(l, to, isCallPool, amount);                    }                }                if (to != address(0)) {                    uint256 balance = _balanceOf(to, id);                    if (balance <= minimum && balance + amount >= minimum) {                        l.addUnderwriter(to, isCallPool);                    }                }            }            (PoolStorage.TokenType tokenType, , ) = PoolStorage.parseTokenId(                id            );            if (                tokenType == PoolStorage.TokenType.SHORT_CALL ||                tokenType == PoolStorage.TokenType.SHORT_PUT            ) {                _beforeShortTokenTransfer(l, from, to, id, amount);            }        }    }"