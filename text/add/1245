"function vote(        uint256 id,        bool support,        uint256 voteAmount    ) external override nonReentrant {        Proposal storage proposal = proposals[id];        require(proposal.proposer != address(0), \"yVaren: INVALID_PROPOSAL_ID\");        require(block.number < proposal.endBlock, \"yVaren: VOTING_ENDED\");        require(voteAmount > 0, \"yVaren: ZERO\");        require(            voteAmount <= balanceOf(msg.sender),            \"yVaren: INSUFFICIENT_BALANCE\"        );        _updateVoteExpiry();        require(            voteAmount >= voteLockAmount[msg.sender],            \"yVaren: SMALLER_VOTE\"        );        if (            (support && voteAmount == proposal.forVotes[msg.sender]) ||            (!support && voteAmount == proposal.againstVotes[msg.sender])        ) {            revert(\"yVaren: SAME_VOTE\");        }        if (voteAmount > voteLockAmount[msg.sender]) {            voteLockAmount[msg.sender] = voteAmount;        }        voteLockExpiry[msg.sender] = proposal.endBlock >            voteLockExpiry[msg.sender]            ? proposal.endBlock            : voteLockExpiry[msg.sender];        if (support) {            proposal.totalForVotes = proposal.totalForVotes.<mask0>.sub(                proposal.forVotes[msg.sender]            );            proposal.forVotes[msg.sender] = voteAmount;            proposal.totalAgainstVotes = proposal.totalAgainstVotes.sub(                proposal.againstVotes[msg.sender]            );            proposal.againstVotes[msg.sender] = 0;        } else {            proposal.totalAgainstVotes = proposal            .totalAgainstVotes            .add(voteAmount)            .sub(proposal.againstVotes[msg.sender]);            proposal.againstVotes[msg.sender] = voteAmount;            proposal.totalForVotes = proposal.totalForVotes.sub(                proposal.forVotes[msg.sender]            );            proposal.forVotes[msg.sender] = 0;        }        emit VoteCast(msg.sender, id, support, voteAmount);    }"