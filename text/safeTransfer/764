"function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) public override _non_reentrant_ returns (uint _output_amount) {        require(keccak256(abi.encodePacked(tx.origin, block.number)) != _minterBlock, \"REENTR MINT-BURN\");        _output_amount = (balance().mul(_shares)).div(totalSupply());        _burn(msg.sender, _shares);        uint _withdrawalProtectionFee = vaultMaster.withdrawalProtectionFee();        if (_withdrawalProtectionFee > 0) {            uint _withdrawalProtection = _output_amount.mul(_withdrawalProtectionFee).div(10000);            _output_amount = _output_amount.sub(_withdrawalProtection);        }        uint b = basedToken.balanceOf(address(this));        if (b < _output_amount) {            uint _toWithdraw = _output_amount.sub(b);            uint _withdrawFee = IController(controller).withdraw(_toWithdraw);            uint _after = basedToken.balanceOf(address(this));            uint _diff = _after.sub(b);            if (_diff < _toWithdraw) {                _output_amount = b.add(_diff);            }            if (_withdrawFee > 0) {                _output_amount = _output_amount.sub(_withdrawFee, \"_output_amount < _withdrawFee\");            }        }        if (_output == address(basedToken)) {            require(_output_amount >= _min_output_amount, \"slippage\");            basedToken.safeTransfer(_account, _output_amount);        } else {            basedToken.<mask0>;            uint _received = basedConverter.convert(address(basedToken), _output, address(this));            require(_received >= _min_output_amount, \"slippage\");            IERC20(_output).safeTransfer(_account, _received);        }    }"