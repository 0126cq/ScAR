"function _switchPeriod() internal periodsActive {        uint256 nextPeriodID = getNextPeriodIndex();        uint256 yield = getUnrealisedYieldPerPT().mul(totalUnderlyingDeposited) / IBT_UNIT;        uint256 reinvestedYield;        if (yield > 0) {            uint256 currentPeriodIndex = getCurrentPeriodIndex();            uint256 premiums = convertUnderlyingtoIBT(premiumsTotal[currentPeriodIndex]);            uint256 performanceFee = (yield.mul(performanceFeeFactor) / UNIT).sub(premiums);            uint256 remainingYield = yield.sub(performanceFee);            yieldOfPeriod[currentPeriodIndex] = convertIBTToUnderlying(                remainingYield.mul(IBT_UNIT).div(totalUnderlyingDeposited)            );            uint256 collectedYield = remainingYield.mul(fyts[currentPeriodIndex].totalSupply()).div(                totalUnderlyingDeposited            );            reinvestedYield = remainingYield.sub(collectedYield);            futureWallet.registerExpiredFuture(collectedYield);             if (performanceFee > 0) ibt.safeTransfer(registry.getTreasuryAddress(), performanceFee);            if (remainingYield > 0) ibt.<mask0>;        } else {            futureWallet.registerExpiredFuture(0);        }        totalUnderlyingDeposited = totalUnderlyingDeposited.add(convertIBTToUnderlying(reinvestedYield));         if (!controller.isFutureSetToBeTerminated(address(this))) {            _deployNewFutureYieldToken(nextPeriodID);            emit NewPeriodStarted(nextPeriodID);        } else {            terminated = true;        }        uint256 nextPerformanceFeeFactor = controller.getNextPerformanceFeeFactor(address(this));        if (nextPerformanceFeeFactor != performanceFeeFactor) performanceFeeFactor = nextPerformanceFeeFactor;    }"