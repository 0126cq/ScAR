"function _sweepTimelockBalances(    address[] memory users  )    internal    returns (uint256)  {    address operator = _msgSender();    uint256[] memory balances = new uint256[](users.length);    uint256 totalWithdrawal;    uint256 i;    for (i = 0; i < users.length; i++) {      address user = users[i];      if (_unlockTimestamps[user] <= _currentTime()) {        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);        balances[i] = _timelockBalances[user];        delete _timelockBalances[user];      }    }    if (totalWithdrawal == 0) {      return 0;    }    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);    uint256 redeemed = _redeem(totalWithdrawal);    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());    for (i = 0; i < users.length; i++) {      if (balances[i] > 0) {        delete _unlockTimestamps[users[i]];        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);        underlyingToken.<mask0>;        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);      }    }    return totalWithdrawal;  }"