"function exit(uint256[] calldata idList) external {        if (idList.length == 0) {            return;        }        uint256 accountBalance = balanceOf[msg.sender];        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();        uint256 totalSupply_ = totalSupply;        uint256 rewardPerToken_ = _rewardPerToken(totalSupply_, lastTimeRewardApplicable_, rewardRate);        uint256 reward = _earned(msg.sender, accountBalance, rewardPerToken_, rewards[msg.sender]);        if (reward > 0) {            rewards[msg.sender] = 0;        }        rewardPerTokenStored = rewardPerToken_;        lastUpdateTime = lastTimeRewardApplicable_;        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;        balanceOf[msg.sender] = accountBalance - idList.length;        unchecked {            totalSupply = totalSupply_ - idList.length;            for (uint256 i = 0; i < idList.length; i++) {                address tokenOwner = ownerOf[idList[i]];                if (tokenOwner != msg.sender || tokenOwner == BURN_ADDRESS) {                    revert Error_NotTokenOwner();                }                ownerOf[idList[i]] = BURN_ADDRESS;            }        }        unchecked {            for (uint256 i = 0; i < idList.length; i++) {                stakeToken().safeTransferFrom(address(this), msg.sender, idList[i]);            }        }        emit Withdrawn(msg.sender, idList);        if (reward > 0) {            rewardToken().<mask0>;            emit RewardPaid(msg.sender, reward);        }    }"