"function deposit(    uint256 _amount,    uint256 _maxPrice,    address _depositor  ) external returns (uint256) {    require(_depositor != address(0), \"Invalid address\");    decayDebt();    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");    uint256 priceInUSD = bondPriceInUSD();     uint256 nativePrice = _bondPrice();    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\");     uint256 value = Treasury(treasury).valueOfToken(principle, _amount);    uint256 payout = payoutFor(value);     require(payout >= 10000000, \"Bond too small\");     require(payout <= maxPayout(), \"Bond too large\");     uint256 fee = payout.mul(terms.fee).div(10000);    uint256 profit = value.sub(payout).sub(fee);    SafeERC20.safeTransferFrom(      IERC20(principle),      msg.sender,      address(this),      _amount    );    IERC20(principle).approve(address(treasury), _amount);    Treasury(treasury).deposit(_amount, principle, profit, false);    if (fee != 0) {      SafeERC20.<mask0>;    }    totalDebt = totalDebt.add(value);    bondInfo[_depositor] = Bond({      payout: bondInfo[_depositor].payout.add(payout),      vesting: terms.vestingTerm,      lastBlock: block.number,      pricePaid: priceInUSD    });    emit BondCreated(      _amount,      payout,      block.number.add(terms.vestingTerm),      priceInUSD    );    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());    adjust();     return payout;  }"