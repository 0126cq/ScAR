"function withdraw(uint256 numberOfShares) external override nonReentrant {        require(totalSupply() > 0, \"Fund has no shares\");        require(numberOfShares > 0, \"numberOfShares must be greater than 0\");        uint256 underlyingAmountToWithdraw =            _underlyingFromShares(numberOfShares);        _burn(msg.sender, numberOfShares);        if (underlyingAmountToWithdraw > underlyingBalanceInFund()) {            uint256 missing =                underlyingAmountToWithdraw.sub(underlyingBalanceInFund());            uint256 missingCarryOver;            for (uint256 i; i < getStrategyCount(); i++) {                if (isActiveStrategy(strategyList[i])) {                    uint256 balanceBefore = underlyingBalanceInFund();                    uint256 weightage = strategies[strategyList[i]].weightage;                    uint256 missingforStrategy =                        (missing.mul(weightage).div(_totalWeightInStrategies()))                            .add(missingCarryOver);                    IStrategy(strategyList[i]).withdrawToFund(                        missingforStrategy                    );                    missingCarryOver = missingforStrategy                        .add(balanceBefore)                        .sub(underlyingBalanceInFund());                }            }            underlyingAmountToWithdraw = MathUpgradeable.min(                underlyingAmountToWithdraw,                underlyingBalanceInFund()            );            _setShouldRebalance(true);        }        uint256 withdrawalFee =            underlyingAmountToWithdraw.mul(_withdrawalFee()).div(MAX_BPS);        if (withdrawalFee > 0) {            IERC20(_underlying()).safeTransfer(                _platformRewards(),                withdrawalFee            );            underlyingAmountToWithdraw = underlyingAmountToWithdraw.sub(                withdrawalFee            );        }        IERC20(_underlying()).<mask0>;        emit Withdraw(msg.sender, underlyingAmountToWithdraw, withdrawalFee);    }"