"function closeSwap(uint256 _swapNumber) external override returns (bool) {        bytes32 swapKey = keccak256(abi.encode(msg.sender, _swapNumber));        require(swaps[swapKey].user == msg.sender, '11');        require(!swaps[swapKey].isClosed, '12');        Swap memory swap = swaps[swapKey];        (uint256 userToPay, uint256 ammToPay) = _calculateInterestAccrued(swap);        require(block.number > swap.openBlock, '13');        uint256 payout = userToPay > ammToPay ? userToPay.sub(ammToPay) : ammToPay.sub(userToPay);        uint256 supplementaryCollateral = swap.activeLiquidity;        uint256 activeLiquidityRecovered;        uint256 redeemableFunds;        if (ammToPay > userToPay) {            payout = Math.min(payout, swap.activeLiquidity);            activeLiquidityRecovered = swap.activeLiquidity.sub(payout);            redeemableFunds = swap.swapCollateral.add(supplementaryCollateral).add(payout);        }        else if (ammToPay < userToPay) {            payout = Math.min(payout, swap.swapCollateral);            activeLiquidityRecovered = swap.activeLiquidity.add(payout);            redeemableFunds = swap.swapCollateral.add(supplementaryCollateral).sub(payout);        }        else {            activeLiquidityRecovered = swap.activeLiquidity;            redeemableFunds = swap.swapCollateral.add(supplementaryCollateral);        }        totalActiveLiquidity = totalActiveLiquidity.sub(swap.activeLiquidity);        totalSwapCollateral = totalSwapCollateral.sub(swap.swapCollateral);        totalSupplementaryCollateral = totalSupplementaryCollateral.sub(supplementaryCollateral);        totalAvailableLiquidity = totalAvailableLiquidity.add(activeLiquidityRecovered);        swaps[swapKey].isClosed = true;        utilization = _calculateUtilization();        fee = _calculateFee();        IERC20(underlier).<mask0>;        emit CloseSwap(msg.sender, swap.notional, userToPay, ammToPay);        return true;    }"