"function deposit(address _token, uint256 _amount)        external        whenNotPaused        onlyRole(DEFAULT_ADMIN_ROLE)    {        uint256 amount18 = _amount *            10**(18 - ERC20Upgradeable(_token).decimals());        uint256 inAdapter = getAdapterAmount(msg.sender);        uint256 expectedAdapterAmount = getExpectedAdapterAmount(            msg.sender,            amount18        );        uint256 adapterId = ibAlluoToAdapterId.get(msg.sender);        address adapter = adapterIdsToAdapterInfo[adapterId].adapterAddress;        IERC20Upgradeable(_token).<mask0>;        if (inAdapter < expectedAdapterAmount) {            if (expectedAdapterAmount < inAdapter + amount18) {                uint256 toWallet = inAdapter + amount18 - expectedAdapterAmount;                uint256 leaveInPool = amount18 - toWallet;                IHandlerAdapter(adapter).deposit(_token, amount18, leaveInPool);            } else {                IHandlerAdapter(adapter).deposit(_token, amount18, amount18);            }        } else {            IHandlerAdapter(adapter).deposit(_token, amount18, 0);        }        WithdrawalSystem storage withdrawalSystem = ibAlluoToWithdrawalSystems[            msg.sender        ];        if (            withdrawalSystem.totalWithdrawalAmount > 0 && !withdrawalSystem.resolverTrigger        ) {            uint256 inAdapterAfterDeposit = getAdapterAmount(msg.sender);            uint256 firstInQueueAmount = withdrawalSystem                .withdrawals[withdrawalSystem.lastSatisfiedWithdrawal + 1].amount;            if (firstInQueueAmount <= inAdapterAfterDeposit) {                withdrawalSystem.resolverTrigger = true;                emit EnoughToSatisfy(                    msg.sender,                    inAdapterAfterDeposit,                    withdrawalSystem.totalWithdrawalAmount                );            }        }    }"