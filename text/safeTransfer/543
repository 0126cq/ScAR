"function withdraw(uint256 _pid, uint256 _amount) external payable nonReentrant {        PoolInfo storage pool = poolInfo[_pid];        UserInfo storage user = userInfo[_pid][msg.sender];        require(user.amount >= _amount, \"withdraw: not good\");        require(_amount > 0, \"Amount should be greator than 0\");        _transferPerformanceFee();        if(pool.bonusEndBlock < block.number) {            massUpdatePools();            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint);            pool.allocPoint = 0;        } else {            updatePool(_pid);        }        uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt);        if (pending > 0) {            require(availableRewardTokens() >= pending, \"Insufficient reward tokens\");            safeTokenTransfer(msg.sender, pending);            if(totalEarned > pending) {                totalEarned = totalEarned.sub(pending);            } else {                totalEarned = 0;            }        }        uint256 pendingReflection = user.amount.mul(pool.accReflectionPerShare).div(1e12).sub(user.reflectionDebt);        pendingReflection = _estimateDividendAmount(pendingReflection);        if (pendingReflection > 0 && hasDividend) {            if(address(reflectionToken) == address(0x0)) {                payable(msg.sender).transfer(pendingReflection);            } else {                IERC20(reflectionToken).safeTransfer(msg.sender, pendingReflection);            }            totalReflections = totalReflections.sub(pendingReflection);        }        if (_amount > 0) {            user.amount = user.amount.sub(_amount);            if (pool.withdrawFee > 0) {                uint256 withdrawFee = _amount.mul(pool.withdrawFee).div(10000);                pool.lpToken.safeTransfer(feeAddress, withdrawFee);                pool.lpToken.<mask0>;            } else {                pool.lpToken.safeTransfer(address(msg.sender), _amount);            }            _calculateTotalStaked(_pid, pool.lpToken, _amount, false);        }        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);        user.reflectionDebt = user.amount.mul(pool.accReflectionPerShare).div(1e12);        emit Withdraw(msg.sender, _pid, _amount);    }"