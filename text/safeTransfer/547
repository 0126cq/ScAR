"function withdraw(uint256 _shares)      external      nonReentrant  {      require(_shares > 0, \"withdraw must be greater than 0\");      uint256 ibalance = balanceOf(msg.sender);      require(_shares <= ibalance, \"insufficient balance\");      pool = calcPoolValueInToken();      uint256 r = (pool.mul(_shares)).div(_totalSupply);      _balances[msg.sender] = _balances[msg.sender].sub(_shares, \"redeem amount exceeds balance\");      _totalSupply = _totalSupply.sub(_shares);      emit Transfer(msg.sender, address(0), _shares);      uint256 b = IERC20(token).balanceOf(address(this));      if (b < r) {        _withdrawSome(r.sub(b));      }      if (yeldDAIInstance.checkIfPriceNeedsUpdating()) yeldDAIInstance.updatePrice();      if (checkIfRedeemableBalance()) redeemYeld();      uint256 halfProfits = (r.sub(staked[msg.sender])).div(2);      uint256 stakingProfits = daiToETH(halfProfits);      uint256 tokensAlreadyBurned = yeldToken.balanceOf(address(0));      if (tokensAlreadyBurned < maximumTokensToBurn) {        uint256 ethToSwap = stakingProfits.mul(98).div(100);        buyNBurn(ethToSwap);        uint256 retirementYeld = stakingProfits.mul(2).div(100);        retirementYeldTreasury.transfer(retirementYeld);      } else {        uint256 retirementYeld = stakingProfits;        retirementYeldTreasury.transfer(retirementYeld);      }      IERC20(token).<mask0>;      pool = calcPoolValueInToken();  }"