"function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);        address from = address(uint160(prevOwnershipPacked));        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);        if (approvalCheck) {            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();        }        <mask0>;        assembly {            if approvedAddress {                sstore(approvedAddressSlot, 0)            }        }        unchecked {            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;            _packedOwnerships[tokenId] = _packOwnershipData(                from,                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)            );            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {                uint256 nextTokenId = tokenId + 1;                if (_packedOwnerships[nextTokenId] == 0) {                    if (nextTokenId != _currentIndex) {                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;                    }                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }"