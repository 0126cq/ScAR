"function _transfer(        address from,        address to,        uint256 tokenId    ) private {        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();        address approvedAddress = ERC721AStorage.layout()._tokenApprovals[tokenId];        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||            isApprovedForAll(from, _msgSenderERC721A()) ||            approvedAddress == _msgSenderERC721A());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (_addressToUint256(to) == 0) revert TransferToZeroAddress();        <mask0>;        if (_addressToUint256(approvedAddress) != 0) {            delete ERC721AStorage.layout()._tokenApprovals[tokenId];        }        unchecked {            --ERC721AStorage.layout()._packedAddressData[from];             ++ERC721AStorage.layout()._packedAddressData[to];             ERC721AStorage.layout()._packedOwnerships[tokenId] =                _addressToUint256(to) |                (block.timestamp << BITPOS_START_TIMESTAMP) |                BITMASK_NEXT_INITIALIZED;            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {                uint256 nextTokenId = tokenId + 1;                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;                    }                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }"