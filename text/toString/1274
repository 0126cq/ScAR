"function mint(    uint256[] calldata _quantities,    bytes32[][] calldata _proofs,    uint256[] calldata _allotments,    uint256[] calldata _allowlistIds  ) external payable nonReentrant {    require(isTrustedForwarder(msg.sender) || _msgSender() == tx.origin, \"BOT\");    uint256 _cost = 0;    uint256 _quantity = 0;    for(uint256 i = 0; i < _quantities.length; i++) {      _quantity += _quantities[i];      revertOnInactiveList(_allowlistIds[i]);      revertOnAllocationCheckFailure(        msg.sender,        _allowlistIds[i],        mintedByAllowlist[msg.sender][_allowlistIds[i]],        _quantities[i],        _allotments[i],        _proofs[i]      );      _cost += allowlists.lists[_allowlistIds[i]].price * _quantities[i];    }    require(nextTokenId + _quantity - 1 <= config.mintConfig.maxSupply, \"Exceeded max supply.\");    if(_cost > msg.value) revert InsufficientFunds();    (bool sent, bytes memory data) = receivingWallet.call{value: msg.value}(\"\");    string memory tokensMinted = \"\";    unchecked {        for (uint i = nextTokenId; i < nextTokenId + _quantity; i++) {            tokensMinted = string(abi.encodePacked(tokensMinted, i.<mask0>, \",\"));        }        for (uint i = 0; i < _quantities.length; i++) {          mintedByAllowlist[address(msg.sender)][_allowlistIds[i]] += _quantities[i];        }        minted[address(msg.sender)] += _quantity;        nextTokenId += _quantity;        _safeMint(msg.sender, _quantity);    }    emit Minted(msg.sender, tokensMinted);  }"