"function mintToken(address reciver, string[] memory optionalURI, uint256[] memory optionalId, address payToken,                        uint256 payAmount, uint256 nonce, bytes memory data)        public        payable        returns (uint256[] memory)    {        uint256 count = 1;        if(allowDirectMint == false){            count = optionalURI.length;        } else {            count = nonce;        }        uint256[] memory tokenIds = new uint256[](count);        if(maxSupply != 0){            require(supply + (count - 1) < maxSupply, \"Max supply reached\");        }        if(msg.value > 0 && payToken == address(0)){            payAmount = msg.value;        }            if(msg.sender != moderator && msg.sender != creator && allowDirectMint == false){                lognonce(nonce);                require(verifyMint(moderator, reciver, payToken, payAmount, optionalURI, optionalId, nonce, data), \"Not allowed\");            }        if(drop > 0){            require(supply + count <= drop, \"Drop limit\");        }        if(cost > 0 && msg.sender != moderator && msg.sender != creator ){            require(payAmount >= cost,\"Amount send underpriced\");        }        if(onlyWhiteListed == true){            require(whiteList[msg.sender] == true,\"Not whitelisted\");        }        if(maxMint > 0){            require((balanceOf(msg.sender) + count) <= maxMint, \"maxMint Limit\");        }        distribShares(creator, payToken, payAmount);        for (uint256 i = 0; i < count; i++) {            supply += 1;            uint256 tmpid = supply;             if(allowDirectMint == false){                if( optionalId[i] > 0 ){                                    tmpid = optionalId[i];                }            }            if(_exists(tmpid) == false){                tokenIds[i] = tmpid;                _mint(reciver, tmpid);                if(allowDirectMint == false){                                       _setTokenURI(tmpid, optionalURI[i]);                } else {                    _setTokenURI(tmpid, tmpid.<mask0>);                }                lastTransact[tmpid]=block.timestamp;            } else {                revert(\"TokenId Used\");            }        }        emit nftMinted(reciver, count, payToken, payAmount, tokenIds);        return tokenIds;    }"