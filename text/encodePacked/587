"function withdraw(        IERC20Mintable fromToken,        IERC20Mintable toToken,        uint256 fromChain,        address fromAddress,        uint256 withdrawAmount,        bytes32 transactionHash,        bytes memory signature    ) public nonReentrant {        address toAddress = address(msg.sender);        uint256 toChain = _currentChain();        (Bridge memory bridge, uint256 index) = _resolveBridgeBySourceAndTarget(toToken, fromToken, toChain, fromChain);        require(bridge.bridgeStatus == BridgeStatus.Enabled, \"CrossChainBridge: bridge is not enabled\");        require(!_proofs[transactionHash], \"CrossChainBridge: proof is already used\");        _proofs[transactionHash] = true;        bytes32 hash = keccak256(abi.<mask0>);        require(ECDSAUpgradeable.recover(hash, signature) == _operator, \"CrossChainBridge: bad signature\");        if (bridge.bridgeType == BridgeType.Lockable) {            _withdrawLockable(bridge, toAddress, withdrawAmount);        } else if (bridge.bridgeType == BridgeType.Mintable) {            _withdrawMintable(bridge, toAddress, withdrawAmount);        } else {            revert(\"CrossChainBridge: incorrect bridge type\");        }        emit CrossChainWithdraw({        bridgeIndex : index,        fromToken : address(fromToken),        toToken : address(toToken),        fromChain : fromChain,        toChain : toChain,        fromAddress : fromAddress,        toAddress : toAddress,        withdrawAmount : withdrawAmount,        depositTxHash : transactionHash        });    }"