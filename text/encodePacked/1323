"function matchOrder(    uint8 v,    bytes32 r,    bytes32 s,    address[4] calldata _addressArgs,    uint[6] calldata _uintArgs  ) external payable {    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");    bytes32 hashStruct = keccak256(      abi.encode(          keccak256(\"matchorder(address contractaddress,uint tokenid,uint ethamt,uint deadline,uint feeamt,address signer,uint salt,address royaltyaddress,uint royaltyamt)\"),          _addressArgs[0],          _uintArgs[0],          _uintArgs[1],          _uintArgs[2],          _uintArgs[3],          _addressArgs[1],          _uintArgs[4],          _addressArgs[2],          _uintArgs[5]        )    );    bytes32 hash = keccak256(abi.<mask0>);    address signaturesigner = ecrecover(hash, v, r, s);    require(signaturesigner == _addressArgs[1], \"invalid signature\");    require(msg.value == _uintArgs[1], \"wrong eth amt\");    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");    orderhashes[hashStruct]=true;     ERC721 nftcontract = ERC721(_addressArgs[0]);    nftcontract.safeTransferFrom(_addressArgs[1],msg.sender ,_uintArgs[0]);     if (_uintArgs[3]>0){      owner.transfer(_uintArgs[3]);     }    if (_uintArgs[5]>0){      payable(_addressArgs[2]).transfer(_uintArgs[5]);     }    payable(_addressArgs[1]).transfer(msg.value-_uintArgs[3]-_uintArgs[5]);     emit Orderfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] , _addressArgs[3] ,_uintArgs[3],_uintArgs[5],_addressArgs[2]);  }"