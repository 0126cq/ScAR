"function solveQuest(uint256 questTokenId, uint256 lootIdx, uint256 variantIdx, uint256 providedLootTokenId) external whenNotPaused {        require(_msgSender() == lootContract.ownerOf(providedLootTokenId), \"Can only apply own(ed) Loot\");        getRequiredLootIdxMask(questTokenId) & (1 << lootIdx);        require(requiredLootResolutionStatus[questTokenId / 32] & ((1 << lootIdx) << (8 * (questTokenId % 32))) == 0, \"Loot must still be missing\");        require(usedUpLoot[providedLootTokenId / 32] & ((1 << lootIdx) << (8 * (providedLootTokenId % 32))) == 0, \"Provided Loot was used before\");        if(((requiredLootResolutionStatus[questTokenId / 32] >> (8 * (questTokenId % 32)))) & 0xff == 0) {            require(_msgSender() == ownerOf(questTokenId), \"Only owner can begin quest\");            emit QuestStarted(_msgSender(), questTokenId);        }        string memory providedLoot = lookupLootName(providedLootTokenId, lootIdx);        string memory requiredLoot = getRequiredLoot(questTokenId, lootIdx, variantIdx);        require(keccak256(abi.encodePacked(providedLoot)) == keccak256(abi.<mask0>), \"Matching loot must be provided\");        requiredLootResolutionStatus[questTokenId / 32] |= ((1 << lootIdx) << (8 * (questTokenId % 32)));         usedUpLoot[providedLootTokenId / 32] |= ((1 << lootIdx) << (8 * (providedLootTokenId % 32)));         emit QuestContributed(_msgSender(), questTokenId, providedLootTokenId, lootIdx);        if(isQuestSolved(questTokenId)) {            emit QuestSolved(questTokenId);        }        uint256 reward = questToRewardAmountMap[questTokenId];        if(reward > 0) {            delete questToRewardAmountMap[questTokenId];            delete questToRewardSourceMap[questTokenId];            emit RewardClaimed(_msgSender(), questTokenId, reward);            payable(_msgSender()).transfer(reward);        }    }"