"function setConfig(    address[] calldata _signers,    address[] calldata _transmitters,    uint8 _threshold,    uint64 _encodedConfigVersion,    bytes calldata _encoded  )    external    checkConfigValid(_signers.length, _transmitters.length, _threshold)    onlyOwner()  {    while (s_signers.length != 0) {       uint lastIdx = s_signers.length - 1;      address signer = s_signers[lastIdx];      address transmitter = s_transmitters[lastIdx];      payOracle(transmitter);      delete s_oracles[signer];      delete s_oracles[transmitter];      s_signers.<mask0>;      s_transmitters.pop();    }    for (uint i = 0; i < _signers.length; i++) {       require(        s_oracles[_signers[i]].role == Role.Unset,        \"repeated signer address\"      );      s_oracles[_signers[i]] = Oracle(uint8(i), Role.Signer);      require(s_payees[_transmitters[i]] != address(0), \"payee must be set\");      require(        s_oracles[_transmitters[i]].role == Role.Unset,        \"repeated transmitter address\"      );      s_oracles[_transmitters[i]] = Oracle(uint8(i), Role.Transmitter);      s_signers.push(_signers[i]);      s_transmitters.push(_transmitters[i]);    }    s_hotVars.threshold = _threshold;    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;    s_latestConfigBlockNumber = uint32(block.number);    s_configCount += 1;    uint64 configCount = s_configCount;    {      s_hotVars.latestConfigDigest = configDigestFromConfigData(        address(this),        configCount,        _signers,        _transmitters,        _threshold,        _encodedConfigVersion,        _encoded      );      s_hotVars.latestEpochAndRound = 0;    }    emit ConfigSet(      previousConfigBlockNumber,      configCount,      _signers,      _transmitters,      _threshold,      _encodedConfigVersion,      _encoded    );  }"