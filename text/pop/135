"function unstake721(address contractAddress, uint256[] memory tokenIds) public nonReentrant {      require(contractAddress != address(0) && contractAddress == address(ApeNft) || contractAddress == address(TreasuryNft) || contractAddress == address(BreedingNft), \"Unknown contract or staking is not yet enabled for this NFT\");      ContractTypes contractType = _contractTypes[contractAddress];      Staker storage user = _stakers[_msgSender()];      uint256 newYield = user.currentYield;      for (uint256 i; i < tokenIds.length; i++) {        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == address(this), \"Not the owner\");        _ownerOfToken[contractAddress][tokenIds[i]] = address(0);        if (user.currentYield != 0) {            if (contractType == ContractTypes.APE){                uint256 ape_loot = stakerApeLoot[_msgSender()][tokenIds[i]];                uint256 tokenYield = getApeLootTokenYield(tokenIds[i], ape_loot);                newYield -= tokenYield;                if (ape_loot > 0){                  IERC721(address(LootNft)).safeTransferFrom(address(this), _msgSender(), ape_loot);                  _ownerOfToken[address(LootNft)][ape_loot] = address(0);                }            } else {                uint256 tokenYield = getTokenYield(contractAddress, tokenIds[i]);                newYield -= tokenYield;            }        }        if (contractType == ContractTypes.APE) {          user.stakedAPE = _prepareForDeletion(user.stakedAPE, tokenIds[i]);          user.stakedAPE.pop();          stakerApeLoot[_msgSender()][tokenIds[i]] = 0;        }        if (contractType == ContractTypes.TREASURY) {          user.stakedTREASURY = _prepareForDeletion(user.stakedTREASURY, tokenIds[i]);          user.stakedTREASURY.<mask0>;        }        if (contractType == ContractTypes.BREEDING) {          user.stakedBREEDING = _prepareForDeletion(user.stakedBREEDING, tokenIds[i]);          user.stakedBREEDING.pop();        }        IERC721(contractAddress).safeTransferFrom(address(this), _msgSender(), tokenIds[i]);      }      if (user.stakedAPE.length == 0 && user.stakedTREASURY.length == 0 && user.stakedPET.length == 0 && user.stakedBREEDING.length == 0) {        newYield = 0;      }      accumulate(_msgSender());      user.currentYield = newYield;      emit Unstake721(_msgSender(), contractAddress, tokenIds.length);    }"