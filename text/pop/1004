"function _claimFromMiner(uint16 tokenId, bool unstake) internal returns (uint owed) {        Stake memory stake = goldMinerStake[msg.sender][goldMinerIndices[tokenId]];        require(stake.owner == msg.sender, \"This NTF does not belong to address\");        require(!(unstake && block.timestamp - stake.value < MINIMUM_TIME_TO_EXIT), \"Need to wait 2 days since last claim\");        if (totalGoldEarned < MAXIMUM_GLOBAL_GOLD) {            owed = ((block.timestamp - stake.value) * DAILY_GOLD_RATE) / 1 days;        } else if (stake.value > lastClaimTimestamp) {            owed = 0;         } else {            owed = ((lastClaimTimestamp - stake.value) * DAILY_GOLD_RATE) / 1 days;         }        if (unstake) {            if (getSomeRandomNumber(tokenId, 100) <= 50) {                _payTax(owed);                owed = 0;            }            updateRandomIndex();            totalGoldMinerStaked -= 1;            Stake memory lastStake = goldMinerStake[msg.sender][goldMinerStake[msg.sender].length - 1];            goldMinerStake[msg.sender][goldMinerIndices[tokenId]] = lastStake;            goldMinerIndices[lastStake.tokenId] = goldMinerIndices[tokenId];            goldMinerStake[msg.sender].<mask0>;            delete goldMinerIndices[tokenId];            goldHunter.safeTransferFrom(address(this), msg.sender, tokenId, \"\");        } else {            _payTax((owed * TAX_PERCENTAGE) / 100);             owed = (owed * (100 - TAX_PERCENTAGE)) / 100;            uint80 timestamp = uint80(block.timestamp);            goldMinerStake[msg.sender][goldMinerIndices[tokenId]] = Stake({                owner: msg.sender,                tokenId: uint16(tokenId),                value: timestamp            });         }        emit GoldMinerClaimed(tokenId, owed, unstake);    }"