"function _claimNftFromRegister(uint256 tokenId, bool unstake) internal returns (uint256 rewards) {        NftInfo storage stake = register[tokenId];        require(stake.owner == _msgSender(), \"BIOAPES: SHOULD BE OWNER\");        require(block.timestamp >= stake.lockTime, \"BIOAPES: CAN NOT CLAIM YET\");        require(stake.tokenId == tokenId, \"Not Staked\");        if (stake.tier == 30) {            rewards = uint256((block.timestamp - stake.stakeTime) * rewardPerDay30 / 1 days * (10 ** 9));        } else if (stake.tier == 60) {            rewards = uint256((block.timestamp - stake.stakeTime) * rewardPerDay60 / 1 days * (10 ** 9));        } else if (stake.tier == 90) {            rewards = uint256((block.timestamp - stake.stakeTime) * rewardPerDay90 / 1 days * (10 ** 9));        } else {            require(false, \"Invalid Tier\");        }        if (unstake) {            bioapes.safeTransferFrom(address(this), _msgSender(), tokenId);             delete register[tokenId];            for (uint i = 0; i < stakedTokens[_msgSender()].length; i++) {                if (stakedTokens[_msgSender()][i].tokenId == tokenId) {                    for (uint j = i; j < stakedTokens[_msgSender()].length - 1; j++) {                        stakedTokens[_msgSender()][j] = stakedTokens[_msgSender()][j + 1];                    }                    stakedTokens[_msgSender()].<mask0>;                }            }            totalNFTStaked -= 1;        } else {            stake.stakeTime = block.timestamp;            stake.lockTime = block.timestamp + register[tokenId].tier * 1 days;        }        emit BCTClaimed(tokenId, rewards, unstake);    }"