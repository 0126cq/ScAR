"function claimManyFromCoral(uint16[] calldata tokenIds, bool unstake) external whenNotPaused _updateEarnings nonReentrant {    require(tx.origin == _msgSender() || _msgSender() == address(sharkGame), \"Only EOA\");    uint256 owed = 0;    for (uint i = 0; i < tokenIds.length; i++) {      uint16 tokenId = tokenIds[i];      Stake memory stake = coral[tokenId];      require(stake.owner != address(0), \"Token is not staked\");      uint256 tokenOwed = this.calculateRewards(stake);      ISharks.SGTokenType tokenType = sharksNft.getTokenType(tokenId);      if (unstake) {        console.log(tokenId);        address recipient = _msgSender();        if (tokenType == ISharks.SGTokenType.MINNOW) {          if (randomizer.random() & 1 == 1) {            uint256 orcasSteal = tokenOwed * 3 / 10;            _payTax(orcasSteal, ISharks.SGTokenType.ORCA);            _payTax(tokenOwed - orcasSteal, ISharks.SGTokenType.SHARK);            tokenOwed = 0;          }        } else if (tokenType == ISharks.SGTokenType.SHARK) {          uint256 seed = randomizer.random();          if (orcasEnabled && (seed & 0xFFFF) % 100 < SHARK_RISK_CHANCE) {            recipient = this.randomTokenOwner(ISharks.SGTokenType.ORCA, seed);          }        }        delete coral[tokenId];        if (coralByType[tokenType].length > 1) {          coralByType[tokenType][coralByTypeIndex[tokenId]] = coralByType[tokenType][coralByType[tokenType].length - 1];        }        coralByType[tokenType].<mask0>;        numStaked[tokenType] -= 1;        sharksNft.safeTransferFrom(address(this), recipient, tokenId, \"\");      } else {        if (tokenType == ISharks.SGTokenType.MINNOW) {          uint256 sharksSteal = tokenOwed * MINNOW_CLAIM_TAX / 100;          _payTax(sharksSteal, ISharks.SGTokenType.SHARK);          tokenOwed -= sharksSteal;        } else if (tokenType == ISharks.SGTokenType.SHARK && orcasEnabled) {          uint256 orcasSteal = tokenOwed * SHARK_CLAIM_TAX / 100;          _payTax(orcasSteal, ISharks.SGTokenType.ORCA);          tokenOwed -= orcasSteal;        }        coral[tokenId] = Stake({          owner: _msgSender(),          tokenId: uint16(tokenId),          value: uint80(chumStolen[uint8(tokenType)]),          timestamp: block.timestamp        });       }      owed += tokenOwed;      emit TokenClaimed(tokenId, unstake, tokenType, owed);    }    chumToken.updateOriginAccess();    if (owed == 0) {      return;    }    chumToken.mint(_msgSender(), owed);  }"