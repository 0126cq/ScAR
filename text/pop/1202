"function withdrawNFT(uint[] memory tokenIds_) public onlySender {        address _user = msg.sender;        for (uint256 i = 0; i < tokenIds_.length; i++) {            require(                tokenOwner[tokenIds_[i]] == _user,                \"Cannot withdraw unowned NFT!\"            );            Stake memory _stake = tokenIdToStake[tokenIds_[i]];            require(                _stake.cooldown < block.timestamp,                \"Cooldown: Must wait for cooldown period before withdrawing!\"            );            claimStake(tokenIds_[i]);            Staker storage _staker = stakers[_user];             if (--_staker.stakeCount > 0) {                 _staker.stakedTokens[getIndex(tokenIds_[i], _staker.stakedTokens)] = _staker.stakedTokens[_staker.stakedTokens.length - 1];                _staker.stakedTokens.<mask0>;                delete _stake;            } else {                delete stakers[_user];            }            delete tokenOwner[tokenIds_[i]];            stakedTotal--;            PassiveStake storage _passiveStake = passiveStakes[tokenIds_[i]];            _passiveStake.claimed = (block.timestamp - _passiveStake.since) * passiveRewardPerHour / 1 hours;        }        address[] memory _userToArr;        for (uint i = 0; i < tokenIds_.length; i++) {            _userToArr[i] = _user;        }         IExternalNft(contractAddr).resurrect(tokenIds_, _userToArr);        emit Unstaked(_userToArr, tokenIds_);    }"