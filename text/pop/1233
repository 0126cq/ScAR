"function redeemToken(uint256 tokenId, bool searchAndRemoveVaultId) external nonReentrant {        LibDiamond.AppStorage storage _as = LibDiamond.appStorage();        uint64 vaultId = _as.vaultTokens[tokenId];        require(ownerOf(tokenId) == msg.sender, \"E1\");        require(isVaultSoldNFT(vaultId), \"E2\");        address payable assetsHolder = _as.assetsHolders[vaultId];        LibDiamond.Vault storage vault = _as.vaults[vaultId];        uint24 numberOfParticipants = _as.vaultsExtensions[vaultId].numberOfParticipants;        for (uint256 i; i < numberOfParticipants;) {            LibDiamond.Participant storage participant = _as.vaultParticipants[vaultId][i];            if (participant.partialNFTVaultTokenId == tokenId) {                _burn(tokenId);                uint256 percentage = participant.ownership;                uint256 salePriceDeductingFees = vault.netSalePrice / 100;                uint256 profits = salePriceDeductingFees * percentage / 1e18;                uint256 stakingFee = participant.collectorOwner != address(0) ? 0 : profits * LibDiamond.STAKING_FEE / LibDiamond.PERCENTAGE_DENOMINATOR;                uint256 liquidityFee = participant.collectorOwner != address(0) ? 0 : profits * LibDiamond.LIQUIDITY_FEE / LibDiamond.PERCENTAGE_DENOMINATOR;                IAssetsHolderImpl(assetsHolder).sendValue(                    payable(participant.participant),                    profits - stakingFee - liquidityFee                );                if (stakingFee > 0) {                    IAssetsHolderImpl(assetsHolder).sendValue(payable(_as.stakingWallet), stakingFee);                }                if (liquidityFee > 0) {                    IAssetsHolderImpl(assetsHolder).sendValue(payable(_as.liquidityWallet), liquidityFee);                }                if (participant.collectorOwner != address(0)) {                    IAssetsHolderImpl(assetsHolder).transferToken(                        false,                        participant.collectorOwner,                        address(LibDiamond.THE_COLLECTORS),                        participant.stakedCollectorTokenId                    );                }                if (searchAndRemoveVaultId) {                    uint64[] storage vaults = _as.collectionsVaults[vault.collection];                    for (uint256 j; j < vaults.length; j++) {                        if (vaults[j] == vaultId) {                            vaults[j] = vaults[vaults.length - 1];                            vaults.<mask0>;                            break;                        }                    }                }                emit VaultTokenRedeemed(vaultId, participant.participant, tokenId);                delete _as.vaultTokens[tokenId];                break;            }            unchecked {                ++i;            }        }    }"