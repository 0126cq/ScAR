"function _rollToNextOption(        uint256 lastQueuedWithdrawAmount,        uint256 currentQueuedWithdrawShares    ) internal returns (address, uint256) {        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");        address newOption = optionState.nextOption;        require(newOption != address(0), \"!nextOption\");        (            uint256 newLockedBalanceInETH,            uint256 queuedWithdrawAmount,            uint256 newPricePerShare,            uint256 mintShares,            uint256 performanceFeeInAsset,            uint256 totalVaultFee        ) =            VaultLifecycle.rollover(                vaultState,                VaultLifecycle.RolloverParams(                    vaultParams.decimals,                    totalBalance(),                    totalSupply(),                    lastQueuedWithdrawAmount,                    performanceFee,                    managementFee,                    currentQueuedWithdrawShares                )            );        optionState.currentOption = newOption;        optionState.nextOption = address(0);        {            address vaultFeeRecipient = feeRecipient;            address collateral = address(collateralToken);            uint256 currentRound = vaultState.round;            roundPricePerShare[currentRound] = newPricePerShare;            VaultLifecycleSTETH.wrapToYieldToken(WETH, collateral, STETH);            emit CollectVaultFees(                performanceFeeInAsset,                totalVaultFee,                currentRound,                vaultFeeRecipient            );            vaultState.totalPending = 0;            vaultState.round = uint16(currentRound + 1);            ShareMath.assertUint104(newLockedBalanceInETH);            vaultState.lockedAmount = uint104(newLockedBalanceInETH);            <mask0>;            if (totalVaultFee > 0) {                VaultLifecycleSTETH.withdrawYieldAndBaseToken(                    collateral,                    WETH,                    vaultFeeRecipient,                    totalVaultFee                );            }        }        return (newOption, queuedWithdrawAmount);    }"