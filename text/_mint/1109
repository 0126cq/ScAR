"function deposit(        uint256 deposit0,        uint256 deposit1,        address to    ) external override returns (uint256 shares) {        require(deposit0 > 0 || deposit1 > 0, \"deposits must be nonzero\");        require(deposit0 <= deposit0Max && deposit1 <= deposit1Max, \"deposits must be less than maximum amounts\");        require(to != address(0) && to != address(this), \"to\");        require(!whitelisted || list[msg.sender], \"must be on the list\");        (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);        if (baseLiquidity > 0) {            pool.burn(baseLower, baseUpper, 0);        }        (uint128 limitLiquidity,,)  = _position(limitLower, limitUpper);        if (limitLiquidity > 0) {            pool.burn(limitLower, limitUpper, 0);        }        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));        (uint256 pool0, uint256 pool1) = getTotalAmounts();        uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);        shares = deposit1.add(deposit0PricedInToken1);        if (deposit0 > 0) {          token0.safeTransferFrom(msg.sender, address(this), deposit0);        }        if (deposit1 > 0) {          token1.safeTransferFrom(msg.sender, address(this), deposit1);        }        if (totalSupply() != 0) {          uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);          shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));        }        <mask0>;        emit Deposit(msg.sender, to, shares, deposit0, deposit1);        require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, \"maxTotalSupply\");    }"