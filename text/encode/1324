"function executeActionWithAtomicBatchCalls(    Call[] memory calls,    uint256 minimumActionGas,    bytes memory userSignature,    bytes memory dharmaSignature  ) public returns (bool[] memory ok, bytes[] memory returnData) {    for (uint256 i = 0; i < calls.length; i++) {      _ensureValidGenericCallTarget(calls[i].to);    }    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(      ActionType.GenericAtomicBatch,      abi.<mask0>,      minimumActionGas,      userSignature,      dharmaSignature    );    ok = new bool[](calls.length);    returnData = new bytes[](calls.length);    _selfCallContext = this.executeActionWithAtomicBatchCalls.selector;    (bool externalOk, bytes memory rawCallResults) = address(this).call(      abi.encodeWithSelector(        this._executeActionWithAtomicBatchCallsAtomic.selector, calls      )    );    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));    for (uint256 i = 0; i < callResults.length; i++) {      Call memory currentCall = calls[i];      ok[i] = callResults[i].ok;      returnData[i] = callResults[i].returnData;      if (callResults[i].ok) {        emit CallSuccess(          actionID,          !externalOk,           nonce,          currentCall.to,          currentCall.data,          callResults[i].returnData        );      } else {        emit CallFailure(          actionID,          nonce,          currentCall.to,          currentCall.data,          _decodeRevertReason(callResults[i].returnData)        );        break;      }    }  }"