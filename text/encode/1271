"function privateMint(address user, uint amount, uint8 v, bytes32 r, bytes32 s, bool stake) external payable discountCHI(amount * 5) {        require(tx.origin == msg.sender, \"Only EOA\");        require(privateSaleIsEnabled, \"Private sale must be enabled\");        require(0 < amount && amount <= maxMint, \"Invalid amount to mint\");        require(_availableTokens.length >= amount, \"All tokens for this Phase are already sold\");        require(mintPrice * amount == msg.value, \"Invalid payment amount\");        bytes32 domainSeparator = keccak256(abi.<mask0>);        bytes32 structHash = keccak256(abi.encode(MINT_TYPEHASH, user, amount));        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));        address signatory = ecrecover(digest, v, r, s);        require(signatory == admin, \"Invalid signatory\");        uint _tokensMinted = tokensMinted;        uint16[] memory tokenIds = stake ? new uint16[](amount) : new uint16[](0);        for (uint i = 0; i < amount; i++) {            uint16 tokenId = _getTokenToBeMinted();            if (isHunter(tokenId)) {                hunterMinted += 1;            }            if (!stake) {                _safeMint(msg.sender, tokenId);            } else {                _safeMint(address(forest), tokenId);                tokenIds[i] = tokenId;            }            _tokensMinted++;        }        tokensMinted = _tokensMinted;        if (stake) {            forest.addTokensToStake(msg.sender, tokenIds);        }        emit PrivateMint(msg.sender, amount);    }"