"function rebalance() external override onlyGovernance nonReentrant checkDeviation updateVault(address(0))  {        pool.burnAllLiquidity(tickLower, tickUpper);        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();        PoolVariables.Info memory cache =             PoolVariables.Info(0, 0, 0, 0, 0, 0, 0);        int24 baseThreshold = tickSpacing * ISorbettoStrategy(strategy).tickRangeMultiplier();        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);        cache.amount0Desired = _balance0();        cache.amount1Desired = _balance1();        emit Snapshot(cache.amount0Desired, cache.amount1Desired);        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);        int256 amountSpecified =             zeroForOne                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2));         uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(ISorbettoStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);        pool.swap(            address(this),            zeroForOne,            amountSpecified,            sqrtPriceLimitX96,            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))        );        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();        cache.amount0Desired = _balance0();        cache.amount1Desired = _balance1();        emit Snapshot(cache.amount0Desired, cache.amount1Desired);        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);        (cache.amount0, cache.amount1) = pool.mint(            address(this),            tickLower,            tickUpper,            cache.liquidity,            abi.<mask0>);        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);    }"