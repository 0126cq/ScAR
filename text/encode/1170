"function purchasePresale(        uint256 quantity,        uint256 maxQuantity,        uint256 pricePerToken,        bytes32[] calldata merkleProof    )        external        payable        nonReentrant        canMintTokens(quantity)        onlyPresaleActive        returns (uint256)    {        if (            !MerkleProofUpgradeable.verify(                merkleProof,                salesConfig.presaleMerkleRoot,                keccak256(                    abi.<mask0>                )            )        ) {            revert Presale_MerkleNotApproved();        }        if (msg.value != pricePerToken * quantity) {            revert Purchase_WrongPrice(pricePerToken * quantity);        }        presaleMintsByAddress[_msgSender()] += quantity;        if (presaleMintsByAddress[_msgSender()] > maxQuantity) {            revert Presale_TooManyForAddress();        }        _mintNFTs(_msgSender(), quantity);        uint256 firstMintedTokenId = _lastMintedTokenId() - quantity;        emit IERC721Drop.Sale({            to: _msgSender(),            quantity: quantity,            pricePerToken: pricePerToken,            firstPurchasedTokenId: firstMintedTokenId        });        return firstMintedTokenId;    }"