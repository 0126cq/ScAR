"function tokamakStaking(address _layer2, uint256 stakeAmount)        external        override        lock        nonZero(stakeRegistry)        nonZero(_layer2)        onlyClosed    {        require(block.number <= endBlock, \"TokamakStaker:period end\");        require(stakeAmount > 0, \"TokamakStaker:stakeAmount is zero\");        defiStatus = uint256(LibTokenStake1.DefiStatus.DEPOSITED);        checkTokamak();        uint256 globalWithdrawalDelay =            IIIDepositManager(depositManager).globalWithdrawalDelay();        require(            block.number < endBlock.sub(globalWithdrawalDelay),            \"TokamakStaker:period(withdrawalDelay) end\"        );        if (tokamakLayer2 == address(0)) tokamakLayer2 = _layer2;        else {            if (                IISeigManager(seigManager).stakeOf(                    tokamakLayer2,                    address(this)                ) >                0 ||                IIIDepositManager(depositManager).pendingUnstaked(                    tokamakLayer2,                    address(this)                ) >                0            ) {                require(                    tokamakLayer2 == _layer2,                    \"TokamakStaker:different layer\"                );            } else {                if (tokamakLayer2 != _layer2) tokamakLayer2 = _layer2;            }        }        require(            IERC20BASE2(ton).balanceOf(address(this)) >= stakeAmount,            \"TokamakStaker: ton balance is insufficient\"        );        toTokamak = toTokamak.add(stakeAmount);        bytes memory data = abi.<mask0>;        require(            ITON(ton).approveAndCall(wton, stakeAmount, data),            \"TokamakStaker:approveAndCall fail\"        );        emit TokamakStaked(_layer2, stakeAmount);    }"