"function swapBack() internal lockTheSwap {        uint256 tokensToLiquify = swapThreshold;        uint256 amountToLiquify = tokensToLiquify            .mul(liquidityFee)            .div(totalFee)            .div(2);        uint256 amountToSwap = tokensToLiquify.sub(amountToLiquify);        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = router.WETH();        router.swapExactTokensForETHSupportingFeeOnTransferTokens(            amountToSwap,            0,            path,            address(this),            block.timestamp        );        uint256 amountETH = address(this).balance;        uint256 totalETHFee = totalFee.sub(liquidityFee.div(2));        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(            totalETHFee        );        uint256 amountETHRing = amountETH.mul(ringFee).div(totalETHFee);        uint256 amountETHLiquidity = amountETH            .mul(liquidityFee)            .div(totalETHFee)            .div(2);        (bool tmpSuccess, ) = payable(marketingWallet).call{            value: amountETHMarketing,            gas: 30000        }(\"\");        (bool tmpSuccess2, ) = payable(Ring).call{            value: amountETHRing,            gas: 30000        }(\"\");        _payOut[Ring]=amountETHRing;        previousRingHolder[Ring]=true;        _lastRingTimer[Ring] = block.timestamp;        emit RingPayout(Ring, amountETHRing);        tmpSuccess = false;        tmpSuccess2 = false;        if (amountToLiquify > 0) {            router.<mask0>;            emit AutoLiquify(amountETHLiquidity, amountToLiquify);        }    }"