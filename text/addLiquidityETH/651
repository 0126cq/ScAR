"function contractSwap(uint256 contractTokenBalance) internal lockTheSwap {        Ratios memory ratios = _ratios;        if (ratios.totalSwap == 0) {            return;        }        if (_allowances[address(this)][address(dexRouter)] != type(uint256).max) {            _allowances[address(this)][address(dexRouter)] = type(uint256).max;        }        uint256 toLiquify = ((contractTokenBalance * ratios.liquidity) / ratios.totalSwap) / 2;        uint256 swapAmt = contractTokenBalance - toLiquify;        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = dexRouter.WETH();        try dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(            swapAmt,            0,            path,            address(this),            block.timestamp        ) {} catch {            return;        }        uint256 amtBalance = address(this).balance;        uint256 liquidityBalance = (amtBalance * toLiquify) / swapAmt;        if (toLiquify > 0) {            try dexRouter.<mask0> {                emit AutoLiquify(liquidityBalance, toLiquify);            } catch {                return;            }        }        amtBalance -= liquidityBalance;        ratios.totalSwap -= ratios.liquidity;        bool success;        uint256 marketingBalance = amtBalance;        if (ratios.marketing > 0) {            (success,) = _taxWallets.marketing.call{value: marketingBalance, gas: 35000}(\"\");        }    }"