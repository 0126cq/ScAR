"function openTrading(address[] memory lockSells, uint duration) external onlyOwner() {        require(!tradingOpen, \"trading is already open\");        IUniswapV2Router02 _uniswapV2Router;       if(block.chainid == 56) {            _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);        }        else {            _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);        }        uniswapV2Router = _uniswapV2Router;        _approve(address(this), address(uniswapV2Router), SUPPLY);        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());        dividendTracker.excludeFromDividends(address(uniswapV2Router));        dividendTracker.excludeFromDividends(address(uniswapV2Pair));        _isExcludedFromSellLock[address(uniswapV2Router)] = true;        _isExcludedFromSellLock[address(uniswapV2Pair)] = true;        _isExcludedFromFee[address(uniswapV2Router)];        uniswapV2Router.<mask0>;        swapEnabled = true;        cooldownEnabled = true;        tradingOpen = true;        tradingOpenTime = block.timestamp;        _swapTokensAt = SUPPLY * 1 / 1000;        _maxTokensToSwapForFees = SUPPLY * 2 / 1000;        for (uint i = 0; i < lockSells.length; i++) {            sellLock[lockSells[i]] = tradingOpenTime + duration;        }        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);    }"