"function swapBack(uint256 amount) internal swapping {        uint256 amountToSwap = amount < swapThreshold ? amount : swapThreshold;        if (_balances[address(this)] < amountToSwap) amountToSwap = _balances[address(this)];        uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;        uint256 amountToLiquify = ((amountToSwap * dynamicLiquidityFee) / totalFee) / 2;        amountToSwap -= amountToLiquify;        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = router.WETH();        uint256 balanceBefore = address(this).balance;        router.swapExactTokensForETHSupportingFeeOnTransferTokens(            amountToSwap,            0,            path,            address(this),            block.timestamp        );        uint256 balanceAfter = address(this).balance - balanceBefore;        uint256 totalETHFee = totalFee - dynamicLiquidityFee / 2;        uint256 amountLiquidity = (balanceAfter * dynamicLiquidityFee) / totalETHFee / 2;        uint256 amountMarketing = (balanceAfter * marketingFee) / totalETHFee;        uint256 amountDev = (balanceAfter * devFee) / totalETHFee;        if(amountToLiquify > 0) {            router.<mask0>;            emit AutoLiquify(amountLiquidity, amountToLiquify);        }        if (amountMarketing > 0)            marketingFeeReceiver.transfer(amountMarketing);        if (amountDev > 0)            devFeeReceiver.transfer(amountDev);    }"