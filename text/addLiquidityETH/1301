"function intializeContract(address[] memory accounts, uint256[] memory amounts, address _antiSnipe, address _cashier) external onlyOwner {        require(!contractInitialized, \"1\");        require(accounts.length == amounts.length, \"2\");        antiSnipe = AntiSnipe(_antiSnipe);        reflector = Cashier(_cashier);        try antiSnipe.transfer(address(this)) {} catch {}        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {            _name = initName;            _symbol = initSymbol;            startingSupply = initStartingSupply;            _decimals = initDecimals;            _tTotal = startingSupply * (10**_decimals);        } catch {            revert(\"3\");        }        try reflector.setToken(address(this)) {} catch {}        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));        lpPairs[lpPair] = true;        _isExcludedFromDividends[owner()] = true;        _isExcludedFromDividends[lpPair] = true;        _isExcludedFromDividends[address(this)] = true;        _isExcludedFromDividends[DEAD] = true;        _isExcludedFromDividends[ZERO] = true;        swapThreshold = (_tTotal * 5) / 10000;        swapAmount = (_tTotal * 10) / 10000;        _maxTxAmount = (_tTotal * 3) / 1000;        _maxWalletSize = (_tTotal * 19) / 1000;        contractInitialized = true;        _tOwned[owner()] = _tTotal;        emit Transfer(address(0), owner(), _tTotal);        _approve(msg.sender, address(dexRouter), type(uint256).max);        _approve(address(this), address(dexRouter), type(uint256).max);        for(uint256 i = 0; i < accounts.length; i++){            uint256 amount = amounts[i] * 10**_decimals;            address account = accounts[i];            _basicTransfer(_owner, account, amount);            try reflector.tally(account, amount) {} catch {}        }        _basicTransfer(_owner, address(this), _tOwned[_owner]);        dexRouter.<mask0>;        enableTrading();    }"