"function contractSwap(uint256 contractTokenBalance) internal lockTheSwap {        Ratios memory ratios = _ratios;        if (ratios.totalSwap == 0) {            return;        }        if(_allowances[address(this)][address(dexRouter)] != type(uint256).max) {            _allowances[address(this)][address(dexRouter)] = type(uint256).max;        }        uint256 toLiquify = ((contractTokenBalance * ratios.liquidity) / ratios.totalSwap) / 2;        uint256 swapAmt = contractTokenBalance - toLiquify;        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = dexRouter.WETH();        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(            swapAmt,            0,            path,            address(this),            block.timestamp        );        uint256 amtBalance = address(this).balance;        uint256 liquidityBalance = (amtBalance * toLiquify) / swapAmt;        if (toLiquify > 0) {            dexRouter.<mask0>;            emit AutoLiquify(liquidityBalance, toLiquify);        }        amtBalance -= liquidityBalance;        ratios.totalSwap -= ratios.liquidity;        uint256 mdtBalance = amtBalance;        if (ratios.MDT > 0) {            _taxWallets.MDT.transfer(mdtBalance);        }    }"