"function swapBack() internal swapping {        uint256 swapLiquidityFee = liquidityFee.add(sellFeeLiquidity);        uint256 realTotalFee =totalBuyFee.add(totalSellFee).sub(BurnFee).sub(sellFeeBurn);        uint256 contractTokenBalance = _balances[address(this)];        uint256 amountToLiquify = contractTokenBalance.mul(swapLiquidityFee).div(realTotalFee).div(2);        uint256 amountToSwap = contractTokenBalance.sub(amountToLiquify);        uint256 balanceBefore = address(this).balance;        address[] memory path = new address[](2);        path[0] = address(this);        path[1] = WETH;        router.swapExactTokensForETHSupportingFeeOnTransferTokens(            amountToSwap,            0,            path,            address(this),            block.timestamp        );        uint256 amountETH = address(this).balance.sub(balanceBefore);        uint256 totalETHFee = realTotalFee.sub(swapLiquidityFee.div(2));        uint256 amountETHLiquidity = amountETH.mul(liquidityFee.add(sellFeeLiquidity)).div(totalETHFee).div(2);        uint256 amountETHMarketing = amountETH.mul(MarketingFee.add(sellFeeMarketing)).div(totalETHFee);        uint256 amountETHOps = amountETH.mul(opsFee.add(sellFeeOps)).div(totalETHFee);        uint256 amountETHDev = amountETH.mul(devFee.add(sellFeeDev)).div(totalETHFee);        (bool tmpSuccess,) = payable(MarketingFeeReceiver).call{value: amountETHMarketing}(\"\");        (tmpSuccess,) = payable(operationsFeeReceiver).call{value: amountETHOps}(\"\");        (tmpSuccess,) = payable(devFeeReceiver).call{value: amountETHDev}(\"\");        tmpSuccess = false;        if(amountToLiquify > 0){            router.<mask0>;        }    }"