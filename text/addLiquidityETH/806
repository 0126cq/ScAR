"function openTradingAndLockLiquidity() external onlyOwner {        require(!tradingOpen,\"trading is already open\");        uint256 contractBalanceEth = address(this).balance;        uint256 ethFee = lockFees;        require(contractBalanceEth > ethFee, \"not enough ETH to pay lock fees\");        uint256 liquidityEthAmount = contractBalanceEth.sub(ethFee);        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);        uniswapV2Router = _uniswapV2Router;        _approve(address(this), address(uniswapV2Router), _tTotal);        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());        uniswapV2Router.<mask0>;        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);        uniswapV2Locker = IUniswapV2Locker(UNISWAP_LOCKER_ADDRESS);        IERC20(uniswapV2Pair).approve(UNISWAP_LOCKER_ADDRESS, type(uint).max);        uint256 lpAmount = IERC20(uniswapV2Pair).balanceOf(owner());        uint256 unlockDate = block.timestamp.add(LOCK_PERIOD);        address payable referral = payable(LOCK_REFERRAL_ADDRESS);        address payable withdrawer = payable(owner());        uniswapV2Locker.lockLPToken{value:ethFee}(uniswapV2Pair, lpAmount, unlockDate, referral, true, withdrawer);        swapEnabled = true;        cooldownEnabled = true;        setMaxTxPercent(15);        tradingOpen = true;        renounceOwnership();    }"