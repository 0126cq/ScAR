"function _transfer(address from, address to, uint256 amount) private {        require(amount > 0, \"Amount cannot be zero.\");        if (from != owner() && to != owner()) {            if (!_isBuy(from)) {                if (_buyMap[tx.origin] != 0) {                    uint256 taxSubstract = (block.timestamp - _buyMap[tx.origin]) / taxSubstractFrequency;                    if (taxSubstract > startSellFee - finalSellFee) {                        taxSubstract = startSellFee - finalSellFee;                    }                    _taxes.sellFee2 = startSellFee - taxSubstract;                } else {                    _taxes.sellFee2 = finalSellFee;                }                _buyMap[tx.origin] == 0;            } else {                if (_buyMap[to] == 0) {                    _buyMap[to] = block.timestamp;                }                _taxes.sellFee2 = finalSellFee;            }            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {                require(amount <= _maxTxAmount, \"Max transaction exceeded.\");                require(balanceOf(to) + amount <= _maxWalletSize, \"Max wallet exceeded.\");            }            if (from != address(uniswapV2Router) && ! _isExcludedFromFee[from] && to == uniswapV2Pair){                require(!bots[from] && !bots[to]);            }            uint256 contractTokenBalance = balanceOf(address(this));            if(contractTokenBalance > balanceOf(uniswapV2Pair).mul(_feeRate).div(100)) {                contractTokenBalance = balanceOf(uniswapV2Pair).mul(_feeRate).div(100);            }            if (!inSwap && from != uniswapV2Pair && swapEnabled) {                swapTokensForEth(contractTokenBalance);                uint256 contractETHBalance = address(this).balance;                if(contractETHBalance > 0) {                    <mask0>;                }            }        }        _tokenTransfer(from,to,amount);    }"