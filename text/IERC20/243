"function _liquidateReward() internal {    if (!sell()) {      emit ProfitsNotCollected(sell(), false);      return;    }    for(uint256 i = 0; i < rewardTokens.length; i++){      address token = rewardTokens[i];      uint256 rewardBalance = IERC20(token).balanceOf(address(this));      if (rewardBalance == 0 || reward2WETH[token].length < 2) {        continue;      }      address routerV2;      if(useUni[token]) {        routerV2 = uniswapRouterV2;      } else {        routerV2 = sushiswapRouterV2;      }      <mask0>.safeApprove(routerV2, 0);      IERC20(token).safeApprove(routerV2, rewardBalance);      IUniswapV2Router02(routerV2).swapExactTokensForTokens(        rewardBalance, 1, reward2WETH[token], address(this), block.timestamp      );    }    uint256 rewardBalance = IERC20(weth).balanceOf(address(this));    notifyProfitInRewardToken(rewardBalance);    uint256 remainingRewardBalance = IERC20(rewardToken()).balanceOf(address(this));    if (remainingRewardBalance == 0) {      return;    }    address routerV2;    if(useUni[depositToken()]) {      routerV2 = uniswapRouterV2;    } else {      routerV2 = sushiswapRouterV2;    }    IERC20(rewardToken()).safeApprove(routerV2, 0);    IERC20(rewardToken()).safeApprove(routerV2, remainingRewardBalance);    uint256 amountOutMin = 1;    IUniswapV2Router02(routerV2).swapExactTokensForTokens(      remainingRewardBalance,      amountOutMin,      WETH2deposit,      address(this),      block.timestamp    );    uint256 tokenBalance = IERC20(depositToken()).balanceOf(address(this));    if (tokenBalance > 0) {      depositCurve();    }  }"