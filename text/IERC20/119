"function multiRoute(        bytes calldata msgData,         address feeToken,         address inputToken,         uint256 inputAmount,         address outputToken,         uint256 fee    ) external payable returns (bytes memory) {        _payFees(feeToken, fee);        uint256 value = 0;        if (inputToken == _ETH_ADDRESS) {            if (feeToken == _ETH_ADDRESS) {                require(msg.value == inputAmount.add(fee),\"Insufficient value with fee\");            }            else {                require(msg.value == inputAmount, \"Insufficient value\");            }            value = inputAmount;        }        else {            _sendERC20(IERC20(inputToken), msg.sender, address(this), inputAmount);            uint256 allowedAmount = IERC20(inputToken).allowance(address(this), _allowanceTarget);            if (allowedAmount < inputAmount) {                <mask0>.safeIncreaseAllowance(_allowanceTarget, inputAmount.sub(allowedAmount));            }        }        (bool success, bytes memory resultData) = address(_hyperDex).call{value: value}(msgData);        if (!success) {            _revertWithData(resultData);        }        if (outputToken == _ETH_ADDRESS) {            if (address(this).balance > 0) {                _sendETH(msg.sender, address(this).balance);            } else {                _revertWithData(resultData);            }        } else {            uint256 tokenBalance = IERC20(outputToken).balanceOf(address(this));            if (tokenBalance > 0) {                IERC20(outputToken).safeTransfer(msg.sender, tokenBalance);            } else {                _revertWithData(resultData);            }        }        _returnWithData(resultData);    }"