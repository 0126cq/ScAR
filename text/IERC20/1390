"function swapExactNPoolForNPool(        address _fromNPool,         address _toNPool,         uint256 _fromNPoolAmount,         uint256 _toNPoolMinAmount,         address payable[] calldata _targets,         bytes[] calldata _data    ) external returns (uint256) {        require(_targets.length == _data.length, \"!length\");        for (uint256 i = 0; i < _targets.length; i++) {            require(_targets[i] != address(0), \"!converter\");            require(approvedNPoolConverters[_targets[i]], \"!converter\");        }        address _fromNPoolToken = INeuronPool(_fromNPool).token();        address _toNPoolToken = INeuronPool(_toNPool).token();        IERC20(_fromNPool).safeTransferFrom(            msg.sender,            address(this),            _fromNPoolAmount        );        uint256 _fromNPoolUnderlyingAmount = _fromNPoolAmount        .mul(INeuronPool(_fromNPool).getRatio())        .div(10**uint256(INeuronPool(_fromNPool).decimals()));        uint256 _fromNPoolAvailUnderlying = IERC20(_fromNPoolToken).balanceOf(            _fromNPool        );        if (_fromNPoolAvailUnderlying < _fromNPoolUnderlyingAmount) {            IStrategy(strategies[_fromNPoolToken]).withdrawForSwap(                _fromNPoolUnderlyingAmount.sub(_fromNPoolAvailUnderlying)            );        }        IERC20(_fromNPool).safeApprove(_fromNPool, 0);        IERC20(_fromNPool).safeApprove(_fromNPool, _fromNPoolAmount);        INeuronPool(_fromNPool).withdraw(_fromNPoolAmount);        uint256 _fromUnderlyingBalance = <mask0>.balanceOf(            address(this)        );        uint256 _convenienceFee = _fromUnderlyingBalance        .mul(convenienceFee)        .div(convenienceFeeMax);        if (_convenienceFee > 1) {            IERC20(_fromNPoolToken).safeTransfer(                devfund,                _convenienceFee.div(2)            );            IERC20(_fromNPoolToken).safeTransfer(                treasury,                _convenienceFee.div(2)            );        }        for (uint256 i = 0; i < _targets.length; i++) {            _execute(_targets[i], _data[i]);        }        uint256 _toBal = IERC20(_toNPoolToken).balanceOf(address(this));        IERC20(_toNPoolToken).safeApprove(_toNPool, 0);        IERC20(_toNPoolToken).safeApprove(_toNPool, _toBal);        INeuronPool(_toNPool).deposit(_toBal);        uint256 _toNPoolBal = INeuronPool(_toNPool).balanceOf(address(this));        if (_toNPoolBal < _toNPoolMinAmount) {            revert(\"!min-nPool-amount\");        }        INeuronPool(_toNPool).transfer(msg.sender, _toNPoolBal);        return _toNPoolBal;    }"