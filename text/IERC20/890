"function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)        public        nonReentrant        onlyActiveReserve(_reserve)        onlyAmountGreaterThanZero(_amount)    {        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()            ? address(core).balance            : IERC20(_reserve).balanceOf(address(core));        require(            availableLiquidityBefore >= _amount,            \"There is not enough liquidity available to borrow\"        );        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider            .getFlashLoanFeesInBips();        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);        require(            amountFee > 0 && protocolFee > 0,            \"The requested amount is too small for a flashLoan.\"        );        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);        address payable userPayable = address(uint160(_receiver));        core.transferToUser(_reserve, userPayable, _amount);        receiver.executeOperation(_reserve, _amount, amountFee, _params);        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()            ? address(core).balance            : <mask0>.balanceOf(address(core));        require(            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),            \"The actual balance of the protocol is inconsistent\"        );        core.updateStateOnFlashLoan(            _reserve,            availableLiquidityBefore,            amountFee.sub(protocolFee),            protocolFee        );        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);    }"