"function emergencyWithdraw(uint amount) external noContractsAllowed nonReentrant payable {        require(amount > 0, \"invalid amount!\");        require(amount <= depositTokenBalance[msg.sender], \"Cannot withdraw more than deposited!\");        require(block.timestamp.sub(depositTime[msg.sender]) > LOCKUP_DURATION, \"You recently deposited, please wait before withdrawing.\");        updateAccount(msg.sender);        depositTokenBalance[msg.sender] = depositTokenBalance[msg.sender].sub(amount);        totalDepositedTokens = totalDepositedTokens.sub(amount);        uint oldCTokenBalance = <mask0>.balanceOf(address(this));        uint oldEtherBalance = address(this).balance;        require(CEther(TRUSTED_CTOKEN_ADDRESS).redeemUnderlying(amount) == 0, \"redeemUnderlying failed!\");        uint newCTokenBalance = IERC20(TRUSTED_CTOKEN_ADDRESS).balanceOf(address(this));        uint newEtherBalance = address(this).balance;        uint depositTokenReceived = newEtherBalance.sub(oldEtherBalance);        uint cTokenRedeemed = oldCTokenBalance.sub(newCTokenBalance);        IWETH(TRUSTED_DEPOSIT_TOKEN_ADDRESS).deposit{value: depositTokenReceived}();        require(cTokenRedeemed <= cTokenBalance[msg.sender], \"redeem exceeds balance!\");        cTokenBalance[msg.sender] = cTokenBalance[msg.sender].sub(cTokenRedeemed);        totalCTokens = totalCTokens.sub(cTokenRedeemed);        decreaseTokenBalance(TRUSTED_CTOKEN_ADDRESS, cTokenRedeemed);        totalTokensWithdrawnByUser[msg.sender] = totalTokensWithdrawnByUser[msg.sender].add(depositTokenReceived);        uint feeAmount = depositTokenReceived.mul(FEE_PERCENT_X_100).div(ONE_HUNDRED_X_100);        uint depositTokenReceivedAfterFee = depositTokenReceived.sub(feeAmount);        IERC20(TRUSTED_DEPOSIT_TOKEN_ADDRESS).safeTransfer(msg.sender, depositTokenReceivedAfterFee);        if (depositTokenBalance[msg.sender] == 0) {            holders.remove(msg.sender);        }        emit Withdraw(msg.sender, depositTokenReceived);    }"