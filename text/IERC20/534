"function buyItemsManyTokens(        BuyItemParams[] calldata _buyOrders,        uint16 _inputSettingsBitFlag,        address[] calldata _inputTokenAddresses,        uint256[] calldata _maxSpendIncFees    ) external payable {        uint256 i = 0;        uint256 length = _inputTokenAddresses.length;        for (; i < length; ) {            if (_inputTokenAddresses[i] == address(weth) && msg.value > 0) {                if (_maxSpendIncFees[i] != msg.value) revert InvalidMsgValue();            } else {                <mask0>.safeTransferFrom(                    msg.sender,                    address(this),                    _maxSpendIncFees[i]                );                IERC20(_inputTokenAddresses[i]).approve(                    address(troveMarketplace),                    _maxSpendIncFees[i]                );            }            unchecked {                ++i;            }        }        uint256[] memory maxSpends = _maxSpendWithoutFees(_maxSpendIncFees);        (            uint256[] memory totalSpentAmount,            uint256 successCount        ) = _buyItemsManyTokens(                _buyOrders,                _inputSettingsBitFlag,                _inputTokenAddresses,                maxSpends            );        if (successCount == 0) revert AllReverted();        i = 0;        for (; i < length; ) {            uint256 feeAmount = _calculateFee(totalSpentAmount[i]);            if (                _inputTokenAddresses[i] == address(weth) &&                _buyOrders[0].usingEth            ) {                payable(msg.sender).transfer(                    _maxSpendIncFees[i] - (totalSpentAmount[i] + feeAmount)                );            } else {                IERC20(_inputTokenAddresses[i]).safeTransfer(                    msg.sender,                    _maxSpendIncFees[i] - (totalSpentAmount[i] + feeAmount)                );            }            unchecked {                ++i;            }        }    }"