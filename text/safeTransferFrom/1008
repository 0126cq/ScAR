"function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {        IERC20(depositToken).<mask0>;        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);        Proposal storage proposal = proposals[proposalId];        require(proposal.proposer != address(0), \"!proposed\");        require(proposal.flags[0] == 0, \"sponsored\");        require(proposal.flags[3] == 0, \"cancelled\");        require(members[proposal.applicant].jailed == 0, \"applicant jailed\");        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");        }        if (proposal.flags[4] == 1) {            require(!tokenWhitelist[address(proposal.tributeToken)], \"whitelisted\");            require(!proposedToWhitelist[address(proposal.tributeToken)], \"whitelist proposed\");            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");            proposedToWhitelist[address(proposal.tributeToken)] = true;        } else if (proposal.flags[5] == 1) {            require(!proposedToKick[proposal.applicant], \"kick proposed\");            proposedToKick[proposal.applicant] = true;        }        uint256 startingPeriod = max(            getCurrentPeriod(),            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length - 1]].startingPeriod        ) + 1;        proposal.startingPeriod = startingPeriod;        address memberAddress = memberAddressByDelegateKey[msg.sender];        proposal.sponsor = memberAddress;        proposal.flags[0] = 1;         proposalQueue.push(proposalId);        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length - 1, startingPeriod);    }"