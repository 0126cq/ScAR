"function stakeApesWithLoots(uint256[] memory apeIds, uint256[] memory lootIds) public nonReentrant {      require(!depositPaused, \"Deposit paused\");      require(stakingLaunched, \"Staking is not launched yet\");      require(apeIds.length == lootIds.length, \"Lists not same length\");      require(address(LootNft) != address(0), \"Loot Bags staking is not yet enabled\");      Staker storage user = _stakers[_msgSender()];      uint256 newYield = user.currentYield;      for (uint256 i; i < apeIds.length; i++) {        require(IERC721(address(ApeNft)).ownerOf(apeIds[i]) == _msgSender(), \"Not the owner of staking Ape\");        if (lootIds[i] > 0){          require(IERC721(address(LootNft)).ownerOf(lootIds[i]) == _msgSender(), \"Not the owner of staking Loot\");          IERC721(address(LootNft)).<mask0>;          _ownerOfToken[address(LootNft)][lootIds[i]] = _msgSender();          stakerApeLoot[_msgSender()][apeIds[i]] = lootIds[i];        }        IERC721(address(ApeNft)).safeTransferFrom(_msgSender(), address(this), apeIds[i]);        _ownerOfToken[address(ApeNft)][apeIds[i]] = _msgSender();        newYield += getApeLootTokenYield(apeIds[i], lootIds[i]);        user.stakedAPE.push(apeIds[i]);      }      accumulate(_msgSender());      user.currentYield = newYield;      emit StakeApesWithLoots(_msgSender(), apeIds.length);    }"