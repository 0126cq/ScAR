"function composeRe(uint256 tokenIdA, uint256 tokenIdB, uint8[] memory idxs, bool burn) external payable whenNotPaused {        validate(tokenIdA, tokenIdB);        require(idxs.length > 0 && idxs.length <= 8, \"Idxs length is invalid\");        require(idxs.length * _commissionPerItem <= msg.value, \"Insufficient payment\");        Loot memory lootA = _reloots[tokenIdA];        Loot memory lootB = _reloots[tokenIdB];        bool[] memory unsameArmorFlag = new bool[](8);        uint8 unsameArmor;        for (uint8 i = 0; i < idxs.length; i++) {            if (!compareEquipment(lootA.equipment[idxs[i]], lootB.equipment[idxs[i]])) {                if (!unsameArmorFlag[idxs[i]]) {                    unsameArmorFlag[idxs[i]] = true;                    unsameArmor++;                }              }        }        uint8[] memory unsameArmorIdx = new uint8[](unsameArmor);        uint8 j;        for (uint8 i = 0; i < unsameArmorFlag.length; i++) {            if (unsameArmorFlag[i]) {                unsameArmorIdx[j] = i;                j++;             }        }        shuffle(unsameArmorIdx);        uint8 extra = _extraProbability;        if (!burn) {            extra = 0;        }         for (uint8 i = 0; i < unsameArmorIdx.length; i++) {            if (ProbabilityGenerator(_probability[i]+extra)) {                _reloots[tokenIdA].equipment[unsameArmorIdx[i]] = lootB.equipment[unsameArmorIdx[i]];            }        }        if (msg.value != 0) {            address payable owner = payable(owner());            owner.transfer(msg.value);        }        if (burn) {            super.<mask0>;        }    }"