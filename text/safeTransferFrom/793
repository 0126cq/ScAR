"function createLiquidation(        address sponsor,        FixedPoint.Unsigned calldata minCollateralPerToken,        FixedPoint.Unsigned calldata maxCollateralPerToken,        FixedPoint.Unsigned calldata maxTokensToLiquidate,        uint256 deadline    )        external        fees()        onlyPreExpiration()        nonReentrant()        returns (            uint256 liquidationId,            FixedPoint.Unsigned memory tokensLiquidated,            FixedPoint.Unsigned memory finalFeeBond        )    {        require(getCurrentTime() <= deadline, \"Mined after deadline\");        PositionData storage positionToLiquidate = _getPositionData(sponsor);        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);        require(tokensLiquidated.isGreaterThan(0));        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);        }        {            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;            require(                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),                \"CR is more than max liq. price\"            );            require(                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),                \"CR is less than min liq. price\"            );        }        finalFeeBond = _computeFinalFees();        FixedPoint.Unsigned memory lockedCollateral;        FixedPoint.Unsigned memory liquidatedCollateral;        {            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);            lockedCollateral = startCollateral.mul(ratio);            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);            FixedPoint.Unsigned memory withdrawalAmountToRemove =                positionToLiquidate.withdrawalRequestAmount.mul(ratio);            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);        }        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));        liquidationId = liquidations[sponsor].length;        liquidations[sponsor].push(            LiquidationData({                sponsor: sponsor,                liquidator: msg.sender,                state: Status.NotDisputed,                liquidationTime: getCurrentTime(),                tokensOutstanding: tokensLiquidated,                lockedCollateral: lockedCollateral,                liquidatedCollateral: liquidatedCollateral,                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),                disputer: address(0),                settlementPrice: FixedPoint.fromUnscaledUint(0),                finalFee: finalFeeBond            })        );        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;        if (            positionToLiquidate.withdrawalRequestPassTimestamp > 0 &&             positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() &&             tokensLiquidated.isGreaterThanOrEqual(griefingThreshold)         ) {            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);        }        emit LiquidationCreated(            sponsor,            msg.sender,            liquidationId,            tokensLiquidated.rawValue,            lockedCollateral.rawValue,            liquidatedCollateral.rawValue,            getCurrentTime()        );        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);        tokenCurrency.burn(tokensLiquidated.rawValue);        collateralCurrency.<mask0>;    }"