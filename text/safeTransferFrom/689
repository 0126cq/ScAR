"function deposit(uint256 _pid, uint256 _amount) external payable nonReentrant {        _transferPerformanceFee();        PoolInfo storage pool = poolInfo[_pid];        UserInfo storage user = userInfo[_pid][msg.sender];        if(pool.bonusEndBlock < block.number) {            massUpdatePools();            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint);            pool.allocPoint = 0;        } else {            updatePool(_pid);        }        if (user.amount > 0) {            uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt);            if (pending > 0) {                require(availableRewardTokens() >= pending, \"Insufficient reward tokens\");                safeTokenTransfer(msg.sender, pending);                if(totalEarned > pending) {                    totalEarned = totalEarned.sub(pending);                } else {                    totalEarned = 0;                }            }            uint256 pendingReflection = user.amount.mul(pool.accReflectionPerShare).div(1e12).sub(user.reflectionDebt);            pendingReflection = _estimateDividendAmount(pendingReflection);            if (pendingReflection > 0 && hasDividend) {                if(address(reflectionToken) == address(0x0)) {                    payable(msg.sender).transfer(pendingReflection);                } else {                    IERC20(reflectionToken).safeTransfer(msg.sender, pendingReflection);                }                totalReflections = totalReflections.sub(pendingReflection);            }        }        if (_amount > 0) {            uint256 beforeAmt = pool.lpToken.balanceOf(address(this));            pool.lpToken.<mask0>;            uint256 afterAmt = pool.lpToken.balanceOf(address(this));            uint256 amount = afterAmt.sub(beforeAmt);            if (pool.depositFee > 0) {                uint256 depositFee = amount.mul(pool.depositFee).div(10000);                pool.lpToken.safeTransfer(feeAddress, depositFee);                user.amount = user.amount.add(amount).sub(depositFee);            } else {                user.amount = user.amount.add(amount);            }            _calculateTotalStaked(_pid, pool.lpToken, amount, true);        }        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);        user.reflectionDebt = user.amount.mul(pool.accReflectionPerShare).div(1e12);        emit Deposit(msg.sender, _pid, _amount);    }"