"function disputePriceFor(        address disputer,        address requester,        bytes32 identifier,        uint256 timestamp,        bytes memory ancillaryData    ) public override nonReentrant() returns (uint256 totalBond) {        require(disputer != address(0), \"disputer address must be non 0\");        require(            getState(requester, identifier, timestamp, ancillaryData) == State.Proposed,            \"disputePriceFor: Proposed\"        );        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);        request.disputer = disputer;        uint256 finalFee = request.finalFee;        uint256 bond = request.bond;        totalBond = bond.add(finalFee);        if (totalBond > 0) {            request.currency.<mask0>;        }        StoreInterface store = _getStore();        {            uint256 burnedBond = _computeBurnedBond(request);            uint256 totalFee = finalFee.add(burnedBond);            if (totalFee > 0) {                request.currency.safeIncreaseAllowance(address(store), totalFee);                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));            }        }        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));        uint256 refund = 0;        if (request.reward > 0 && request.refundOnDispute) {            refund = request.reward;            request.reward = 0;            request.currency.safeTransfer(requester, refund);        }        emit DisputePrice(            requester,            request.proposer,            disputer,            identifier,            timestamp,            ancillaryData,            request.proposedPrice        );        if (address(requester).isContract())            try OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund) {} catch {}    }"