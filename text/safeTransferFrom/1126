"function redeem(        uint256[] calldata tokenIds,        uint256[] calldata amounts     ) external nonReentrant {        uint256 length = tokenIds.length;        uint256 totalAmount = 0;        for (uint256 i; i < length; ++i) {            totalAmount += amounts[i];            require(balanceOf(msg.sender, tokenIds[i]) >= amounts[i], \"CNFT: Not enough NFTs to redeem\");        }        uint redeemAllowedResult = ComptrollerInterface(comptroller).redeemAllowed(address(this), msg.sender, totalAmount);        require(redeemAllowedResult == 0, \"CNFT: Redeem is not allowed\");        totalBalance[msg.sender] -= totalAmount;        _burnBatch(msg.sender, tokenIds, amounts);        if (is1155) {            IERC1155(underlying).safeBatchTransferFrom(address(this), msg.sender, tokenIds, amounts, \"\");        } else {            if (isPunk) {                for (uint256 i; i < length; ++i) {                    bytes memory data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", msg.sender, tokenIds[i]);                    (bool transferPunkSuccess, bytes memory returnData) = underlying.call(data);                    require(transferPunkSuccess, \"CNFT: Calling transferPunk was unsuccessful\");                }            } else {                for (uint256 i; i < length; ++i) {                    IERC721(underlying).<mask0>;                }            }        }        emit Redeem(msg.sender, tokenIds, amounts);    }"