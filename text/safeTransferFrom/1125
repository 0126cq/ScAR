"function mint(        uint256[] calldata tokenIds,        uint256[] calldata amounts     ) external nonReentrant returns (uint256) {        uint mintAllowedResult = ComptrollerInterface(comptroller).mintAllowed(address(this), msg.sender, 0);        require(mintAllowedResult == 0, \"CNFT: Mint is not allowed\");        uint256 length = tokenIds.length;        uint256 totalAmount = 0;        for (uint256 i; i < length; ++i) {            totalAmount += amounts[i];        }        totalBalance[msg.sender] += totalAmount;        if (is1155) {            IERC1155(underlying).safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");        } else {            if (isPunk) {                for (uint256 i; i < length; ++i) {                    bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenIds[i]);                    (bool checkSuccess, bytes memory result) = underlying.staticcall(punkIndexToAddress);                    (address nftOwner) = abi.decode(result, (address));                    require(checkSuccess && nftOwner == msg.sender, \"Not the NFT owner\");                    bytes memory data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenIds[i]);                    (bool buyPunkSuccess, bytes memory resultData) = underlying.call(data);                    require(buyPunkSuccess, \"CNFT: Calling buyPunk was unsuccessful\");                }            } else {                for (uint256 i; i < length; ++i) {                    IERC721(underlying).<mask0>;                }            }        }        _mintBatch(msg.sender, tokenIds, amounts, \"\");        emit Mint(msg.sender, tokenIds, amounts);        return length;    }"