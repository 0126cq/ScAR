"function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {        uint _pool = balance();        uint _before = token3CRV.balanceOf(address(this));        bool hasStables = false;        for (uint8 i = 0; i < 4; i++) {            uint _inputAmount = _amounts[i];            if (_inputAmount > 0) {                if (i == 3) {                    inputTokens[i].<mask0>;                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);                    hasStables = true;                }            }        }        if (hasStables) {            uint[3] memory _stablesAmounts;            _stablesAmounts[0] = _amounts[0];            _stablesAmounts[1] = _amounts[1];            _stablesAmounts[2] = _amounts[2];            converter.convert_stables(_stablesAmounts);        }        uint _after = token3CRV.balanceOf(address(this));        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");        uint _totalDepositAmount = _after.sub(_before);         require(_totalDepositAmount >= _min_mint_amount, \"slippage\");        if (_totalDepositAmount > 0) {            if (!_isStake) {                _deposit(msg.sender, _pool, _totalDepositAmount);            } else {                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);                _stakeShares(_shares);            }        }    }"