0
ownerOf:function create(        string calldata _name,        string calldata _terms,        address _party,        address _asset,        uint256 _id,        uint256 _due    ) external {        require(            _party == IERC721(_asset).mask(),            "party-B is not asset owner"        );        nft.push(            AgreementNFT(                _name,                _terms,                msg.sender,                _party,                _asset,                _id,                block.timestamp,                _due,                false            )        );        _mint(msg.sender, 1);    }


1
push:function create(        string calldata _name,        string calldata _terms,        address _party,        address _asset,        uint256 _id,        uint256 _due    ) external {        require(            _party == IERC721(_asset).ownerOf(_id),            "party-B is not asset owner"        );        nft.mask();        _mint(msg.sender, 1);    }


2
_mint:function create(        string calldata _name,        string calldata _terms,        address _party,        address _asset,        uint256 _id,        uint256 _due    ) external {        require(            _party == IERC721(_asset).ownerOf(_id),            "party-B is not asset owner"        );        nft.push(            AgreementNFT(                _name,                _terms,                msg.sender,                _party,                _asset,                _id,                block.timestamp,                _due,                false            )        );        mask();    }


3
ownerOf:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).mask()        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


4
encodePacked:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.mask();        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


5
toHexString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).mask(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


6
toHexString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).mask(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


7
toHexString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).mask(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


8
toString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.mask(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


9
encodePacked:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.mask();        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


10
encode:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.mask(),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


11
encodePacked:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.mask()),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


12
toString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.mask(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


13
toString:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.mask(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.encode(meta)                )            );    }


14
encodePacked:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.mask()            );    }


15
encode:function tokenURI(uint256 tokenId)        public        view        virtual        override        tokenExist(tokenId)        returns (string memory)    {        bool signed = nft[tokenId].signed;        string memory status = nft[tokenId].signed ? "Signed" : "Pending";        if (block.timestamp >= nft[tokenId].dueDate) {            status = "Expired";            signed = false;        }        if (            nft[tokenId].partyB !=            IERC721(nft[tokenId].asset).ownerOf(nft[tokenId].assetId)        ) {            status = "Asset Lost";            signed = false;        }        bytes memory meta = abi.encodePacked(            '{"name": "',            nft[tokenId].name,            '", "description": "The Agreement between [',            uint160(nft[tokenId].partyA).toHexString(),            "] and [",            uint160(nft[tokenId].partyB).toHexString(),            "] with Asset {",            uint160(nft[tokenId].asset).toHexString(),            "#",            nft[tokenId].assetId.toString(),            '}",'        );        meta = abi.encodePacked(            meta,            '"image_data": "data:image/svg+xml;base64,',            Base64.encode(abi.encodePacked(_nft_image(signed, tokenId))),            '", "designer": "drzu.xyz",',            '"attributes": [{"trait_type": "SIGN-DATE", "value": "',            nft[tokenId].signDate.toString(),            '"},{"trait_type": "DUE-DATE", "value": "',            nft[tokenId].dueDate.toString(),            '"},',            '{"trait_type": "STATUS", "value": "',            status,            '"}]}'        );        return            string(                abi.encodePacked(                    "data:application/json;base64,",                    Base64.mask()                )            );    }


16
ownerOf:function _verify(address _party, uint256 tokenId) internal {        require(_party == nft[tokenId].partyB, "signer is not partyB");        require(            _party == IERC721(nft[tokenId].asset).mask(),            "party-B is not asset owner"        );        nft[tokenId].signed = true;    }


17
bytes:function toString(uint256 value) internal pure returns (string memory) {        if (value == 0) {            return "0";        }        uint256 temp = value;        uint256 digits;        while (temp != 0) {            digits++;            temp /= 10;        }        bytes memory buffer = new mask();        while (value != 0) {            digits -= 1;            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));            value /= 10;        }        return string(buffer);    }


18
toHexString:function toHexString(uint256 value) internal pure returns (string memory) {        if (value == 0) {            return "0x00";        }        uint256 temp = value;        uint256 length = 0;        while (temp != 0) {            length++;            temp >>= 8;        }        return mask();    }


19
bytes:function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {        bytes memory buffer = new mask();        buffer[0] = "0";        buffer[1] = "x";        for (uint256 i = 2 * length + 1; i > 1; --i) {            buffer[i] = _HEX_SYMBOLS[value & 0xf];            value >>= 4;        }        require(value == 0, "Strings: hex length insufficient");        return string(buffer);    }


20
_startTokenId:function totalSupply() public view returns (uint256) {        unchecked {            return _currentIndex - _burnCounter - mask();        }    }


21
_startTokenId:function _totalMinted() internal view returns (uint256) {        unchecked {            return _currentIndex - mask();        }    }


22
supportsInterface:function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {        return            interfaceId == type(IERC721).interfaceId ||            interfaceId == type(IERC721Metadata).interfaceId ||            super.mask();    }


23
_startTokenId:function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {        uint256 curr = tokenId;        unchecked {            if (mask() <= curr && curr < _currentIndex) {                TokenOwnership memory ownership = _ownerships[curr];                if (!ownership.burned) {                    if (ownership.addr != address(0)) {                        return ownership;                    }                    while (true) {                        curr--;                        ownership = _ownerships[curr];                        if (ownership.addr != address(0)) {                            return ownership;                        }                    }                }            }        }        revert OwnerQueryForNonexistentToken();    }


24
_exists:function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        if (!mask()) revert URIQueryForNonexistentToken();        string memory baseURI = _baseURI();        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';    }


25
_baseURI:function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();        string memory baseURI = mask();        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';    }


26
encodePacked:function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();        string memory baseURI = _baseURI();        return bytes(baseURI).length != 0 ? string(abi.mask()) : '';    }


27
toString:function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();        string memory baseURI = _baseURI();        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.mask())) : '';    }


28
ownerOf:function approve(address to, uint256 tokenId) public override {        address owner = ERC721A.mask();        if (to == owner) revert ApprovalToCurrentOwner();        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {            revert ApprovalCallerNotOwnerNorApproved();        }        _approve(to, tokenId, owner);    }


29
isApprovedForAll:function approve(address to, uint256 tokenId) public override {        address owner = ERC721A.ownerOf(tokenId);        if (to == owner) revert ApprovalToCurrentOwner();        if (_msgSender() != owner && !mask()) {            revert ApprovalCallerNotOwnerNorApproved();        }        _approve(to, tokenId, owner);    }


30
_msgSender:function approve(address to, uint256 tokenId) public override {        address owner = ERC721A.ownerOf(tokenId);        if (to == owner) revert ApprovalToCurrentOwner();        if (mask() != owner && !isApprovedForAll(owner, _msgSender())) {            revert ApprovalCallerNotOwnerNorApproved();        }        _approve(to, tokenId, owner);    }


31
_msgSender:function approve(address to, uint256 tokenId) public override {        address owner = ERC721A.ownerOf(tokenId);        if (to == owner) revert ApprovalToCurrentOwner();        if (_msgSender() != owner && !isApprovedForAll(owner, mask())) {            revert ApprovalCallerNotOwnerNorApproved();        }        _approve(to, tokenId, owner);    }


32
_approve:function approve(address to, uint256 tokenId) public override {        address owner = ERC721A.ownerOf(tokenId);        if (to == owner) revert ApprovalToCurrentOwner();        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {            revert ApprovalCallerNotOwnerNorApproved();        }        mask();    }


33
_exists:function getApproved(uint256 tokenId) public view override returns (address) {        if (!mask()) revert ApprovalQueryForNonexistentToken();        return _tokenApprovals[tokenId];    }


34
_msgSender:function setApprovalForAll(address operator, bool approved) public virtual override {        if (operator == mask()) revert ApproveToCaller();        _operatorApprovals[_msgSender()][operator] = approved;        emit ApprovalForAll(_msgSender(), operator, approved);    }


35
_msgSender:function setApprovalForAll(address operator, bool approved) public virtual override {        if (operator == _msgSender()) revert ApproveToCaller();        _operatorApprovals[mask()][operator] = approved;        emit ApprovalForAll(_msgSender(), operator, approved);    }


36
_msgSender:function setApprovalForAll(address operator, bool approved) public virtual override {        if (operator == _msgSender()) revert ApproveToCaller();        _operatorApprovals[_msgSender()][operator] = approved;        emit ApprovalForAll(mask(), operator, approved);    }


37
_transfer:function transferFrom(        address from,        address to,        uint256 tokenId    ) public virtual override {        mask();    }


38
safeTransferFrom:function safeTransferFrom(        address from,        address to,        uint256 tokenId    ) public virtual override {        mask();    }


39
_transfer:function safeTransferFrom(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) public virtual override {        mask();        if (to.isContract() && !_checkContractOnERC721Received(from, to, tokenId, _data)) {            revert TransferToNonERC721ReceiverImplementer();        }    }


40
isContract:function safeTransferFrom(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) public virtual override {        _transfer(from, to, tokenId);        if (to.mask() && !_checkContractOnERC721Received(from, to, tokenId, _data)) {            revert TransferToNonERC721ReceiverImplementer();        }    }


41
_startTokenId:function _exists(uint256 tokenId) internal view returns (bool) {        return mask() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;    }


42
_safeMint:function _safeMint(address to, uint256 quantity) internal {        mask();    }


43
_beforeTokenTransfers:function _safeMint(        address to,        uint256 quantity,        bytes memory _data    ) internal {        uint256 startTokenId = _currentIndex;        if (to == address(0)) revert MintToZeroAddress();        if (quantity == 0) revert MintZeroQuantity();        mask();        unchecked {            _addressData[to].balance += uint64(quantity);            _addressData[to].numberMinted += uint64(quantity);            _ownerships[startTokenId].addr = to;            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);            uint256 updatedIndex = startTokenId;            uint256 end = updatedIndex + quantity;            if (to.isContract()) {                do {                    emit Transfer(address(0), to, updatedIndex);                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {                        revert TransferToNonERC721ReceiverImplementer();                    }                } while (updatedIndex != end);                if (_currentIndex != startTokenId) revert();            } else {                do {                    emit Transfer(address(0), to, updatedIndex++);                } while (updatedIndex != end);            }            _currentIndex = updatedIndex;        }        _afterTokenTransfers(address(0), to, startTokenId, quantity);    }


44
isContract:function _safeMint(        address to,        uint256 quantity,        bytes memory _data    ) internal {        uint256 startTokenId = _currentIndex;        if (to == address(0)) revert MintToZeroAddress();        if (quantity == 0) revert MintZeroQuantity();        _beforeTokenTransfers(address(0), to, startTokenId, quantity);        unchecked {            _addressData[to].balance += uint64(quantity);            _addressData[to].numberMinted += uint64(quantity);            _ownerships[startTokenId].addr = to;            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);            uint256 updatedIndex = startTokenId;            uint256 end = updatedIndex + quantity;            if (to.mask()) {                do {                    emit Transfer(address(0), to, updatedIndex);                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {                        revert TransferToNonERC721ReceiverImplementer();                    }                } while (updatedIndex != end);                if (_currentIndex != startTokenId) revert();            } else {                do {                    emit Transfer(address(0), to, updatedIndex++);                } while (updatedIndex != end);            }            _currentIndex = updatedIndex;        }        _afterTokenTransfers(address(0), to, startTokenId, quantity);    }


45
_afterTokenTransfers:function _safeMint(        address to,        uint256 quantity,        bytes memory _data    ) internal {        uint256 startTokenId = _currentIndex;        if (to == address(0)) revert MintToZeroAddress();        if (quantity == 0) revert MintZeroQuantity();        _beforeTokenTransfers(address(0), to, startTokenId, quantity);        unchecked {            _addressData[to].balance += uint64(quantity);            _addressData[to].numberMinted += uint64(quantity);            _ownerships[startTokenId].addr = to;            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);            uint256 updatedIndex = startTokenId;            uint256 end = updatedIndex + quantity;            if (to.isContract()) {                do {                    emit Transfer(address(0), to, updatedIndex);                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {                        revert TransferToNonERC721ReceiverImplementer();                    }                } while (updatedIndex != end);                if (_currentIndex != startTokenId) revert();            } else {                do {                    emit Transfer(address(0), to, updatedIndex++);                } while (updatedIndex != end);            }            _currentIndex = updatedIndex;        }        mask();    }


46
_beforeTokenTransfers:function _mint(address to, uint256 quantity) internal {        uint256 startTokenId = _currentIndex;        if (to == address(0)) revert MintToZeroAddress();        if (quantity == 0) revert MintZeroQuantity();        mask();        unchecked {            _addressData[to].balance += uint64(quantity);            _addressData[to].numberMinted += uint64(quantity);            _ownerships[startTokenId].addr = to;            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);            uint256 updatedIndex = startTokenId;            uint256 end = updatedIndex + quantity;            do {                emit Transfer(address(0), to, updatedIndex++);            } while (updatedIndex != end);            _currentIndex = updatedIndex;        }        _afterTokenTransfers(address(0), to, startTokenId, quantity);    }


47
_afterTokenTransfers:function _mint(address to, uint256 quantity) internal {        uint256 startTokenId = _currentIndex;        if (to == address(0)) revert MintToZeroAddress();        if (quantity == 0) revert MintZeroQuantity();        _beforeTokenTransfers(address(0), to, startTokenId, quantity);        unchecked {            _addressData[to].balance += uint64(quantity);            _addressData[to].numberMinted += uint64(quantity);            _ownerships[startTokenId].addr = to;            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);            uint256 updatedIndex = startTokenId;            uint256 end = updatedIndex + quantity;            do {                emit Transfer(address(0), to, updatedIndex++);            } while (updatedIndex != end);            _currentIndex = updatedIndex;        }        mask();    }


48
_msgSender:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, _msgSender()) ||            getApproved(tokenId) == mask());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


49
getApproved:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, _msgSender()) ||            mask() == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


50
isApprovedForAll:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            mask() ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


51
_msgSender:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (mask() == from ||            isApprovedForAll(from, _msgSender()) ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


52
_msgSender:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, mask()) ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


53
_beforeTokenTransfers:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, _msgSender()) ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        mask();        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


54
_approve:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, _msgSender()) ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        mask();        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        _afterTokenTransfers(from, to, tokenId, 1);    }


55
_afterTokenTransfers:function _transfer(        address from,        address to,        uint256 tokenId    ) private {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();        bool isApprovedOrOwner = (_msgSender() == from ||            isApprovedForAll(from, _msgSender()) ||            getApproved(tokenId) == _msgSender());        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        if (to == address(0)) revert TransferToZeroAddress();        _beforeTokenTransfers(from, to, tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            _addressData[from].balance -= 1;            _addressData[to].balance += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = to;            currSlot.startTimestamp = uint64(block.timestamp);            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, to, tokenId);        mask();    }


56
_burn:function _burn(uint256 tokenId) internal virtual {        mask();    }


57
_msgSender:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, _msgSender()) ||                getApproved(tokenId) == mask());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


58
getApproved:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, _msgSender()) ||                mask() == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


59
isApprovedForAll:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                mask() ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


60
_msgSender:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (mask() == from ||                isApprovedForAll(from, _msgSender()) ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


61
_msgSender:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, mask()) ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


62
_beforeTokenTransfers:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, _msgSender()) ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        mask();        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


63
_approve:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, _msgSender()) ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        mask();        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        _afterTokenTransfers(from, address(0), tokenId, 1);        unchecked {            _burnCounter++;        }    }


64
_afterTokenTransfers:function _burn(uint256 tokenId, bool approvalCheck) internal virtual {        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);        address from = prevOwnership.addr;        if (approvalCheck) {            bool isApprovedOrOwner = (_msgSender() == from ||                isApprovedForAll(from, _msgSender()) ||                getApproved(tokenId) == _msgSender());            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();        }        _beforeTokenTransfers(from, address(0), tokenId, 1);        _approve(address(0), tokenId, from);        unchecked {            AddressData storage addressData = _addressData[from];            addressData.balance -= 1;            addressData.numberBurned += 1;            TokenOwnership storage currSlot = _ownerships[tokenId];            currSlot.addr = from;            currSlot.startTimestamp = uint64(block.timestamp);            currSlot.burned = true;            uint256 nextTokenId = tokenId + 1;            TokenOwnership storage nextSlot = _ownerships[nextTokenId];            if (nextSlot.addr == address(0)) {                if (nextTokenId != _currentIndex) {                    nextSlot.addr = from;                    nextSlot.startTimestamp = prevOwnership.startTimestamp;                }            }        }        emit Transfer(from, address(0), tokenId);        mask();        unchecked {            _burnCounter++;        }    }


65
onERC721Received:function _checkContractOnERC721Received(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) private returns (bool) {        try IERC721Receiver(to).mask() returns (bytes4 retval) {            return retval == IERC721Receiver(to).onERC721Received.selector;        } catch (bytes memory reason) {            if (reason.length == 0) {                revert TransferToNonERC721ReceiverImplementer();            } else {                assembly {                    revert(add(32, reason), mload(reason))                }            }        }    }


66
IERC721Receiver:function _checkContractOnERC721Received(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) private returns (bool) {        try mask().onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {            return retval == IERC721Receiver(to).onERC721Received.selector;        } catch (bytes memory reason) {            if (reason.length == 0) {                revert TransferToNonERC721ReceiverImplementer();            } else {                assembly {                    revert(add(32, reason), mload(reason))                }            }        }    }


67
_msgSender:function _checkContractOnERC721Received(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) private returns (bool) {        try IERC721Receiver(to).onERC721Received(mask(), from, tokenId, _data) returns (bytes4 retval) {            return retval == IERC721Receiver(to).onERC721Received.selector;        } catch (bytes memory reason) {            if (reason.length == 0) {                revert TransferToNonERC721ReceiverImplementer();            } else {                assembly {                    revert(add(32, reason), mload(reason))                }            }        }    }


68
IERC721Receiver:function _checkContractOnERC721Received(        address from,        address to,        uint256 tokenId,        bytes memory _data    ) private returns (bool) {        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {            return retval == mask().onERC721Received.selector;        } catch (bytes memory reason) {            if (reason.length == 0) {                revert TransferToNonERC721ReceiverImplementer();            } else {                assembly {                    revert(add(32, reason), mload(reason))                }            }        }    }


69
call:function sendValue(address payable recipient, uint256 amount) internal {        require(address(this).balance >= amount, "Address: insufficient balance");        (bool success, ) = recipient.mask();        require(success, "Address: unable to send value, recipient may have reverted");    }


70
functionCall:function functionCall(address target, bytes memory data) internal returns (bytes memory) {        return mask();    }


71
functionCallWithValue:function functionCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        return mask();    }


72
functionCallWithValue:function functionCallWithValue(        address target,        bytes memory data,        uint256 value    ) internal returns (bytes memory) {        return mask();    }


73
isContract:function functionCallWithValue(        address target,        bytes memory data,        uint256 value,        string memory errorMessage    ) internal returns (bytes memory) {        require(address(this).balance >= value, "Address: insufficient balance for call");        require(mask(), "Address: call to non-contract");        (bool success, bytes memory returndata) = target.call{value: value}(data);        return verifyCallResult(success, returndata, errorMessage);    }


74
call:function functionCallWithValue(        address target,        bytes memory data,        uint256 value,        string memory errorMessage    ) internal returns (bytes memory) {        require(address(this).balance >= value, "Address: insufficient balance for call");        require(isContract(target), "Address: call to non-contract");        (bool success, bytes memory returndata) = target.mask();        return verifyCallResult(success, returndata, errorMessage);    }


75
verifyCallResult:function functionCallWithValue(        address target,        bytes memory data,        uint256 value,        string memory errorMessage    ) internal returns (bytes memory) {        require(address(this).balance >= value, "Address: insufficient balance for call");        require(isContract(target), "Address: call to non-contract");        (bool success, bytes memory returndata) = target.call{value: value}(data);        return mask();    }


76
functionStaticCall:function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {        return mask();    }


77
isContract:function functionStaticCall(        address target,        bytes memory data,        string memory errorMessage    ) internal view returns (bytes memory) {        require(mask(), "Address: static call to non-contract");        (bool success, bytes memory returndata) = target.staticcall(data);        return verifyCallResult(success, returndata, errorMessage);    }


78
staticcall:function functionStaticCall(        address target,        bytes memory data,        string memory errorMessage    ) internal view returns (bytes memory) {        require(isContract(target), "Address: static call to non-contract");        (bool success, bytes memory returndata) = target.mask();        return verifyCallResult(success, returndata, errorMessage);    }


79
verifyCallResult:function functionStaticCall(        address target,        bytes memory data,        string memory errorMessage    ) internal view returns (bytes memory) {        require(isContract(target), "Address: static call to non-contract");        (bool success, bytes memory returndata) = target.staticcall(data);        return mask();    }


80
functionDelegateCall:function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {        return mask();    }


81
isContract:function functionDelegateCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        require(mask(), "Address: delegate call to non-contract");        (bool success, bytes memory returndata) = target.delegatecall(data);        return verifyCallResult(success, returndata, errorMessage);    }


82
delegatecall:function functionDelegateCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        require(isContract(target), "Address: delegate call to non-contract");        (bool success, bytes memory returndata) = target.mask();        return verifyCallResult(success, returndata, errorMessage);    }


83
verifyCallResult:function functionDelegateCall(        address target,        bytes memory data,        string memory errorMessage    ) internal returns (bytes memory) {        require(isContract(target), "Address: delegate call to non-contract");        (bool success, bytes memory returndata) = target.delegatecall(data);        return mask();    }


